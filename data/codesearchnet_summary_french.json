[
  {
    "code": "def addidsuffix(self, idsuffix, recursive = True):\n        \"\"\"Appends a suffix to this element's ID, and optionally to all child IDs as well. There is sually no need to call this directly, invoked implicitly by :meth:`copy`\"\"\"\n        if self.id: self.id += idsuffix\n        if recursive:\n            for e in self:\n                try:\n                    e.addidsuffix(idsuffix, recursive)\n                except Exception:\n                    pass",
    "docstring": "Appends a suffix to this element's ID, and optionally to all child IDs as well. There is sually no need to call this directly, invoked implicitly by :meth:`copy`",
    "summary": "Cette fonction, `addidsuffix`, ajoute un suffixe \u00e0 l'ID de l'\u00e9l\u00e9ment actuel (`self`) et, si l'option `recursive` est activ\u00e9e (ce qui est le cas par d\u00e9faut), elle ajoute \u00e9galement ce suffixe aux ID de tous les \u00e9l\u00e9ments enfants. \n\n**En termes simples :**\n\nImagine que tu as une liste d'\u00e9l\u00e9ments, chacun avec un identifiant unique (ID). Cette fonction te permet d'ajouter un suffixe (comme \"_copie\" par exemple) \u00e0 la fin de l'ID de l'\u00e9l\u00e9ment sur lequel tu l'appliques. Si tu choisis l'option r\u00e9cursive, elle fera la m\u00eame chose pour tous les \u00e9l\u00e9ments qui sont \"\u00e0 l'int\u00e9rieur\" de cet \u00e9l\u00e9ment, comme des sous-\u00e9l\u00e9ments ou des enfants.\n\n**Exemple :**\n\nSi tu as un \u00e9l\u00e9ment avec l'ID \"element_1\" et des enfants avec les ID \"element_1_1\" et \"element_1_2\", et que tu appelles `addidsuffix` avec le suffixe \"_copie\", tu obtiendras :\n\n* ID de l'\u00e9l\u00e9ment actuel : \"element_1_copie\"\n* ID des enfants (si r\u00e9cursif) : \"element_1_1_copie\" et \"element_1_2_copie\"\n\nNote que cette fonction est g\u00e9n\u00e9ralement utilis\u00e9e implicitement par une autre fonction appel\u00e9e `copy`, donc tu n'auras probablement pas besoin de l'appeler directement."
  },
  {
    "code": "def setparents(self):\n        \"\"\"Correct all parent relations for elements within the scop. There is sually no need to call this directly, invoked implicitly by :meth:`copy`\"\"\"\n        for c in self:\n            if isinstance(c, AbstractElement):\n                c.parent = self\n                c.setparents()",
    "docstring": "Correct all parent relations for elements within the scop. There is sually no need to call this directly, invoked implicitly by :meth:`copy`",
    "summary": "Cette fonction, `setparents`, est utilis\u00e9e pour mettre \u00e0 jour les relations parent-enfant entre les \u00e9l\u00e9ments d'une structure (probablement une sorte d'arbre ou de hi\u00e9rarchie). Voici une explication simple en fran\u00e7ais :\n\n1. **Objectif** : La fonction s'assure que chaque \u00e9l\u00e9ment dans la structure a le bon \"parent\". Cela signifie qu'elle corrige les liens entre les \u00e9l\u00e9ments pour qu'ils refl\u00e8tent correctement leur hi\u00e9rarchie.\n\n2. **Fonctionnement** :\n   - Elle parcourt chaque \u00e9l\u00e9ment (`c`) contenu dans `self` (l'objet actuel).\n   - Si l'\u00e9l\u00e9ment `c` est une instance de `AbstractElement` (c'est-\u00e0-dire s'il s'agit d'un type sp\u00e9cifique d'\u00e9l\u00e9ment), elle fait deux choses :\n     - Elle d\u00e9finit le parent de `c` comme \u00e9tant `self` (l'objet actuel).\n     - Elle appelle r\u00e9cursivement la fonction `setparents` sur `c` pour s'assurer que tous les enfants de `c` ont \u00e9galement le bon parent.\n\n3. **Utilisation** : Normalement, vous n'avez pas besoin d'appeler cette fonction directement, car elle est automatiquement invoqu\u00e9e par une autre fonction appel\u00e9e `copy`.\n\nEn r\u00e9sum\u00e9, cette fonction s'assure que la hi\u00e9rarchie des \u00e9l\u00e9ments est correctement \u00e9tablie, en d\u00e9finissant les relations parent-enfant de mani\u00e8re r\u00e9cursive."
  },
  {
    "code": "def setdoc(self,newdoc):\n        \"\"\"Set a different document. Usually no need to call this directly, invoked implicitly by :meth:`copy`\"\"\"\n        self.doc = newdoc\n        if self.doc and self.id:\n            self.doc.index[self.id] = self\n        for c in self:\n            if isinstance(c, AbstractElement):\n                c.setdoc(newdoc)",
    "docstring": "Set a different document. Usually no need to call this directly, invoked implicitly by :meth:`copy`",
    "summary": "Cette fonction, `setdoc`, permet de changer le document associ\u00e9 \u00e0 un objet. Voici une explication \u00e9tape par \u00e9tape en fran\u00e7ais :\n\n1. **Changement du document** : La fonction prend un nouveau document (`newdoc`) en entr\u00e9e et l'assigne \u00e0 l'attribut `doc` de l'objet courant (`self.doc = newdoc`).\n\n2. **Mise \u00e0 jour de l'index** : Si l'objet a un document (`self.doc`) et un identifiant (`self.id`), elle met \u00e0 jour l'index du document pour y associer l'objet courant. Cela signifie que l'objet est enregistr\u00e9 dans l'index du document sous son identifiant.\n\n3. **Propagation du changement aux \u00e9l\u00e9ments enfants** : La fonction parcourt ensuite tous les \u00e9l\u00e9ments enfants (`for c in self`) de l'objet courant. Si un \u00e9l\u00e9ment enfant est une instance de `AbstractElement`, la fonction `setdoc` est appel\u00e9e r\u00e9cursivement sur cet \u00e9l\u00e9ment avec le nouveau document. Cela assure que tous les \u00e9l\u00e9ments enfants sont \u00e9galement mis \u00e0 jour avec le nouveau document.\n\nEn r\u00e9sum\u00e9, cette fonction permet de changer le document associ\u00e9 \u00e0 un objet et \u00e0 ses \u00e9l\u00e9ments enfants, tout en mettant \u00e0 jour l'index du document pour refl\u00e9ter ce changement. Elle est g\u00e9n\u00e9ralement appel\u00e9e implicitement par d'autres m\u00e9thodes, comme `copy`, et n'a pas besoin d'\u00eatre invoqu\u00e9e directement dans la plupart des cas."
  },
  {
    "code": "def hastext(self,cls='current',strict=True, correctionhandling=CorrectionHandling.CURRENT): #pylint: disable=too-many-return-statements\n        \"\"\"Does this element have text (of the specified class)\n\n        By default, and unlike :meth:`text`, this checks strictly, i.e. the element itself must have the text and it is not inherited from its children.\n\n        Parameters:\n            cls (str): The class of the text content to obtain, defaults to ``current``.\n            strict (bool):  Set this if you are strictly interested in the text explicitly associated with the element, without recursing into children. Defaults to ``True``.\n            correctionhandling: Specifies what text to check for when corrections are encountered. The default is ``CorrectionHandling.CURRENT``, which will retrieve the corrected/current text. You can set this to ``CorrectionHandling.ORIGINAL`` if you want the text prior to correction, and ``CorrectionHandling.EITHER`` if you don't care.\n\n        Returns:\n            bool\n        \"\"\"\n        if not self.PRINTABLE: #only printable elements can hold text\n            return False\n        elif self.TEXTCONTAINER:\n            return True\n        else:\n            try:\n                if strict:\n                    self.textcontent(cls, correctionhandling) #will raise NoSuchTextException when not found\n                    return True\n                else:\n                    #Check children\n                    for e in self:\n                        if e.PRINTABLE and not isinstance(e, TextContent):\n                            if e.hastext(cls, strict, correctionhandling):\n                                return True\n\n                    self.textcontent(cls, correctionhandling)  #will raise NoSuchTextException when not found\n                    return True\n            except NoSuchText:\n                return False",
    "docstring": "Does this element have text (of the specified class)\n\n        By default, and unlike :meth:`text`, this checks strictly, i.e. the element itself must have the text and it is not inherited from its children.\n\n        Parameters:\n            cls (str): The class of the text content to obtain, defaults to ``current``.\n            strict (bool):  Set this if you are strictly interested in the text explicitly associated with the element, without recursing into children. Defaults to ``True``.\n            correctionhandling: Specifies what text to check for when corrections are encountered. The default is ``CorrectionHandling.CURRENT``, which will retrieve the corrected/current text. You can set this to ``CorrectionHandling.ORIGINAL`` if you want the text prior to correction, and ``CorrectionHandling.EITHER`` if you don't care.\n\n        Returns:\n            bool",
    "summary": "Cette fonction, `hastext`, v\u00e9rifie si un \u00e9l\u00e9ment sp\u00e9cifique contient du texte d'une certaine classe. Voici une explication simplifi\u00e9e en fran\u00e7ais :\n\n1. **Objectif** : La fonction d\u00e9termine si un \u00e9l\u00e9ment poss\u00e8de du texte, en tenant compte de certains crit\u00e8res comme la classe du texte et la mani\u00e8re dont les corrections sont g\u00e9r\u00e9es.\n\n2. **Param\u00e8tres** :\n   - `cls` : La classe du texte \u00e0 v\u00e9rifier (par d\u00e9faut, c'est `'current'`).\n   - `strict` : Si `True` (par d\u00e9faut), la fonction v\u00e9rifie uniquement si l'\u00e9l\u00e9ment lui-m\u00eame contient le texte, sans regarder dans ses enfants.\n   - `correctionhandling` : D\u00e9termine comment g\u00e9rer les corrections apport\u00e9es au texte (par d\u00e9faut, elle utilise le texte actuel/corrig\u00e9).\n\n3. **Fonctionnement** :\n   - Si l'\u00e9l\u00e9ment n'est pas \"imprimable\" (c'est-\u00e0-dire qu'il ne peut pas contenir de texte), la fonction retourne `False`.\n   - Si l'\u00e9l\u00e9ment est un conteneur de texte, la fonction retourne `True`.\n   - Sinon, elle v\u00e9rifie si le texte existe en fonction des param\u00e8tres `strict` et `correctionhandling`.\n   - Si `strict` est `True`, elle essaie de trouver le texte directement dans l'\u00e9l\u00e9ment. Si elle ne le trouve pas, elle retourne `False`.\n   - Si `strict` est `False`, elle v\u00e9rifie \u00e9galement dans les enfants de l'\u00e9l\u00e9ment. Si elle trouve le texte quelque part, elle retourne `True`.\n\n4. **Retour** : La fonction retourne `True` si le texte est trouv\u00e9 selon les crit\u00e8res, sinon `False`.\n\nEn r\u00e9sum\u00e9, cette fonction permet de savoir si un \u00e9l\u00e9ment ou ses enfants contiennent un certain type de texte, en tenant compte de param\u00e8tres sp\u00e9cifiques."
  },
  {
    "code": "def hasphon(self,cls='current',strict=True,correctionhandling=CorrectionHandling.CURRENT): #pylint: disable=too-many-return-statements\n        \"\"\"Does this element have phonetic content (of the specified class)\n\n        By default, and unlike :meth:`phon`, this checks strictly, i.e. the element itself must have the phonetic content and it is not inherited from its children.\n\n        Parameters:\n            cls (str): The class of the phonetic content to obtain, defaults to ``current``.\n            strict (bool):  Set this if you are strictly interested in the phonetic content explicitly associated with the element, without recursing into children. Defaults to ``True``.\n            correctionhandling: Specifies what phonetic content to check for when corrections are encountered. The default is ``CorrectionHandling.CURRENT``, which will retrieve the corrected/current phonetic content. You can set this to ``CorrectionHandling.ORIGINAL`` if you want the phonetic content prior to correction, and ``CorrectionHandling.EITHER`` if you don't care.\n\n        Returns:\n            bool\n        \"\"\"\n        if not self.SPEAKABLE: #only printable elements can hold text\n            return False\n        elif self.PHONCONTAINER:\n            return True\n        else:\n            try:\n                if strict:\n                    self.phoncontent(cls, correctionhandling)\n                    return True\n                else:\n                    #Check children\n                    for e in self:\n                        if e.SPEAKABLE and not isinstance(e, PhonContent):\n                            if e.hasphon(cls, strict, correctionhandling):\n                                return True\n\n                    self.phoncontent(cls)  #will raise NoSuchTextException when not found\n                    return True\n            except NoSuchPhon:\n                return False",
    "docstring": "Does this element have phonetic content (of the specified class)\n\n        By default, and unlike :meth:`phon`, this checks strictly, i.e. the element itself must have the phonetic content and it is not inherited from its children.\n\n        Parameters:\n            cls (str): The class of the phonetic content to obtain, defaults to ``current``.\n            strict (bool):  Set this if you are strictly interested in the phonetic content explicitly associated with the element, without recursing into children. Defaults to ``True``.\n            correctionhandling: Specifies what phonetic content to check for when corrections are encountered. The default is ``CorrectionHandling.CURRENT``, which will retrieve the corrected/current phonetic content. You can set this to ``CorrectionHandling.ORIGINAL`` if you want the phonetic content prior to correction, and ``CorrectionHandling.EITHER`` if you don't care.\n\n        Returns:\n            bool",
    "summary": "Cette fonction, `hasphon`, v\u00e9rifie si un \u00e9l\u00e9ment donn\u00e9 poss\u00e8de un contenu phon\u00e9tique sp\u00e9cifique. Voici une explication simplifi\u00e9e en fran\u00e7ais :\n\n1. **Objectif** : La fonction d\u00e9termine si l'\u00e9l\u00e9ment sur lequel elle est appel\u00e9e contient des informations phon\u00e9tiques (par exemple, une transcription phon\u00e9tique) d'une certaine classe.\n\n2. **Param\u00e8tres** :\n   - `cls` : Sp\u00e9cifie la classe du contenu phon\u00e9tique \u00e0 v\u00e9rifier (par d\u00e9faut, c'est \"current\").\n   - `strict` : Si `True` (par d\u00e9faut), la fonction v\u00e9rifie uniquement si l'\u00e9l\u00e9ment lui-m\u00eame poss\u00e8de le contenu phon\u00e9tique, sans regarder ses enfants. Si `False`, elle v\u00e9rifie aussi dans les \u00e9l\u00e9ments enfants.\n   - `correctionhandling` : D\u00e9termine comment g\u00e9rer les corrections \u00e9ventuelles dans le contenu phon\u00e9tique. Par d\u00e9faut, elle utilise le contenu phon\u00e9tique actuel (corrig\u00e9), mais on peut aussi demander le contenu original ou accepter les deux.\n\n3. **Fonctionnement** :\n   - Si l'\u00e9l\u00e9ment n'est pas \"parlable\" (c'est-\u00e0-dire qu'il ne peut pas contenir de texte), la fonction retourne `False`.\n   - Si l'\u00e9l\u00e9ment est un conteneur phon\u00e9tique, elle retourne `True`.\n   - Sinon, elle v\u00e9rifie si l'\u00e9l\u00e9ment ou ses enfants (selon le param\u00e8tre `strict`) poss\u00e8dent le contenu phon\u00e9tique sp\u00e9cifi\u00e9. Si c'est le cas, elle retourne `True`, sinon `False`.\n\n4. **Retour** : La fonction retourne `True` si le contenu phon\u00e9tique est trouv\u00e9, sinon `False`.\n\nEn r\u00e9sum\u00e9, cette fonction permet de savoir si un \u00e9l\u00e9ment ou ses enfants contiennent des informations phon\u00e9tiques sp\u00e9cifiques, en tenant compte de param\u00e8tres comme la classe et la gestion des corrections."
  },
  {
    "code": "def settext(self, text, cls='current'):\n        \"\"\"Set the text for this element.\n\n        Arguments:\n            text (str): The text\n            cls (str): The class of the text, defaults to ``current`` (leave this unless you know what you are doing). There may be only one text content element of each class associated with the element.\n        \"\"\"\n        self.replace(TextContent, value=text, cls=cls)",
    "docstring": "Set the text for this element.\n\n        Arguments:\n            text (str): The text\n            cls (str): The class of the text, defaults to ``current`` (leave this unless you know what you are doing). There may be only one text content element of each class associated with the element.",
    "summary": "Cette fonction, `settext`, permet de d\u00e9finir ou de modifier le texte associ\u00e9 \u00e0 un \u00e9l\u00e9ment sp\u00e9cifique. Voici ce qu'elle fait en termes simples :\n\n1. **Texte** (`text`) : Elle prend un texte en entr\u00e9e (par exemple, une cha\u00eene de caract\u00e8res) et l'associe \u00e0 l'\u00e9l\u00e9ment sur lequel elle est appel\u00e9e.\n  \n2. **Classe** (`cls`) : Elle permet \u00e9galement de sp\u00e9cifier une \"classe\" pour ce texte. Par d\u00e9faut, cette classe est d\u00e9finie sur `\"current\"`, mais elle peut \u00eatre personnalis\u00e9e si n\u00e9cessaire. La classe aide \u00e0 identifier ou \u00e0 cat\u00e9goriser le texte, surtout si plusieurs textes diff\u00e9rents sont associ\u00e9s au m\u00eame \u00e9l\u00e9ment.\n\n3. **Remplacement** : Si un texte de la m\u00eame classe existe d\u00e9j\u00e0 pour cet \u00e9l\u00e9ment, il sera remplac\u00e9 par le nouveau texte fourni.\n\nEn r\u00e9sum\u00e9, cette fonction met \u00e0 jour ou d\u00e9finit le texte d'un \u00e9l\u00e9ment, en permettant de le classer si besoin. C'est utile pour g\u00e9rer dynamiquement le contenu textuel d'un \u00e9l\u00e9ment dans une interface ou une structure de donn\u00e9es."
  },
  {
    "code": "def setdocument(self, doc):\n        \"\"\"Associate a document with this element.\n\n        Arguments:\n            doc (:class:`Document`): A document\n\n        Each element must be associated with a FoLiA document.\n        \"\"\"\n        assert isinstance(doc, Document)\n\n        if not self.doc:\n            self.doc = doc\n            if self.id:\n                if self.id in doc:\n                    raise DuplicateIDError(self.id)\n                else:\n                    self.doc.index[id] = self\n\n        for e in self: #recursive for all children\n            if isinstance(e,AbstractElement): e.setdocument(doc)",
    "docstring": "Associate a document with this element.\n\n        Arguments:\n            doc (:class:`Document`): A document\n\n        Each element must be associated with a FoLiA document.",
    "summary": "Cette fonction, `setdocument`, permet d'associer un document FoLiA \u00e0 un \u00e9l\u00e9ment donn\u00e9. Voici une explication \u00e9tape par \u00e9tape :\n\n1. **Objectif** : Chaque \u00e9l\u00e9ment doit \u00eatre li\u00e9 \u00e0 un document FoLiA. Cette fonction assure cette association.\n\n2. **Param\u00e8tre** :\n   - `doc` : Un objet de type `Document` qui repr\u00e9sente le document FoLiA \u00e0 associer.\n\n3. **V\u00e9rification** :\n   - La fonction v\u00e9rifie d'abord que `doc` est bien une instance de la classe `Document`.\n\n4. **Association du document** :\n   - Si l'\u00e9l\u00e9ment n'a pas encore de document associ\u00e9 (`self.doc` est vide), il associe le document pass\u00e9 en param\u00e8tre (`self.doc = doc`).\n   - Si l'\u00e9l\u00e9ment a un identifiant (`self.id`), la fonction v\u00e9rifie si cet identifiant existe d\u00e9j\u00e0 dans le document. Si c'est le cas, elle l\u00e8ve une erreur (`DuplicateIDError`). Sinon, elle ajoute l'\u00e9l\u00e9ment \u00e0 l'index du document.\n\n5. **R\u00e9cursivit\u00e9** :\n   - La fonction parcourt ensuite tous les enfants de l'\u00e9l\u00e9ment (`for e in self`). Si un enfant est une instance de `AbstractElement`, la fonction s'appelle elle-m\u00eame (`e.setdocument(doc)`) pour associer le document \u00e0 tous les \u00e9l\u00e9ments enfants de mani\u00e8re r\u00e9cursive.\n\nEn r\u00e9sum\u00e9, cette fonction assure que l'\u00e9l\u00e9ment et tous ses descendants sont correctement li\u00e9s au document FoLiA, en g\u00e9rant les identifiants uniques et en \u00e9vitant les doublons."
  },
  {
    "code": "def addable(Class, parent, set=None, raiseexceptions=True):\n        \"\"\"Tests whether a new element of this class can be added to the parent.\n\n        This method is mostly for internal use.\n        This will use the ``OCCURRENCES`` property, but may be overidden by subclasses for more customised behaviour.\n\n        Parameters:\n            parent (:class:`AbstractElement`): The element that is being added to\n            set (str or None): The set\n            raiseexceptions (bool): Raise an exception if the element can't be added?\n\n        Returns:\n            bool\n\n        Raises:\n            ValueError\n         \"\"\"\n\n\n        if not parent.__class__.accepts(Class, raiseexceptions, parent):\n            return False\n\n        if Class.OCCURRENCES > 0:\n            #check if the parent doesn't have too many already\n            count = parent.count(Class,None,True,[True, AbstractStructureElement]) #never descend into embedded structure annotatioton\n            if count >= Class.OCCURRENCES:\n                if raiseexceptions:\n                    if parent.id:\n                        extra = ' (id=' + parent.id + ')'\n                    else:\n                        extra = ''\n                    raise DuplicateAnnotationError(\"Unable to add another object of type \" + Class.__name__ + \" to \" + parent.__class__.__name__ + \" \" + extra + \". There are already \" + str(count) + \" instances of this class, which is the maximum.\")\n                else:\n                    return False\n\n        if Class.OCCURRENCES_PER_SET > 0 and set and Class.REQUIRED_ATTRIBS and Attrib.CLASS in Class.REQUIRED_ATTRIBS:\n            count = parent.count(Class,set,True, [True, AbstractStructureElement])\n            if count >= Class.OCCURRENCES_PER_SET:\n                if raiseexceptions:\n                    if parent.id:\n                        extra = ' (id=' + parent.id + ')'\n                    else:\n                        extra = ''\n                    raise DuplicateAnnotationError(\"Unable to add another object of set \" + set + \" and type \" + Class.__name__ + \" to \" + parent.__class__.__name__ + \" \" + extra + \". There are already \" + str(count) + \" instances of this class, which is the maximum for the set.\")\n                else:\n                    return False\n\n\n\n        return True",
    "docstring": "Tests whether a new element of this class can be added to the parent.\n\n        This method is mostly for internal use.\n        This will use the ``OCCURRENCES`` property, but may be overidden by subclasses for more customised behaviour.\n\n        Parameters:\n            parent (:class:`AbstractElement`): The element that is being added to\n            set (str or None): The set\n            raiseexceptions (bool): Raise an exception if the element can't be added?\n\n        Returns:\n            bool\n\n        Raises:\n            ValueError",
    "summary": "Cette fonction, `addable`, v\u00e9rifie si un nouvel \u00e9l\u00e9ment d'une certaine classe peut \u00eatre ajout\u00e9 \u00e0 un \u00e9l\u00e9ment parent donn\u00e9. Voici une explication simplifi\u00e9e en fran\u00e7ais :\n\n1. **Objectif** : La fonction d\u00e9termine si un nouvel objet d'une classe sp\u00e9cifique peut \u00eatre ajout\u00e9 \u00e0 un \u00e9l\u00e9ment parent sans violer les r\u00e8gles de limitation d\u00e9finies (comme le nombre maximum d'occurrences autoris\u00e9es).\n\n2. **Param\u00e8tres** :\n   - **Class** : La classe de l'\u00e9l\u00e9ment que l'on souhaite ajouter.\n   - **parent** : L'\u00e9l\u00e9ment parent auquel on veut ajouter le nouvel \u00e9l\u00e9ment.\n   - **set** : Optionnel, un ensemble sp\u00e9cifique dans lequel l'\u00e9l\u00e9ment doit \u00eatre ajout\u00e9 (peut \u00eatre `None`).\n   - **raiseexceptions** : Si `True`, une exception sera lev\u00e9e si l'ajout n'est pas possible. Si `False`, la fonction retournera simplement `False`.\n\n3. **Fonctionnement** :\n   - **V\u00e9rification initiale** : Elle v\u00e9rifie d'abord si la classe de l'\u00e9l\u00e9ment parent accepte la classe de l'\u00e9l\u00e9ment \u00e0 ajouter.\n   - **Limite globale** : Si la classe a une limite globale d'occurrences (`OCCURRENCES`), elle v\u00e9rifie si le nombre d'instances existantes dans le parent ne d\u00e9passe pas cette limite.\n   - **Limite par ensemble** : Si la classe a une limite d'occurrences par ensemble (`OCCURRENCES_PER_SET`) et si un ensemble est sp\u00e9cifi\u00e9, elle v\u00e9rifie si le nombre d'instances dans cet ensemble ne d\u00e9passe pas la limite.\n   - **Retour** : Si toutes les v\u00e9rifications sont r\u00e9ussies, la fonction retourne `True`. Sinon, elle retourne `False` ou l\u00e8ve une exception selon la valeur de `raiseexceptions`.\n\n4. **Exceptions** : Si l'ajout n'est pas possible et que `raiseexceptions` est `True`, une exception `DuplicateAnnotationError` est lev\u00e9e avec un message explicatif.\n\nEn r\u00e9sum\u00e9, cette fonction est un garde-fou pour s'assurer que l'ajout d'un nouvel \u00e9l\u00e9ment respecte les contraintes d\u00e9finies par la classe et le parent."
  },
  {
    "code": "def postappend(self):\n        \"\"\"This method will be called after an element is added to another and does some checks.\n\n        It can do extra checks and if necessary raise exceptions to prevent addition. By default makes sure the right document is associated.\n\n        This method is mostly for internal use.\n        \"\"\"\n\n        #If the element was not associated with a document yet, do so now (and for all unassociated children:\n        if not self.doc and self.parent.doc:\n            self.setdocument(self.parent.doc)\n\n        if self.doc and self.doc.deepvalidation:\n            self.deepvalidation()",
    "docstring": "This method will be called after an element is added to another and does some checks.\n\n        It can do extra checks and if necessary raise exceptions to prevent addition. By default makes sure the right document is associated.\n\n        This method is mostly for internal use.",
    "summary": "Voici une explication simple en fran\u00e7ais de ce que fait cette fonction :\n\nLa fonction `postappend` est appel\u00e9e automatiquement apr\u00e8s qu'un \u00e9l\u00e9ment a \u00e9t\u00e9 ajout\u00e9 \u00e0 un autre. Son r\u00f4le principal est de v\u00e9rifier que tout est correct apr\u00e8s cette op\u00e9ration et, si n\u00e9cessaire, de corriger ou d'emp\u00eacher des erreurs.\n\nVoici ce qu'elle fait en d\u00e9tail :\n\n1. **Association \u00e0 un document** : Si l'\u00e9l\u00e9ment ajout\u00e9 n'est pas encore associ\u00e9 \u00e0 un document, mais que son parent l'est, la fonction associe automatiquement l'\u00e9l\u00e9ment (et ses enfants non associ\u00e9s) au m\u00eame document que son parent.\n\n2. **Validation approfondie** : Si le document associ\u00e9 a une option de validation approfondie activ\u00e9e (`deepvalidation`), la fonction lance une v\u00e9rification d\u00e9taill\u00e9e de l'\u00e9l\u00e9ment pour s'assurer qu'il respecte toutes les r\u00e8gles ou conditions n\u00e9cessaires.\n\nEn r\u00e9sum\u00e9, cette fonction s'assure que l'ajout d'un \u00e9l\u00e9ment est coh\u00e9rent et valide, en g\u00e9rant les associations de documents et en effectuant des v\u00e9rifications suppl\u00e9mentaires si n\u00e9cessaire. Elle est principalement utilis\u00e9e en interne pour maintenir l'int\u00e9grit\u00e9 des donn\u00e9es."
  },
  {
    "code": "def deepvalidation(self):\n        \"\"\"Perform deep validation of this element.\n\n        Raises:\n            :class:`DeepValidationError`\n        \"\"\"\n        if self.doc and self.doc.deepvalidation and self.set and self.set[0] != '_':\n            try:\n                self.doc.setdefinitions[self.set].testclass(self.cls)\n            except KeyError:\n                if self.cls and not self.doc.allowadhocsets:\n                    raise DeepValidationError(\"Set definition \" + self.set + \" for \" + self.XMLTAG + \" not loaded!\")\n            except DeepValidationError as e:\n                errormsg =  str(e) + \" (in set \" + self.set+\" for \" + self.XMLTAG\n                if self.id:\n                    errormsg += \" with ID \" + self.id\n                errormsg += \")\"\n                raise DeepValidationError(errormsg)",
    "docstring": "Perform deep validation of this element.\n\n        Raises:\n            :class:`DeepValidationError`",
    "summary": "Cette fonction, `deepvalidation`, effectue une validation approfondie d'un \u00e9l\u00e9ment sp\u00e9cifique dans un document. Voici ce qu'elle fait en termes simples :\n\n1. **V\u00e9rification des conditions** : Elle v\u00e9rifie d'abord si le document (`self.doc`) existe, si la validation approfondie est activ\u00e9e (`self.doc.deepvalidation`), si un ensemble (`self.set`) est d\u00e9fini, et si cet ensemble ne commence pas par un soulign\u00e9 (`_`).\n\n2. **Test de la classe** : Si toutes ces conditions sont remplies, elle essaie de tester la classe (`self.cls`) de l'\u00e9l\u00e9ment en utilisant la d\u00e9finition de l'ensemble correspondant (`self.doc.setdefinitions[self.set].testclass`).\n\n3. **Gestion des erreurs** :\n   - Si la d\u00e9finition de l'ensemble n'est pas trouv\u00e9e (`KeyError`), elle v\u00e9rifie si une classe est d\u00e9finie et si les ensembles ad hoc ne sont pas autoris\u00e9s (`self.doc.allowadhocsets`). Si c'est le cas, elle l\u00e8ve une erreur (`DeepValidationError`) indiquant que la d\u00e9finition de l'ensemble n'a pas \u00e9t\u00e9 charg\u00e9e.\n   - Si une erreur de validation approfondie (`DeepValidationError`) se produit pendant le test, elle construit un message d'erreur plus d\u00e9taill\u00e9 en incluant le nom de l'ensemble, le tag XML de l'\u00e9l\u00e9ment (`self.XMLTAG`), et \u00e9ventuellement l'ID de l'\u00e9l\u00e9ment (`self.id`), puis l\u00e8ve une nouvelle erreur avec ce message.\n\nEn r\u00e9sum\u00e9, cette fonction s'assure que l'\u00e9l\u00e9ment est correctement valid\u00e9 selon les r\u00e8gles d\u00e9finies dans son ensemble, et elle g\u00e8re les erreurs de mani\u00e8re informative."
  },
  {
    "code": "def findreplaceables(Class, parent, set=None,**kwargs):\n        \"\"\"Internal method to find replaceable elements. Auxiliary function used by :meth:`AbstractElement.replace`. Can be overriden for more fine-grained control.\"\"\"\n        return list(parent.select(Class,set,False))",
    "docstring": "Internal method to find replaceable elements. Auxiliary function used by :meth:`AbstractElement.replace`. Can be overriden for more fine-grained control.",
    "summary": "Cette fonction, `findreplaceables`, est une m\u00e9thode interne utilis\u00e9e pour trouver des \u00e9l\u00e9ments rempla\u00e7ables dans une structure donn\u00e9e. Voici une explication simple en fran\u00e7ais :\n\n1. **Objectif** : La fonction identifie les \u00e9l\u00e9ments d'une certaine classe (`Class`) qui peuvent \u00eatre remplac\u00e9s dans une structure parent (`parent`).\n\n2. **Param\u00e8tres** :\n   - `Class` : Le type d'\u00e9l\u00e9ment que l'on cherche \u00e0 remplacer.\n   - `parent` : La structure ou l'\u00e9l\u00e9ment parent dans lequel on cherche les \u00e9l\u00e9ments rempla\u00e7ables.\n   - `set` : Un ensemble optionnel de crit\u00e8res suppl\u00e9mentaires pour filtrer les \u00e9l\u00e9ments (par d\u00e9faut, `None`).\n   - `**kwargs` : Des arguments suppl\u00e9mentaires qui peuvent \u00eatre pass\u00e9s \u00e0 la fonction (non utilis\u00e9s explicitement ici).\n\n3. **Fonctionnement** :\n   - La fonction utilise la m\u00e9thode `select` de l'objet `parent` pour trouver tous les \u00e9l\u00e9ments de la classe sp\u00e9cifi\u00e9e (`Class`).\n   - Le param\u00e8tre `False` indique que la recherche ne doit pas \u00eatre r\u00e9cursive (elle ne cherche pas dans les sous-\u00e9l\u00e9ments).\n\n4. **R\u00e9sultat** :\n   - La fonction retourne une liste des \u00e9l\u00e9ments trouv\u00e9es qui peuvent \u00eatre remplac\u00e9s.\n\n5. **Utilisation** :\n   - Cette fonction est utilis\u00e9e comme auxiliaire par la m\u00e9thode `replace` de la classe `AbstractElement` pour identifier les \u00e9l\u00e9ments \u00e0 remplacer.\n   - Elle peut \u00eatre red\u00e9finie (overriden) pour un contr\u00f4le plus pr\u00e9cis sur la fa\u00e7on dont les \u00e9l\u00e9ments sont s\u00e9lectionn\u00e9s.\n\nEn r\u00e9sum\u00e9, `findreplaceables` est une fonction utilitaire qui aide \u00e0 trouver des \u00e9l\u00e9ments sp\u00e9cifiques dans une structure pour les remplacer, avec la possibilit\u00e9 d'adapter son comportement si n\u00e9cessaire."
  },
  {
    "code": "def updatetext(self):\n        \"\"\"Recompute textual value based on the text content of the children. Only supported on elements that are a ``TEXTCONTAINER``\"\"\"\n        if self.TEXTCONTAINER:\n            s = \"\"\n            for child in self:\n                if isinstance(child, AbstractElement):\n                    child.updatetext()\n                    s += child.text()\n                elif isstring(child):\n                    s += child\n            self.data = [s]",
    "docstring": "Recompute textual value based on the text content of the children. Only supported on elements that are a ``TEXTCONTAINER``",
    "summary": "Cette fonction, `updatetext`, met \u00e0 jour la valeur textuelle d'un \u00e9l\u00e9ment en se basant sur le contenu textuel de ses enfants. Voici une explication \u00e9tape par \u00e9tape :\n\n1. **V\u00e9rification du type d'\u00e9l\u00e9ment** : La fonction v\u00e9rifie d'abord si l'\u00e9l\u00e9ment actuel est un `TEXTCONTAINER`. Si ce n'est pas le cas, la fonction ne fait rien.\n\n2. **Initialisation d'une cha\u00eene vide** : Si l'\u00e9l\u00e9ment est un `TEXTCONTAINER`, une cha\u00eene vide `s` est cr\u00e9\u00e9e pour stocker le texte cumul\u00e9.\n\n3. **Parcours des enfants** : La fonction parcourt ensuite tous les enfants de l'\u00e9l\u00e9ment actuel.\n\n4. **Traitement des enfants** :\n   - Si un enfant est une instance de `AbstractElement`, la fonction appelle r\u00e9cursivement `updatetext` sur cet enfant pour mettre \u00e0 jour son texte, puis ajoute le texte de l'enfant \u00e0 la cha\u00eene `s`.\n   - Si un enfant est une simple cha\u00eene de caract\u00e8res (v\u00e9rifi\u00e9 par `isstring`), cette cha\u00eene est directement ajout\u00e9e \u00e0 `s`.\n\n5. **Mise \u00e0 jour de la donn\u00e9e** : Une fois tous les enfants trait\u00e9s, la cha\u00eene `s` (qui contient maintenant le texte cumul\u00e9 de tous les enfants) est stock\u00e9e dans l'attribut `data` de l'\u00e9l\u00e9ment actuel, sous forme d'une liste contenant une seule cha\u00eene.\n\nEn r\u00e9sum\u00e9, cette fonction regroupe tout le texte des enfants d'un \u00e9l\u00e9ment `TEXTCONTAINER` et le stocke dans l'attribut `data` de cet \u00e9l\u00e9ment."
  },
  {
    "code": "def replace(self, child, *args, **kwargs):\n        \"\"\"Appends a child element like ``append()``, but replaces any existing child element of the same type and set. If no such child element exists, this will act the same as append()\n\n        Keyword arguments:\n            alternative (bool): If set to True, the *replaced* element will be made into an alternative. Simply use :meth:`AbstractElement.append` if you want the added element\n            to be an alternative.\n\n        See :meth:`AbstractElement.append` for more information and all parameters.\n        \"\"\"\n\n        if 'set' in kwargs:\n            set = kwargs['set']\n            del kwargs['set']\n        else:\n            try:\n                set = child.set\n            except AttributeError:\n                set = None\n\n        if inspect.isclass(child):\n            Class = child\n            replace = Class.findreplaceables(self, set, **kwargs)\n        elif (self.TEXTCONTAINER or self.PHONCONTAINER) and isstring(child):\n            #replace will replace ALL text content, removing text markup along the way!\n            self.data = []\n            return self.append(child, *args,**kwargs)\n        else:\n            Class = child.__class__\n            kwargs['instance'] = child\n            replace = Class.findreplaceables(self,set,**kwargs)\n            del kwargs['instance']\n\n        kwargs['set'] = set #was deleted temporarily for findreplaceables\n\n        if len(replace) == 0:\n            #nothing to replace, simply call append\n            if 'alternative' in kwargs:\n                del kwargs['alternative'] #has other meaning in append()\n            return self.append(child, *args, **kwargs)\n        elif len(replace) > 1:\n            raise Exception(\"Unable to replace. Multiple candidates found, unable to choose.\")\n        elif len(replace) == 1:\n            if 'alternative' in kwargs and kwargs['alternative']:\n                #old version becomes alternative\n                if replace[0] in self.data:\n                    self.data.remove(replace[0])\n                alt = self.append(Alternative)\n                alt.append(replace[0])\n                del kwargs['alternative'] #has other meaning in append()\n            else:\n                #remove old version competely\n                self.remove(replace[0])\n            e = self.append(child, *args, **kwargs)\n            self.updatetext()\n            return e",
    "docstring": "Appends a child element like ``append()``, but replaces any existing child element of the same type and set. If no such child element exists, this will act the same as append()\n\n        Keyword arguments:\n            alternative (bool): If set to True, the *replaced* element will be made into an alternative. Simply use :meth:`AbstractElement.append` if you want the added element\n            to be an alternative.\n\n        See :meth:`AbstractElement.append` for more information and all parameters.",
    "summary": "Cette fonction `replace` permet d'ajouter un \u00e9l\u00e9ment enfant \u00e0 un objet, tout en rempla\u00e7ant un \u00e9l\u00e9ment existant du m\u00eame type et du m\u00eame ensemble (set), si un tel \u00e9l\u00e9ment existe d\u00e9j\u00e0. Voici une explication d\u00e9taill\u00e9e en fran\u00e7ais :\n\n1. **Fonctionnement de base** :  \n   - Si un \u00e9l\u00e9ment du m\u00eame type et du m\u00eame ensemble existe d\u00e9j\u00e0, il est remplac\u00e9 par le nouvel \u00e9l\u00e9ment `child`.  \n   - Si aucun \u00e9l\u00e9ment correspondant n'existe, la fonction se comporte comme `append()`, c'est-\u00e0-dire qu'elle ajoute simplement le nouvel \u00e9l\u00e9ment.  \n\n2. **Param\u00e8tres sp\u00e9ciaux** :  \n   - **`alternative (bool)`** : Si ce param\u00e8tre est d\u00e9fini \u00e0 `True`, l'\u00e9l\u00e9ment remplac\u00e9 est transform\u00e9 en \"alternative\" plut\u00f4t que d'\u00eatre supprim\u00e9. Cela signifie qu'il est conserv\u00e9, mais sous une forme diff\u00e9rente.  \n   - **`set`** : Sp\u00e9cifie l'ensemble (set) auquel l'\u00e9l\u00e9ment appartient. Si non fourni, il est r\u00e9cup\u00e9r\u00e9 de l'\u00e9l\u00e9ment `child` lui-m\u00eame.  \n\n3. **Cas particuliers** :  \n   - Si `child` est une cha\u00eene de caract\u00e8res et que l'objet contient du texte, la fonction remplace tout le contenu textuel existant.  \n   - Si plusieurs \u00e9l\u00e9ments correspondants sont trouv\u00e9s, une exception est lev\u00e9e car la fonction ne peut pas choisir lequel remplacer.  \n\n4. **Processus de remplacement** :  \n   - L'\u00e9l\u00e9ment \u00e0 remplacer est identifi\u00e9 via la m\u00e9thode `findreplaceables` de la classe de `child`.  \n   - Si un \u00e9l\u00e9ment est trouv\u00e9, il est soit supprim\u00e9, soit transform\u00e9 en alternative (selon le param\u00e8tre `alternative`).  \n   - Le nouvel \u00e9l\u00e9ment `child` est ensuite ajout\u00e9 avec `append()`.  \n\n5. **Mise \u00e0 jour finale** :  \n   - Apr\u00e8s le remplacement, la m\u00e9thode `updatetext()` est appel\u00e9e pour mettre \u00e0 jour le contenu textuel si n\u00e9cessaire.  \n\nEn r\u00e9sum\u00e9, cette fonction permet de g\u00e9rer intelligemment l'ajout ou le remplacement d'\u00e9l\u00e9ments enfants, en tenant compte de leur type, de leur ensemble et des options suppl\u00e9mentaires comme `alternative`."
  },
  {
    "code": "def ancestors(self, Class=None):\n        \"\"\"Generator yielding all ancestors of this element, effectively back-tracing its path to the root element. A tuple of multiple classes may be specified.\n\n        Arguments:\n            *Class: The class or classes (:class:`AbstractElement` or subclasses). Not instances!\n\n        Yields:\n            elements (instances derived from :class:`AbstractElement`)\n        \"\"\"\n        e = self\n        while e:\n            if e.parent:\n                e = e.parent\n                if not Class or isinstance(e,Class):\n                    yield e\n                elif isinstance(Class, tuple):\n                    for C in Class:\n                        if isinstance(e,C):\n                            yield e\n            else:\n                break",
    "docstring": "Generator yielding all ancestors of this element, effectively back-tracing its path to the root element. A tuple of multiple classes may be specified.\n\n        Arguments:\n            *Class: The class or classes (:class:`AbstractElement` or subclasses). Not instances!\n\n        Yields:\n            elements (instances derived from :class:`AbstractElement`)",
    "summary": "Cette fonction, `ancestors`, est un g\u00e9n\u00e9rateur qui permet de parcourir tous les anc\u00eatres d'un \u00e9l\u00e9ment donn\u00e9 dans une structure hi\u00e9rarchique, en remontant jusqu'\u00e0 l'\u00e9l\u00e9ment racine. Voici une explication d\u00e9taill\u00e9e en fran\u00e7ais :\n\n1. **Objectif** : La fonction retourne tous les \u00e9l\u00e9ments anc\u00eatres de l'\u00e9l\u00e9ment actuel (`self`), en suivant le chemin qui m\u00e8ne \u00e0 l'\u00e9l\u00e9ment racine.\n\n2. **Param\u00e8tre `Class`** :  \n   - Ce param\u00e8tre est optionnel et peut \u00eatre une classe (ou un tuple de classes) d\u00e9riv\u00e9e de `AbstractElement`.  \n   - Si `Class` est sp\u00e9cifi\u00e9, la fonction ne retourne que les anc\u00eatres qui sont des instances de cette classe (ou de l'une des classes du tuple).  \n   - Si `Class` n'est pas sp\u00e9cifi\u00e9, tous les anc\u00eatres sont retourn\u00e9s, quelle que soit leur classe.\n\n3. **Fonctionnement** :  \n   - La fonction commence par l'\u00e9l\u00e9ment actuel (`self`) et remonte la hi\u00e9rarchie en v\u00e9rifiant le parent de chaque \u00e9l\u00e9ment (`e.parent`).  \n   - Si un parent existe, elle v\u00e9rifie si ce parent correspond \u00e0 la classe sp\u00e9cifi\u00e9e (ou \u00e0 l'une des classes du tuple).  \n   - Si c'est le cas, le parent est retourn\u00e9 (via `yield`).  \n   - Ce processus continue jusqu'\u00e0 ce qu'il n'y ait plus de parent (c'est-\u00e0-dire jusqu'\u00e0 l'\u00e9l\u00e9ment racine).\n\n4. **Exemple d'utilisation** :  \n   Si vous avez une hi\u00e9rarchie d'\u00e9l\u00e9ments et que vous voulez r\u00e9cup\u00e9rer tous les anc\u00eatres d'un \u00e9l\u00e9ment sp\u00e9cifique qui sont de type `MonElement`, vous pouvez appeler la fonction comme suit :  \n   ```python\n   for ancetre in element.ancestors(MonElement):\n       print(ancetre)\n   ```\n\n5. **Remarque** :  \n   - La fonction utilise `yield`, ce qui signifie qu'elle est un g\u00e9n\u00e9rateur et retourne les \u00e9l\u00e9ments un par un au fur et \u00e0 mesure de leur d\u00e9couverte, sans stocker toute la liste en m\u00e9moire.  \n   - Elle s'arr\u00eate d\u00e8s qu'elle atteint l'\u00e9l\u00e9ment racine (c'est-\u00e0-dire un \u00e9l\u00e9ment sans parent).\n\nEn r\u00e9sum\u00e9, cette fonction est utile pour explorer la hi\u00e9rarchie des \u00e9l\u00e9ments en remontant vers la racine, avec la possibilit\u00e9 de filtrer les r\u00e9sultats par type de classe."
  },
  {
    "code": "def ancestor(self, *Classes):\n        \"\"\"Find the most immediate ancestor of the specified type, multiple classes may be specified.\n\n        Arguments:\n            *Classes: The possible classes (:class:`AbstractElement` or subclasses) to select from. Not instances!\n\n        Example::\n\n            paragraph = word.ancestor(folia.Paragraph)\n        \"\"\"\n        for e in self.ancestors(tuple(Classes)):\n            return e\n        raise NoSuchAnnotation",
    "docstring": "Find the most immediate ancestor of the specified type, multiple classes may be specified.\n\n        Arguments:\n            *Classes: The possible classes (:class:`AbstractElement` or subclasses) to select from. Not instances!\n\n        Example::\n\n            paragraph = word.ancestor(folia.Paragraph)",
    "summary": "Cette fonction, `ancestor`, permet de trouver l'anc\u00eatre le plus proche (ou imm\u00e9diat) d'un \u00e9l\u00e9ment donn\u00e9 qui correspond \u00e0 l'un des types de classes sp\u00e9cifi\u00e9s. Voici une explication d\u00e9taill\u00e9e :\n\n1. **Objectif** : Elle recherche dans la hi\u00e9rarchie des anc\u00eatres de l'\u00e9l\u00e9ment actuel (`self`) le premier anc\u00eatre qui est une instance de l'une des classes pass\u00e9es en argument.\n\n2. **Arguments** :\n   - `*Classes` : Un ensemble de classes (pas des instances) qui peuvent \u00eatre des sous-classes de `AbstractElement`. Ces classes repr\u00e9sentent les types d'anc\u00eatres que l'on cherche.\n\n3. **Fonctionnement** :\n   - La fonction parcourt les anc\u00eatres de `self` en utilisant la m\u00e9thode `self.ancestors(tuple(Classes))`.\n   - D\u00e8s qu'elle trouve un anc\u00eatre qui correspond \u00e0 l'une des classes sp\u00e9cifi\u00e9es, elle le retourne.\n   - Si aucun anc\u00eatre correspondant n'est trouv\u00e9, elle l\u00e8ve une exception `NoSuchAnnotation`.\n\n4. **Exemple** :\n   - `paragraph = word.ancestor(folia.Paragraph)` : Cela cherche l'anc\u00eatre le plus proche de `word` qui est une instance de `folia.Paragraph`.\n\nEn r\u00e9sum\u00e9, cette fonction est utile pour naviguer dans une hi\u00e9rarchie d'\u00e9l\u00e9ments et trouver rapidement un anc\u00eatre sp\u00e9cifique en fonction de son type."
  },
  {
    "code": "def xml(self, attribs = None,elements = None, skipchildren = False):\n        \"\"\"Serialises the FoLiA element and all its contents to XML.\n\n        Arguments are mostly for internal use.\n\n        Returns:\n            an lxml.etree.Element\n\n        See also:\n            :meth:`AbstractElement.xmlstring` - for direct string output\n        \"\"\"\n        E = ElementMaker(namespace=NSFOLIA,nsmap={None: NSFOLIA, 'xml' : \"http://www.w3.org/XML/1998/namespace\"})\n\n        if not attribs: attribs = {}\n        if not elements: elements = []\n\n        if self.id:\n            attribs['{http://www.w3.org/XML/1998/namespace}id'] = self.id\n\n        #Some attributes only need to be added if they are not the same as what's already set in the declaration\n        if not isinstance(self, AbstractAnnotationLayer):\n            if '{' + NSFOLIA + '}set' not in attribs: #do not override if overloaded function already set it\n                try:\n                    if self.set:\n                        if not self.ANNOTATIONTYPE in self.doc.annotationdefaults or len(self.doc.annotationdefaults[self.ANNOTATIONTYPE]) != 1 or list(self.doc.annotationdefaults[self.ANNOTATIONTYPE].keys())[0] != self.set:\n                            if self.set != None:\n                                if self.ANNOTATIONTYPE in self.doc.set_alias and self.set in self.doc.set_alias[self.ANNOTATIONTYPE]:\n                                    attribs['{' + NSFOLIA + '}set'] = self.doc.set_alias[self.ANNOTATIONTYPE][self.set] #use alias instead\n                                else:\n                                    attribs['{' + NSFOLIA + '}set'] = self.set\n                except AttributeError:\n                    pass\n\n        if '{' + NSFOLIA + '}class' not in attribs: #do not override if caller already set it\n            try:\n                if self.cls:\n                    attribs['{' + NSFOLIA + '}class'] = self.cls\n            except AttributeError:\n                pass\n\n        if '{' + NSFOLIA + '}annotator' not in attribs: #do not override if caller already set it\n            try:\n                if self.annotator and ((not (self.ANNOTATIONTYPE in self.doc.annotationdefaults)) or (not ( 'annotator' in self.doc.annotationdefaults[self.ANNOTATIONTYPE][self.set])) or (self.annotator != self.doc.annotationdefaults[self.ANNOTATIONTYPE][self.set]['annotator'])):\n                    attribs['{' + NSFOLIA + '}annotator'] = self.annotator\n                if self.annotatortype and ((not (self.ANNOTATIONTYPE in self.doc.annotationdefaults)) or (not ('annotatortype' in self.doc.annotationdefaults[self.ANNOTATIONTYPE][self.set])) or (self.annotatortype != self.doc.annotationdefaults[self.ANNOTATIONTYPE][self.set]['annotatortype'])):\n                    if self.annotatortype == AnnotatorType.AUTO:\n                        attribs['{' + NSFOLIA + '}annotatortype'] = 'auto'\n                    elif self.annotatortype == AnnotatorType.MANUAL:\n                        attribs['{' + NSFOLIA + '}annotatortype'] = 'manual'\n            except AttributeError:\n                pass\n\n        if '{' + NSFOLIA + '}confidence' not in attribs: #do not override if caller already set it\n            if self.confidence:\n                attribs['{' + NSFOLIA + '}confidence'] = str(self.confidence)\n\n        if '{' + NSFOLIA + '}n' not in attribs: #do not override if caller already set it\n            if self.n:\n                attribs['{' + NSFOLIA + '}n'] = str(self.n)\n\n        if '{' + NSFOLIA + '}auth' not in attribs: #do not override if caller already set it\n            try:\n                if not self.AUTH or not self.auth: #(former is static, latter isn't)\n                    attribs['{' + NSFOLIA + '}auth'] = 'no'\n            except AttributeError:\n                pass\n\n        if '{' + NSFOLIA + '}datetime' not in attribs: #do not override if caller already set it\n            if self.datetime and ((not (self.ANNOTATIONTYPE in self.doc.annotationdefaults)) or (not ( 'datetime' in self.doc.annotationdefaults[self.ANNOTATIONTYPE][self.set])) or (self.datetime != self.doc.annotationdefaults[self.ANNOTATIONTYPE][self.set]['datetime'])):\n                attribs['{' + NSFOLIA + '}datetime'] = self.datetime.strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n        if '{' + NSFOLIA + '}src' not in attribs: #do not override if caller already set it\n            if self.src:\n                attribs['{' + NSFOLIA + '}src'] = self.src\n\n        if '{' + NSFOLIA + '}speaker' not in attribs: #do not override if caller already set it\n            if self.speaker:\n                attribs['{' + NSFOLIA + '}speaker'] = self.speaker\n\n        if '{' + NSFOLIA + '}begintime' not in attribs: #do not override if caller already set it\n            if self.begintime:\n                attribs['{' + NSFOLIA + '}begintime'] = \"%02d:%02d:%02d.%03d\" % self.begintime\n\n        if '{' + NSFOLIA + '}endtime' not in attribs: #do not override if caller already set it\n            if self.endtime:\n                attribs['{' + NSFOLIA + '}endtime'] = \"%02d:%02d:%02d.%03d\" % self.endtime\n\n        if '{' + NSFOLIA + '}textclass' not in attribs: #do not override if caller already set it\n            if self.textclass and self.textclass != \"current\":\n                attribs['{' + NSFOLIA + '}textclass'] = self.textclass\n\n        if '{' + NSFOLIA + '}metadata' not in attribs: #do not override if caller already set it\n            if self.metadata:\n                attribs['{' + NSFOLIA + '}metadata'] = self.metadata\n\n        if self.XLINK:\n            if self.href:\n                attribs['{http://www.w3.org/1999/xlink}href'] = self.href\n                if not self.xlinktype:\n                    attribs['{http://www.w3.org/1999/xlink}type'] = \"simple\"\n            if self.xlinktype:\n                attribs['{http://www.w3.org/1999/xlink}type'] = self.xlinktype\n            if self.xlinklabel:\n                attribs['{http://www.w3.org/1999/xlink}label'] = self.xlinklabel\n            if self.xlinkrole:\n                attribs['{http://www.w3.org/1999/xlink}role'] = self.xlinkrole\n            if self.xlinkshow:\n                attribs['{http://www.w3.org/1999/xlink}show'] = self.xlinkshow\n            if self.xlinktitle:\n                attribs['{http://www.w3.org/1999/xlink}title'] = self.xlinktitle\n\n        omitchildren =  []\n\n        #Are there predetermined Features in ACCEPTED_DATA?\n        for c in self.ACCEPTED_DATA:\n            if issubclass(c, Feature) and c.SUBSET:\n                #Do we have any of those?\n                for c2 in self.data:\n                    if c2.__class__ is c and c.SUBSET == c2.SUBSET and c2.cls:\n                        #Yes, serialize them as attributes\n                        attribs[c2.SUBSET] = c2.cls\n                        omitchildren.append(c2) #and skip them as elements\n                        break #only one\n\n        e  = makeelement(E, '{' + NSFOLIA + '}' + self.XMLTAG, **attribs)\n\n\n\n        if not skipchildren and self.data:\n            #append children,\n            # we want make sure that text elements are in the right order, 'current' class first\n            # so we first put them in  a list\n            textelements = []\n            otherelements = []\n            for child in self:\n                if isinstance(child, TextContent):\n                    if child.cls == 'current':\n                        textelements.insert(0, child)\n                    else:\n                        textelements.append(child)\n                elif not child in omitchildren:\n                    otherelements.append(child)\n            for child in textelements+otherelements:\n                if (self.TEXTCONTAINER or self.PHONCONTAINER) and isstring(child):\n                    if len(e) == 0:\n                        if e.text:\n                            e.text += child\n                        else:\n                            e.text = child\n                    else:\n                        #add to tail of last child\n                        if e[-1].tail:\n                            e[-1].tail += child\n                        else:\n                            e[-1].tail = child\n\n                else:\n                    xml = child.xml() #may return None in rare occassions, meaning we wan to skip\n                    if not xml is None:\n                        e.append(xml)\n\n        if elements: #extra elements\n            for e2 in elements:\n                if isinstance(e2, str) or (sys.version < '3' and isinstance(e2, unicode)):\n                    if e.text is None:\n                        e.text = e2\n                    else:\n                        e.text += e2\n                else:\n                    e.append(e2)\n        return e",
    "docstring": "Serialises the FoLiA element and all its contents to XML.\n\n        Arguments are mostly for internal use.\n\n        Returns:\n            an lxml.etree.Element\n\n        See also:\n            :meth:`AbstractElement.xmlstring` - for direct string output",
    "summary": "Cette fonction, nomm\u00e9e `xml`, est utilis\u00e9e pour convertir un \u00e9l\u00e9ment FoLiA (Format for Linguistic Annotation) et son contenu en une repr\u00e9sentation XML. Voici une explication simplifi\u00e9e de ce qu'elle fait :\n\n1. **Initialisation** : La fonction commence par cr\u00e9er un constructeur d'\u00e9l\u00e9ments XML (`ElementMaker`) configur\u00e9 pour utiliser le namespace FoLiA.\n\n2. **Gestion des attributs** : Elle v\u00e9rifie et initialise les dictionnaires `attribs` et `elements` s'ils ne sont pas fournis. Ensuite, elle ajoute des attributs XML sp\u00e9cifiques en fonction des propri\u00e9t\u00e9s de l'objet (comme `id`, `set`, `class`, `annotator`, etc.). Ces attributs sont ajout\u00e9s uniquement s'ils ne sont pas d\u00e9j\u00e0 pr\u00e9sents pour \u00e9viter les doublons.\n\n3. **Construction de l'\u00e9l\u00e9ment XML** : Elle cr\u00e9e un \u00e9l\u00e9ment XML correspondant \u00e0 l'objet FoLiA en utilisant les attributs pr\u00e9par\u00e9s.\n\n4. **Ajout des enfants** : Si l'option `skipchildren` n'est pas activ\u00e9e, la fonction parcourt les enfants de l'objet et les ajoute \u00e0 l'\u00e9l\u00e9ment XML. Elle g\u00e8re sp\u00e9cialement les \u00e9l\u00e9ments de texte pour s'assurer qu'ils sont dans le bon ordre.\n\n5. **Ajout d'\u00e9l\u00e9ments suppl\u00e9mentaires** : Si des \u00e9l\u00e9ments suppl\u00e9mentaires sont fournis via le param\u00e8tre `elements`, ils sont ajout\u00e9s \u00e0 l'\u00e9l\u00e9ment XML.\n\n6. **Retour de l'\u00e9l\u00e9ment XML** : Enfin, la fonction retourne l'\u00e9l\u00e9ment XML complet, pr\u00eat \u00e0 \u00eatre utilis\u00e9 ou s\u00e9rialis\u00e9.\n\nEn r\u00e9sum\u00e9, cette fonction transforme un objet FoLiA en une structure XML bien form\u00e9e, en tenant compte de ses attributs, de ses enfants et de diverses options de configuration."
  },
  {
    "code": "def json(self, attribs=None, recurse=True, ignorelist=False):\n        \"\"\"Serialises the FoLiA element and all its contents to a Python dictionary suitable for serialisation to JSON.\n\n        Example::\n\n            import json\n            json.dumps(word.json())\n\n        Returns:\n            dict\n        \"\"\"\n        jsonnode = {}\n\n        jsonnode['type'] = self.XMLTAG\n        if self.id:\n            jsonnode['id'] = self.id\n        if self.set:\n            jsonnode['set'] = self.set\n        if self.cls:\n            jsonnode['class'] = self.cls\n        if self.annotator:\n            jsonnode['annotator'] = self.annotator\n        if self.annotatortype:\n            if self.annotatortype == AnnotatorType.AUTO:\n                jsonnode['annotatortype'] = \"auto\"\n            elif self.annotatortype == AnnotatorType.MANUAL:\n                jsonnode['annotatortype'] = \"manual\"\n        if self.confidence is not None:\n            jsonnode['confidence'] = self.confidence\n        if self.n:\n            jsonnode['n'] = self.n\n        if self.auth:\n            jsonnode['auth'] = self.auth\n        if self.datetime:\n            jsonnode['datetime'] = self.datetime.strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n        if recurse: #pylint: disable=too-many-nested-blocks\n            jsonnode['children'] = []\n            if self.TEXTCONTAINER:\n                jsonnode['text'] = self.text()\n            if self.PHONCONTAINER:\n                jsonnode['phon'] = self.phon()\n            for child in self:\n                if self.TEXTCONTAINER and isstring(child):\n                    jsonnode['children'].append(child)\n                elif not self.PHONCONTAINER:\n                    #check ignore list\n                    ignore = False\n                    if ignorelist:\n                        for e in ignorelist:\n                            if isinstance(child,e):\n                                ignore = True\n                                break\n                    if not ignore:\n                        jsonnode['children'].append(child.json(attribs,recurse,ignorelist))\n\n        if attribs:\n            for attrib in attribs:\n                jsonnode[attrib] = attribs\n\n        return jsonnode",
    "docstring": "Serialises the FoLiA element and all its contents to a Python dictionary suitable for serialisation to JSON.\n\n        Example::\n\n            import json\n            json.dumps(word.json())\n\n        Returns:\n            dict",
    "summary": "Cette fonction, nomm\u00e9e `json`, est une m\u00e9thode d'une classe (probablement une classe repr\u00e9sentant un \u00e9l\u00e9ment FoLiA, un format de donn\u00e9es pour l'annotation linguistique). Son r\u00f4le principal est de **convertir l'\u00e9l\u00e9ment FoLiA et son contenu en un dictionnaire Python pr\u00eat \u00e0 \u00eatre transform\u00e9 en format JSON**.\n\nVoici une explication \u00e9tape par \u00e9tape en fran\u00e7ais :\n\n1. **Initialisation** : La fonction commence par cr\u00e9er un dictionnaire vide `jsonnode` qui stockera les donn\u00e9es au format JSON.\n\n2. **Ajout des attributs de base** : Elle ajoute des informations de base de l'\u00e9l\u00e9ment FoLiA dans `jsonnode`, comme son type (`type`), son identifiant (`id`), son ensemble (`set`), sa classe (`class`), son annotateur (`annotator`), le type d'annotateur (`annotatortype`), la confiance (`confidence`), le nombre (`n`), l'auteur (`auth`), et la date/heure (`datetime`).\n\n3. **R\u00e9cursivit\u00e9 (si activ\u00e9e)** : Si le param\u00e8tre `recurse` est `True`, la fonction explore r\u00e9cursivement les enfants de l'\u00e9l\u00e9ment FoLiA. Elle ajoute le texte (`text`) et la phonologie (`phon`) si l'\u00e9l\u00e9ment les contient. Ensuite, elle parcourt chaque enfant et les ajoute au dictionnaire `jsonnode` sous la cl\u00e9 `children`. Si une liste d'\u00e9l\u00e9ments \u00e0 ignorer (`ignorelist`) est fournie, ces \u00e9l\u00e9ments sont exclus.\n\n4. **Ajout d'attributs suppl\u00e9mentaires** : Si des attributs suppl\u00e9mentaires sont fournis via le param\u00e8tre `attribs`, ils sont ajout\u00e9s au dictionnaire `jsonnode`.\n\n5. **Retour du r\u00e9sultat** : Enfin, la fonction retourne le dictionnaire `jsonnode`, qui repr\u00e9sente l'\u00e9l\u00e9ment FoLiA et son contenu au format JSON.\n\nEn r\u00e9sum\u00e9, cette fonction transforme un \u00e9l\u00e9ment FoLiA en une structure de donn\u00e9es Python (dictionnaire) pr\u00eate \u00e0 \u00eatre convertie en JSON, en incluant ou en excluant des \u00e9l\u00e9ments selon les param\u00e8tres fournis."
  },
  {
    "code": "def xmlstring(self, pretty_print=False):\n        \"\"\"Serialises this FoLiA element and all its contents to XML.\n\n        Returns:\n            str: a string with XML representation for this element and all its children\"\"\"\n        s = ElementTree.tostring(self.xml(), xml_declaration=False, pretty_print=pretty_print, encoding='utf-8')\n        if sys.version < '3':\n            if isinstance(s, str):\n                s = unicode(s,'utf-8') #pylint: disable=undefined-variable\n        else:\n            if isinstance(s,bytes):\n                s = str(s,'utf-8')\n\n        s = s.replace('ns0:','') #ugly patch to get rid of namespace prefix\n        s = s.replace(':ns0','')\n        return s",
    "docstring": "Serialises this FoLiA element and all its contents to XML.\n\n        Returns:\n            str: a string with XML representation for this element and all its children",
    "summary": "Cette fonction, `xmlstring`, sert \u00e0 convertir un \u00e9l\u00e9ment FoLiA (un format de donn\u00e9es pour la linguistique) et tout son contenu en une cha\u00eene de caract\u00e8res XML. Voici ce qu'elle fait en d\u00e9tail :\n\n1. **S\u00e9rialisation en XML** : Elle prend l'\u00e9l\u00e9ment FoLiA actuel (repr\u00e9sent\u00e9 par `self`) et le convertit, ainsi que tous ses \u00e9l\u00e9ments enfants, en une repr\u00e9sentation XML.\n\n2. **Options de formatage** : L'argument `pretty_print` permet de choisir si le XML g\u00e9n\u00e9r\u00e9 doit \u00eatre indent\u00e9 et facile \u00e0 lire (`True`) ou compact (`False`).\n\n3. **Encodage** : Le XML est g\u00e9n\u00e9r\u00e9 en UTF-8 pour garantir la compatibilit\u00e9 avec les caract\u00e8res sp\u00e9ciaux.\n\n4. **Compatibilit\u00e9 Python** : La fonction g\u00e8re les diff\u00e9rences entre Python 2 et Python 3 pour s'assurer que la cha\u00eene de caract\u00e8res est correctement encod\u00e9e en Unicode.\n\n5. **Suppression des pr\u00e9fixes de namespace** : Elle retire les pr\u00e9fixes de namespace (`ns0:`) du XML g\u00e9n\u00e9r\u00e9 pour obtenir une sortie plus propre.\n\n6. **Retour du r\u00e9sultat** : Enfin, elle retourne la cha\u00eene de caract\u00e8res XML pr\u00eate \u00e0 \u00eatre utilis\u00e9e ou enregistr\u00e9e.\n\nEn r\u00e9sum\u00e9, cette fonction transforme un \u00e9l\u00e9ment FoLiA en une cha\u00eene XML bien form\u00e9e et lisible, en g\u00e9rant les d\u00e9tails techniques comme l'encodage et les namespaces."
  },
  {
    "code": "def select(self, Class, set=None, recursive=True,  ignore=True, node=None): #pylint: disable=bad-classmethod-argument,redefined-builtin\n        \"\"\"Select child elements of the specified class.\n\n        A further restriction can be made based on set.\n\n        Arguments:\n            Class (class): The class to select; any python class (not instance) subclassed off :class:`AbstractElement`\n            Set (str): The set to match against, only elements pertaining to this set will be returned. If set to None (default), all elements regardless of set will be returned.\n            recursive (bool): Select recursively? Descending into child elements? Defaults to ``True``.\n            ignore: A list of Classes to ignore, if set to ``True`` instead of a list, all non-authoritative elements will be skipped (this is the default behaviour and corresponds to the following elements: :class:`Alternative`, :class:`AlternativeLayer`, :class:`Suggestion`, and :class:`folia.Original`. These elements and those contained within are never *authorative*. You may also include the boolean True as a member of a list, if you want to skip additional tags along the predefined non-authoritative ones.\n            * ``node``: Reserved for internal usage, used in recursion.\n\n        Yields:\n            Elements (instances derived from :class:`AbstractElement`)\n\n        Example::\n\n            for sense in text.select(folia.Sense, 'cornetto', True, [folia.Original, folia.Suggestion, folia.Alternative] ):\n                ..\n\n        \"\"\"\n\n        #if ignorelist is True:\n        #    ignorelist = default_ignore\n\n        if not node:\n            node = self\n        for e in self.data: #pylint: disable=too-many-nested-blocks\n            if (not self.TEXTCONTAINER and not self.PHONCONTAINER) or isinstance(e, AbstractElement):\n                if ignore is True:\n                    try:\n                        if not e.auth:\n                            continue\n                    except AttributeError:\n                        #not all elements have auth attribute..\n                        pass\n                elif ignore: #list\n                    doignore = False\n                    for c in ignore:\n                        if c is True:\n                            try:\n                                if not e.auth:\n                                    doignore =True\n                                    break\n                            except AttributeError:\n                                #not all elements have auth attribute..\n                                pass\n                        elif c == e.__class__ or issubclass(e.__class__,c):\n                            doignore = True\n                            break\n                    if doignore:\n                        continue\n\n                if isinstance(e, Class):\n                    if not set is None:\n                        try:\n                            if e.set != set:\n                                continue\n                        except AttributeError:\n                            continue\n                    yield e\n                if recursive:\n                    for e2 in e.select(Class, set, recursive, ignore, e):\n                        if not set is None:\n                            try:\n                                if e2.set != set:\n                                    continue\n                            except AttributeError:\n                                continue\n                        yield e2",
    "docstring": "Select child elements of the specified class.\n\n        A further restriction can be made based on set.\n\n        Arguments:\n            Class (class): The class to select; any python class (not instance) subclassed off :class:`AbstractElement`\n            Set (str): The set to match against, only elements pertaining to this set will be returned. If set to None (default), all elements regardless of set will be returned.\n            recursive (bool): Select recursively? Descending into child elements? Defaults to ``True``.\n            ignore: A list of Classes to ignore, if set to ``True`` instead of a list, all non-authoritative elements will be skipped (this is the default behaviour and corresponds to the following elements: :class:`Alternative`, :class:`AlternativeLayer`, :class:`Suggestion`, and :class:`folia.Original`. These elements and those contained within are never *authorative*. You may also include the boolean True as a member of a list, if you want to skip additional tags along the predefined non-authoritative ones.\n            * ``node``: Reserved for internal usage, used in recursion.\n\n        Yields:\n            Elements (instances derived from :class:`AbstractElement`)\n\n        Example::\n\n            for sense in text.select(folia.Sense, 'cornetto', True, [folia.Original, folia.Suggestion, folia.Alternative] ):\n                ..",
    "summary": "Cette fonction, `select`, est une m\u00e9thode utilis\u00e9e pour s\u00e9lectionner des \u00e9l\u00e9ments enfants d'une classe sp\u00e9cifique dans une structure de donn\u00e9es hi\u00e9rarchique (probablement un arbre ou une structure XML/HTML). Voici une explication simplifi\u00e9e en fran\u00e7ais :\n\n1. **Objectif** : La fonction permet de parcourir et de s\u00e9lectionner des \u00e9l\u00e9ments qui correspondent \u00e0 une certaine classe (`Class`), \u00e9ventuellement filtr\u00e9s par un ensemble (`set`), et en ignorant certains types d'\u00e9l\u00e9ments si n\u00e9cessaire.\n\n2. **Arguments** :\n   - **Class** : La classe des \u00e9l\u00e9ments \u00e0 s\u00e9lectionner. Ces \u00e9l\u00e9ments doivent \u00eatre des sous-classes de `AbstractElement`.\n   - **set** (optionnel) : Un ensemble sp\u00e9cifique \u00e0 laquelle les \u00e9l\u00e9ments doivent appartenir. Si `None`, tous les \u00e9l\u00e9ments sont consid\u00e9r\u00e9s.\n   - **recursive** : Si `True` (par d\u00e9faut), la recherche se fait de mani\u00e8re r\u00e9cursive dans les \u00e9l\u00e9ments enfants.\n   - **ignore** : Une liste de classes \u00e0 ignorer pendant la s\u00e9lection. Si `True`, les \u00e9l\u00e9ments non autoritatifs (comme `Alternative`, `AlternativeLayer`, `Suggestion`, et `Original`) sont ignor\u00e9s.\n   - **node** : Utilis\u00e9 en interne pour la r\u00e9cursion, g\u00e9n\u00e9ralement pas besoin de le sp\u00e9cifier.\n\n3. **Fonctionnement** :\n   - La fonction parcourt les \u00e9l\u00e9ments enfants du n\u0153ud actuel (`self`).\n   - Elle v\u00e9rifie si chaque \u00e9l\u00e9ment correspond \u00e0 la classe sp\u00e9cifi\u00e9e (`Class`).\n   - Si un ensemble (`set`) est fourni, elle v\u00e9rifie \u00e9galement si l'\u00e9l\u00e9ment appartient \u00e0 cet ensemble.\n   - Si l'option `ignore` est activ\u00e9e, elle ignore les \u00e9l\u00e9ments non autoritatifs ou ceux correspondant aux classes sp\u00e9cifi\u00e9es dans la liste `ignore`.\n   - Si `recursive` est `True`, elle r\u00e9p\u00e8te le processus pour les \u00e9l\u00e9ments enfants.\n\n4. **R\u00e9sultat** :\n   - La fonction retourne un g\u00e9n\u00e9rateur qui produit les \u00e9l\u00e9ments correspondants un par un.\n\n5. **Exemple** :\n   - L'exemple montre comment utiliser cette fonction pour s\u00e9lectionner des \u00e9l\u00e9ments de la classe `folia.Sense` appartenant \u00e0 l'ensemble `'cornetto'`, en ignorant certains types d'\u00e9l\u00e9ments.\n\nEn r\u00e9sum\u00e9, cette fonction est un outil puissant pour filtrer et parcourir des \u00e9l\u00e9ments dans une structure hi\u00e9rarchique en fonction de crit\u00e8res sp\u00e9cifiques."
  },
  {
    "code": "def count(self, Class, set=None, recursive=True,  ignore=True, node=None):\n        \"\"\"Like :meth:`AbstractElement.select`, but instead of returning the elements, it merely counts them.\n\n        Returns:\n            int\n        \"\"\"\n        return sum(1 for i in self.select(Class,set,recursive,ignore,node) )",
    "docstring": "Like :meth:`AbstractElement.select`, but instead of returning the elements, it merely counts them.\n\n        Returns:\n            int",
    "summary": "Cette fonction, nomm\u00e9e `count`, est une m\u00e9thode qui permet de compter le nombre d'\u00e9l\u00e9ments correspondant \u00e0 certains crit\u00e8res dans une structure de donn\u00e9es (probablement une sorte d'arbre ou de document). Voici une explication simple en fran\u00e7ais :\n\n1. **Objectif** : Au lieu de retourner les \u00e9l\u00e9ments eux-m\u00eames (comme le ferait la m\u00e9thode `select`), cette fonction se contente de les compter.\n\n2. **Param\u00e8tres** :\n   - `Class` : Le type ou la classe d'\u00e9l\u00e9ments \u00e0 rechercher.\n   - `set` : Un ensemble optionnel pour filtrer les \u00e9l\u00e9ments (par d\u00e9faut, `None`).\n   - `recursive` : Si `True` (par d\u00e9faut), la recherche est effectu\u00e9e de mani\u00e8re r\u00e9cursive dans la structure.\n   - `ignore` : Si `True` (par d\u00e9faut), certains \u00e9l\u00e9ments peuvent \u00eatre ignor\u00e9s pendant la recherche.\n   - `node` : Un n\u0153ud sp\u00e9cifique \u00e0 partir duquel commencer la recherche (par d\u00e9faut, `None`).\n\n3. **Fonctionnement** :\n   - La fonction utilise la m\u00e9thode `select` pour trouver tous les \u00e9l\u00e9ments correspondant aux crit\u00e8res.\n   - Elle compte ensuite le nombre d'\u00e9l\u00e9ments trouv\u00e9s en utilisant une expression g\u00e9n\u00e9ratrice (`sum(1 for i in ...)`) qui incr\u00e9mente un compteur pour chaque \u00e9l\u00e9ment trouv\u00e9.\n\n4. **Retour** : La fonction retourne un entier (`int`) repr\u00e9sentant le nombre total d'\u00e9l\u00e9ments correspondants.\n\nEn r\u00e9sum\u00e9, cette fonction compte rapidement le nombre d'\u00e9l\u00e9ments d'un certain type ou r\u00e9pondant \u00e0 des crit\u00e8res sp\u00e9cifiques dans une structure de donn\u00e9es, sans avoir \u00e0 manipuler les \u00e9l\u00e9ments eux-m\u00eames."
  },
  {
    "code": "def items(self, founditems=[]): #pylint: disable=dangerous-default-value\n        \"\"\"Returns a depth-first flat list of *all* items below this element (not limited to AbstractElement)\"\"\"\n        l = []\n        for e in self.data:\n            if  e not in founditems: #prevent going in recursive loops\n                l.append(e)\n                if isinstance(e, AbstractElement):\n                    l += e.items(l)\n        return l",
    "docstring": "Returns a depth-first flat list of *all* items below this element (not limited to AbstractElement)",
    "summary": "Cette fonction, nomm\u00e9e `items`, est une m\u00e9thode d'une classe (probablement une classe repr\u00e9sentant un \u00e9l\u00e9ment d'une structure de donn\u00e9es hi\u00e9rarchique). Voici ce qu'elle fait en termes simples :\n\n1. **Objectif** : Elle g\u00e9n\u00e8re une liste \"plate\" (c'est-\u00e0-dire sans imbrication) de **tous** les \u00e9l\u00e9ments situ\u00e9s en dessous de l'\u00e9l\u00e9ment actuel, en explorant la structure de mani\u00e8re **profonde d'abord** (depth-first).\n\n2. **Fonctionnement** :\n   - Elle commence par initialiser une liste vide `l` pour stocker les \u00e9l\u00e9ments trouv\u00e9s.\n   - Elle parcourt chaque \u00e9l\u00e9ment `e` contenu dans `self.data` (les donn\u00e9es de l'\u00e9l\u00e9ment actuel).\n   - Si l'\u00e9l\u00e9ment `e` n'a pas d\u00e9j\u00e0 \u00e9t\u00e9 trouv\u00e9 (pour \u00e9viter les boucles infinies), elle l'ajoute \u00e0 la liste `l`.\n   - Si `e` est une instance de `AbstractElement` (c'est-\u00e0-dire un \u00e9l\u00e9ment qui peut contenir d'autres \u00e9l\u00e9ments), elle appelle r\u00e9cursivement la m\u00e9thode `items` sur `e` pour explorer ses sous-\u00e9l\u00e9ments et ajoute le r\u00e9sultat \u00e0 `l`.\n\n3. **Retour** : La fonction retourne la liste `l` contenant tous les \u00e9l\u00e9ments trouv\u00e9s, sans doublons et en suivant un ordre de parcours en profondeur.\n\nEn r\u00e9sum\u00e9, cette fonction explore r\u00e9cursivement toute la structure en dessous de l'\u00e9l\u00e9ment actuel et retourne une liste plate de tous les \u00e9l\u00e9ments rencontr\u00e9s, en \u00e9vitant les boucles infinies."
  },
  {
    "code": "def getmetadata(self, key=None):\n        \"\"\"Get the metadata that applies to this element, automatically inherited from parent elements\"\"\"\n        if self.metadata:\n            d =  self.doc.submetadata[self.metadata]\n        elif self.parent:\n            d =  self.parent.getmetadata()\n        elif self.doc:\n            d =  self.doc.metadata\n        else:\n            return None\n        if key:\n            return d[key]\n        else:\n            return d",
    "docstring": "Get the metadata that applies to this element, automatically inherited from parent elements",
    "summary": "Cette fonction, `getmetadata`, permet de r\u00e9cup\u00e9rer les m\u00e9tadonn\u00e9es associ\u00e9es \u00e0 un \u00e9l\u00e9ment donn\u00e9, en tenant compte de l'h\u00e9ritage des m\u00e9tadonn\u00e9es depuis les \u00e9l\u00e9ments parents. Voici une explication \u00e9tape par \u00e9tape :\n\n1. **Objectif** : La fonction r\u00e9cup\u00e8re les m\u00e9tadonn\u00e9es applicables \u00e0 l'\u00e9l\u00e9ment actuel. Si des m\u00e9tadonn\u00e9es sp\u00e9cifiques ne sont pas d\u00e9finies pour cet \u00e9l\u00e9ment, elle les cherche dans les \u00e9l\u00e9ments parents.\n\n2. **Fonctionnement** :\n   - Si l'\u00e9l\u00e9ment a ses propres m\u00e9tadonn\u00e9es (`self.metadata`), elle les r\u00e9cup\u00e8re depuis `self.doc.submetadata`.\n   - Si l'\u00e9l\u00e9ment n'a pas de m\u00e9tadonn\u00e9es propres mais a un parent (`self.parent`), elle appelle r\u00e9cursivement `getmetadata` sur le parent.\n   - Si l'\u00e9l\u00e9ment n'a ni m\u00e9tadonn\u00e9es ni parent, mais qu'un document (`self.doc`) est associ\u00e9, elle r\u00e9cup\u00e8re les m\u00e9tadonn\u00e9es directement depuis `self.doc.metadata`.\n   - Si aucune m\u00e9tadonn\u00e9e n'est trouv\u00e9e, la fonction retourne `None`.\n\n3. **Param\u00e8tre `key`** :\n   - Si un `key` est fourni, la fonction retourne uniquement la valeur associ\u00e9e \u00e0 cette cl\u00e9 dans les m\u00e9tadonn\u00e9es.\n   - Si aucun `key` n'est fourni, elle retourne l'ensemble des m\u00e9tadonn\u00e9es sous forme de dictionnaire.\n\nEn r\u00e9sum\u00e9, cette fonction permet de r\u00e9cup\u00e9rer les m\u00e9tadonn\u00e9es d'un \u00e9l\u00e9ment, en explorant la hi\u00e9rarchie des \u00e9l\u00e9ments parents si n\u00e9cessaire, et offre la possibilit\u00e9 de filtrer par une cl\u00e9 sp\u00e9cifique."
  },
  {
    "code": "def getindex(self, child, recursive=True, ignore=True):\n        \"\"\"Get the index at which an element occurs, recursive by default!\n\n        Returns:\n            int\n        \"\"\"\n\n        #breadth first search\n        for i, c in enumerate(self.data):\n            if c is child:\n                return i\n        if recursive:  #pylint: disable=too-many-nested-blocks\n            for i, c in enumerate(self.data):\n                if ignore is True:\n                    try:\n                        if not c.auth:\n                            continue\n                    except AttributeError:\n                        #not all elements have auth attribute..\n                        pass\n                elif ignore: #list\n                    doignore = False\n                    for e in ignore:\n                        if e is True:\n                            try:\n                                if not c.auth:\n                                    doignore =True\n                                    break\n                            except AttributeError:\n                                #not all elements have auth attribute..\n                                pass\n                        elif e == c.__class__ or issubclass(c.__class__,e):\n                            doignore = True\n                            break\n                    if doignore:\n                        continue\n                if isinstance(c, AbstractElement):\n                    j = c.getindex(child, recursive)\n                    if j != -1:\n                        return i #yes, i ... not j!\n        return -1",
    "docstring": "Get the index at which an element occurs, recursive by default!\n\n        Returns:\n            int",
    "summary": "Cette fonction, `getindex`, permet de trouver l'index (la position) d'un \u00e9l\u00e9ment sp\u00e9cifique (`child`) dans une structure de donn\u00e9es. Voici une explication simple en fran\u00e7ais :\n\n1. **Recherche directe** : La fonction commence par parcourir la liste des \u00e9l\u00e9ments (`self.data`) de mani\u00e8re simple (recherche en largeur). Si elle trouve l'\u00e9l\u00e9ment `child`, elle retourne imm\u00e9diatement son index.\n\n2. **Recherche r\u00e9cursive** : Si l'\u00e9l\u00e9ment n'est pas trouv\u00e9 et que le param\u00e8tre `recursive` est activ\u00e9 (`True`), la fonction explore plus en profondeur. Elle v\u00e9rifie chaque \u00e9l\u00e9ment pour voir s'il contient lui-m\u00eame une structure de donn\u00e9es (via `isinstance(c, AbstractElement)`). Si c'est le cas, elle appelle r\u00e9cursivement `getindex` sur cet \u00e9l\u00e9ment.\n\n3. **Ignorer certains \u00e9l\u00e9ments** : Le param\u00e8tre `ignore` permet de sauter certains \u00e9l\u00e9ments pendant la recherche. Cela peut \u00eatre un bool\u00e9en (`ignore=True`) pour ignorer les \u00e9l\u00e9ments sans attribut `auth`, ou une liste de classes pour ignorer les \u00e9l\u00e9ments de types sp\u00e9cifiques.\n\n4. **Retour de l'index** : Si l'\u00e9l\u00e9ment est trouv\u00e9 lors de la recherche r\u00e9cursive, la fonction retourne l'index de l'\u00e9l\u00e9ment parent (et non l'index trouv\u00e9 r\u00e9cursivement). Si l'\u00e9l\u00e9ment n'est pas trouv\u00e9 du tout, elle retourne `-1`.\n\nEn r\u00e9sum\u00e9, cette fonction cherche un \u00e9l\u00e9ment dans une structure de donn\u00e9es, en explorant r\u00e9cursivement si n\u00e9cessaire, et permet d'ignorer certains \u00e9l\u00e9ments selon des crit\u00e8res sp\u00e9cifiques."
  },
  {
    "code": "def precedes(self, other):\n        \"\"\"Returns a boolean indicating whether this element precedes the other element\"\"\"\n        try:\n            ancestor = next(commonancestors(AbstractElement, self, other))\n        except StopIteration:\n            raise Exception(\"Elements share no common ancestor\")\n        #now we just do a depth first search and see who comes first\n        def callback(e):\n            if e is self:\n                return True\n            elif e is other:\n                return False\n            return None\n        result = ancestor.depthfirstsearch(callback)\n        if result is None:\n            raise Exception(\"Unable to find relation between elements! (shouldn't happen)\")\n        return result",
    "docstring": "Returns a boolean indicating whether this element precedes the other element",
    "summary": "Cette fonction, `precedes`, v\u00e9rifie si un \u00e9l\u00e9ment (repr\u00e9sent\u00e9 par `self`) appara\u00eet avant un autre \u00e9l\u00e9ment (repr\u00e9sent\u00e9 par `other`) dans une structure hi\u00e9rarchique (comme un arbre d'\u00e9l\u00e9ments). Voici une explication \u00e9tape par \u00e9tape en fran\u00e7ais :\n\n1. **Objectif** : La fonction retourne `True` si `self` pr\u00e9c\u00e8de `other`, et `False` sinon.\n\n2. **Recherche d'un anc\u00eatre commun** : Elle commence par chercher un anc\u00eatre commun aux deux \u00e9l\u00e9ments (`self` et `other`). Si aucun anc\u00eatre commun n'est trouv\u00e9, une exception est lev\u00e9e.\n\n3. **Parcours en profondeur** : Une fois l'anc\u00eatre commun trouv\u00e9, la fonction effectue un parcours en profondeur (depth-first search) \u00e0 partir de cet anc\u00eatre. Pendant ce parcours :\n   - Si elle rencontre `self` en premier, elle retourne `True` (car `self` pr\u00e9c\u00e8de `other`).\n   - Si elle rencontre `other` en premier, elle retourne `False` (car `other` pr\u00e9c\u00e8de `self`).\n\n4. **Gestion des erreurs** : Si le parcours ne permet pas de d\u00e9terminer la relation entre les deux \u00e9l\u00e9ments (ce qui ne devrait pas arriver), une exception est lev\u00e9e.\n\nEn r\u00e9sum\u00e9, cette fonction d\u00e9termine l'ordre d'apparition de deux \u00e9l\u00e9ments dans une structure hi\u00e9rarchique en utilisant un anc\u00eatre commun et un parcours en profondeur."
  },
  {
    "code": "def depthfirstsearch(self, function):\n        \"\"\"Generic depth first search algorithm using a callback function, continues as long as the callback function returns None\"\"\"\n        result = function(self)\n        if result is not None:\n            return result\n        for e in self:\n            result = e.depthfirstsearch(function)\n            if result is not None:\n                return result\n        return None",
    "docstring": "Generic depth first search algorithm using a callback function, continues as long as the callback function returns None",
    "summary": "Cette fonction, `depthfirstsearch`, est un algorithme de **recherche en profondeur** (Depth-First Search, DFS) g\u00e9n\u00e9rique. Voici une explication simple en fran\u00e7ais :\n\n1. **Objectif** : Elle explore une structure de donn\u00e9es (comme un arbre ou un graphe) en profondeur, en utilisant une fonction de rappel (`callback function`).\n\n2. **Fonctionnement** :\n   - Elle commence par appliquer la fonction de rappel (`function`) sur l'\u00e9l\u00e9ment actuel (`self`).\n   - Si la fonction de rappel retourne une valeur diff\u00e9rente de `None`, la recherche s'arr\u00eate et cette valeur est retourn\u00e9e.\n   - Sinon, elle explore r\u00e9cursivement chaque \u00e9l\u00e9ment enfant (`e`) en appelant `depthfirstsearch` sur lui.\n   - Si un enfant retourne une valeur diff\u00e9rente de `None`, cette valeur est propag\u00e9e et la recherche s'arr\u00eate.\n   - Si aucun \u00e9l\u00e9ment ne retourne une valeur, la fonction retourne `None`.\n\n3. **En r\u00e9sum\u00e9** : Elle parcourt la structure en profondeur, en s'arr\u00eatant d\u00e8s qu'une condition (d\u00e9finie par la fonction de rappel) est satisfaite. C'est utile pour trouver un \u00e9l\u00e9ment sp\u00e9cifique ou v\u00e9rifier une propri\u00e9t\u00e9 dans une structure arborescente ou graph\u00e9e."
  },
  {
    "code": "def next(self, Class=True, scope=True, reverse=False):\n        \"\"\"Returns the next element, if it is of the specified type and if it does not cross the boundary of the defined scope. Returns None if no next element is found. Non-authoritative elements are never returned.\n\n        Arguments:\n            * ``Class``: The class to select; any python class subclassed off `'AbstractElement``, may also be a tuple of multiple classes. Set to ``True`` to constrain to the same class as that of the current instance, set to ``None`` to not constrain at all\n            * ``scope``: A list of classes which are never crossed looking for a next element. Set to ``True`` to constrain to a default list of structure elements (Sentence,Paragraph,Division,Event, ListItem,Caption), set to ``None`` to not constrain at all.\n\n        \"\"\"\n        if Class is True: Class = self.__class__\n        if scope is True: scope = STRUCTURESCOPE\n\n        structural = Class is not None and issubclass(Class,AbstractStructureElement)\n\n        if reverse:\n            order = reversed\n            descendindex = -1\n        else:\n            order = lambda x: x #pylint: disable=redefined-variable-type\n            descendindex = 0\n\n        child = self\n        parent = self.parent\n        while parent: #pylint: disable=too-many-nested-blocks\n            if len(parent) > 1:\n                returnnext = False\n                for e in order(parent):\n                    if e is child:\n                        #we found the current item, next item will be the one to return\n                        returnnext = True\n                    elif returnnext and e.auth and not isinstance(e,AbstractAnnotationLayer) and (not structural or (structural and (not isinstance(e,(AbstractTokenAnnotation,TextContent)) ) )):\n                        if structural and isinstance(e,Correction):\n                            if not list(e.select(AbstractStructureElement)): #skip-over non-structural correction\n                                continue\n\n                        if Class is None or (isinstance(Class,tuple) and (any(isinstance(e,C) for C in Class))) or isinstance(e,Class):\n                            return e\n                        else:\n                            #this is not yet the element of the type we are looking for, we are going to descend again in the very leftmost (rightmost if reversed) branch only\n                            while e.data:\n                                e = e.data[descendindex]\n                                if not isinstance(e, AbstractElement):\n                                    return None #we've gone too far\n                                if e.auth and not isinstance(e,AbstractAnnotationLayer):\n                                    if Class is None or (isinstance(Class,tuple) and (any(isinstance(e,C) for C in Class))) or isinstance(e,Class):\n                                        return e\n                                    else:\n                                        #descend deeper\n                                        continue\n                        return None\n\n            #generational iteration\n            child = parent\n            if scope is not None and child.__class__ in scope:\n                #you shall not pass!\n                break\n            parent = parent.parent\n\n        return None",
    "docstring": "Returns the next element, if it is of the specified type and if it does not cross the boundary of the defined scope. Returns None if no next element is found. Non-authoritative elements are never returned.\n\n        Arguments:\n            * ``Class``: The class to select; any python class subclassed off `'AbstractElement``, may also be a tuple of multiple classes. Set to ``True`` to constrain to the same class as that of the current instance, set to ``None`` to not constrain at all\n            * ``scope``: A list of classes which are never crossed looking for a next element. Set to ``True`` to constrain to a default list of structure elements (Sentence,Paragraph,Division,Event, ListItem,Caption), set to ``None`` to not constrain at all.",
    "summary": "Cette fonction, nomm\u00e9e `next`, est utilis\u00e9e pour trouver l'\u00e9l\u00e9ment suivant dans une structure hi\u00e9rarchique (comme un arbre de donn\u00e9es), en respectant certaines conditions. Voici une explication simplifi\u00e9e en fran\u00e7ais :\n\n1. **Objectif** : La fonction cherche l'\u00e9l\u00e9ment suivant qui correspond \u00e0 un certain type (classe) et qui ne d\u00e9passe pas une limite d\u00e9finie (scope). Si aucun \u00e9l\u00e9ment correspondant n'est trouv\u00e9, elle retourne `None`.\n\n2. **Arguments** :\n   - **`Class`** : D\u00e9termine le type d'\u00e9l\u00e9ment \u00e0 chercher. Si `True`, elle cherche un \u00e9l\u00e9ment de la m\u00eame classe que l'\u00e9l\u00e9ment actuel. Si `None`, elle ne filtre pas par classe.\n   - **`scope`** : D\u00e9finit une liste de classes qui ne doivent pas \u00eatre travers\u00e9es lors de la recherche. Si `True`, elle utilise une liste par d\u00e9faut de classes structurelles. Si `None`, elle ne limite pas la recherche par scope.\n   - **`reverse`** : Si `True`, la recherche se fait dans l'ordre inverse (de droite \u00e0 gauche au lieu de gauche \u00e0 droite).\n\n3. **Fonctionnement** :\n   - Elle commence par ajuster les param\u00e8tres `Class` et `scope` si ils sont `True`.\n   - Elle v\u00e9rifie si la recherche est structurelle (c'est-\u00e0-dire si elle doit respecter une hi\u00e9rarchie sp\u00e9cifique).\n   - Elle parcourt la structure hi\u00e9rarchique en commen\u00e7ant par l'\u00e9l\u00e9ment actuel et en remontant vers les parents.\n   - Pour chaque \u00e9l\u00e9ment rencontr\u00e9, elle v\u00e9rifie s'il correspond aux crit\u00e8res (classe, scope, autorisation, etc.).\n   - Si un \u00e9l\u00e9ment correspondant est trouv\u00e9, il est retourn\u00e9. Sinon, la recherche continue jusqu'\u00e0 ce qu'il n'y ait plus de parents \u00e0 explorer.\n\n4. **R\u00e9sultat** : Si un \u00e9l\u00e9ment correspondant est trouv\u00e9, il est retourn\u00e9. Sinon, la fonction retourne `None`.\n\nEn r\u00e9sum\u00e9, cette fonction permet de naviguer dans une structure hi\u00e9rarchique pour trouver l'\u00e9l\u00e9ment suivant qui r\u00e9pond \u00e0 des crit\u00e8res sp\u00e9cifiques, tout en respectant des limites d\u00e9finies."
  },
  {
    "code": "def previous(self, Class=True, scope=True):\n        \"\"\"Returns the previous element, if it is of the specified type and if it does not cross the boundary of the defined scope. Returns None if no next element is found. Non-authoritative elements are never returned.\n\n        Arguments:\n            * ``Class``: The class to select; any python class subclassed off `'AbstractElement``. Set to ``True`` to constrain to the same class as that of the current instance, set to ``None`` to not constrain at all\n            * ``scope``: A list of classes which are never crossed looking for a next element. Set to ``True`` to constrain to a default list of structure elements (Sentence,Paragraph,Division,Event, ListItem,Caption), set to ``None`` to not constrain at all.\n\n        \"\"\"\n        return self.next(Class,scope, True)",
    "docstring": "Returns the previous element, if it is of the specified type and if it does not cross the boundary of the defined scope. Returns None if no next element is found. Non-authoritative elements are never returned.\n\n        Arguments:\n            * ``Class``: The class to select; any python class subclassed off `'AbstractElement``. Set to ``True`` to constrain to the same class as that of the current instance, set to ``None`` to not constrain at all\n            * ``scope``: A list of classes which are never crossed looking for a next element. Set to ``True`` to constrain to a default list of structure elements (Sentence,Paragraph,Division,Event, ListItem,Caption), set to ``None`` to not constrain at all.",
    "summary": "Cette fonction, nomm\u00e9e `previous`, permet de r\u00e9cup\u00e9rer l'\u00e9l\u00e9ment pr\u00e9c\u00e9dent dans une s\u00e9quence, en respectant certaines conditions. Voici ce qu'elle fait en termes simples :\n\n1. **Recherche de l'\u00e9l\u00e9ment pr\u00e9c\u00e9dent** : Elle essaie de trouver l'\u00e9l\u00e9ment qui vient avant l'\u00e9l\u00e9ment actuel dans une s\u00e9quence.\n\n2. **V\u00e9rification du type** : Si un type sp\u00e9cifique (`Class`) est indiqu\u00e9, elle s'assure que l'\u00e9l\u00e9ment pr\u00e9c\u00e9dent est de ce type. Si `Class` est d\u00e9fini sur `True`, elle cherche un \u00e9l\u00e9ment du m\u00eame type que l'\u00e9l\u00e9ment actuel. Si `Class` est `None`, elle ne v\u00e9rifie pas le type.\n\n3. **Respect du scope (port\u00e9e)** : Elle v\u00e9rifie que la recherche ne d\u00e9passe pas certaines limites d\u00e9finies par `scope`. Si `scope` est `True`, elle utilise une liste par d\u00e9faut de types d'\u00e9l\u00e9ments (comme des phrases, paragraphes, etc.) qu'elle ne doit pas franchir. Si `scope` est `None`, elle ne limite pas la recherche.\n\n4. **\u00c9l\u00e9ments non-autoritaires ignor\u00e9s** : Elle ne retourne jamais des \u00e9l\u00e9ments consid\u00e9r\u00e9s comme \"non-autoritaires\".\n\n5. **R\u00e9sultat** : Si elle trouve un \u00e9l\u00e9ment qui respecte toutes ces conditions, elle le retourne. Sinon, elle retourne `None`.\n\nEn r\u00e9sum\u00e9, cette fonction cherche l'\u00e9l\u00e9ment pr\u00e9c\u00e9dent qui correspond \u00e0 certains crit\u00e8res de type et de port\u00e9e, et ignore les \u00e9l\u00e9ments non pertinents."
  },
  {
    "code": "def leftcontext(self, size, placeholder=None, scope=None):\n        \"\"\"Returns the left context for an element, as a list. This method crosses sentence/paragraph boundaries by default, which can be restricted by setting scope\"\"\"\n\n        if size == 0: return [] #for efficiency\n\n        context = []\n        e = self\n        while len(context) < size:\n            e = e.previous(True,scope)\n            if not e: break\n            context.append(e)\n\n        if placeholder:\n            while len(context) < size:\n                context.append(placeholder)\n\n        context.reverse()\n        return context",
    "docstring": "Returns the left context for an element, as a list. This method crosses sentence/paragraph boundaries by default, which can be restricted by setting scope",
    "summary": "Cette fonction, `leftcontext`, permet de r\u00e9cup\u00e9rer le contexte \u00e0 gauche d'un \u00e9l\u00e9ment donn\u00e9 dans une structure de donn\u00e9es (comme un texte ou une s\u00e9quence). Voici une explication \u00e9tape par \u00e9tape en fran\u00e7ais :\n\n1. **Objectif** : La fonction retourne une liste des \u00e9l\u00e9ments situ\u00e9s \u00e0 gauche de l'\u00e9l\u00e9ment actuel (`self`), jusqu'\u00e0 un certain nombre (`size`).\n\n2. **Param\u00e8tres** :\n   - `size` : Le nombre d'\u00e9l\u00e9ments \u00e0 r\u00e9cup\u00e9rer dans le contexte de gauche.\n   - `placeholder` (optionnel) : Une valeur de remplacement \u00e0 utiliser si le contexte n'a pas assez d'\u00e9l\u00e9ments pour atteindre la taille demand\u00e9e.\n   - `scope` (optionnel) : Permet de limiter la recherche \u00e0 une port\u00e9e sp\u00e9cifique (par exemple, une phrase ou un paragraphe).\n\n3. **Fonctionnement** :\n   - Si `size` est 0, la fonction retourne une liste vide pour des raisons d'efficacit\u00e9.\n   - La fonction parcourt les \u00e9l\u00e9ments pr\u00e9c\u00e9dents (`previous`) de l'\u00e9l\u00e9ment actuel jusqu'\u00e0 atteindre la taille demand\u00e9e (`size`).\n   - Si un `scope` est sp\u00e9cifi\u00e9, la recherche ne d\u00e9passe pas cette port\u00e9e.\n   - Si le nombre d'\u00e9l\u00e9ments trouv\u00e9s est inf\u00e9rieur \u00e0 `size` et qu'un `placeholder` est fourni, la fonction ajoute des \u00e9l\u00e9ments de remplacement pour atteindre la taille souhait\u00e9e.\n   - Enfin, la liste des \u00e9l\u00e9ments est invers\u00e9e (pour respecter l'ordre de gauche \u00e0 droite) et retourn\u00e9e.\n\nEn r\u00e9sum\u00e9, cette fonction permet d'obtenir le contexte \u00e0 gauche d'un \u00e9l\u00e9ment, en g\u00e9rant les cas o\u00f9 le contexte est insuffisant ou limit\u00e9 \u00e0 une certaine port\u00e9e."
  },
  {
    "code": "def rightcontext(self, size, placeholder=None, scope=None):\n        \"\"\"Returns the right context for an element, as a list. This method crosses sentence/paragraph boundaries by default, which can be restricted by setting scope\"\"\"\n\n        if size == 0: return [] #for efficiency\n\n        context = []\n        e = self\n        while len(context) < size:\n            e = e.next(True,scope)\n            if not e: break\n            context.append(e)\n\n        if placeholder:\n            while len(context) < size:\n                context.append(placeholder)\n\n        return context",
    "docstring": "Returns the right context for an element, as a list. This method crosses sentence/paragraph boundaries by default, which can be restricted by setting scope",
    "summary": "Cette fonction, `rightcontext`, permet de r\u00e9cup\u00e9rer le contexte \u00e0 droite d'un \u00e9l\u00e9ment donn\u00e9 dans une structure de donn\u00e9es (comme un texte ou une liste d'\u00e9l\u00e9ments). Voici une explication \u00e9tape par \u00e9tape en fran\u00e7ais :\n\n1. **Objectif** : La fonction retourne une liste des \u00e9l\u00e9ments situ\u00e9s \u00e0 droite de l'\u00e9l\u00e9ment actuel (`self`), jusqu'\u00e0 un certain nombre (`size`).\n\n2. **Param\u00e8tres** :\n   - `size` : Le nombre d'\u00e9l\u00e9ments \u00e0 r\u00e9cup\u00e9rer dans le contexte de droite.\n   - `placeholder` (optionnel) : Une valeur de remplacement \u00e0 utiliser si le contexte n'a pas assez d'\u00e9l\u00e9ments pour atteindre la taille demand\u00e9e.\n   - `scope` (optionnel) : Permet de limiter la recherche \u00e0 certaines fronti\u00e8res (comme les phrases ou les paragraphes).\n\n3. **Fonctionnement** :\n   - Si `size` est 0, la fonction retourne une liste vide pour des raisons d'efficacit\u00e9.\n   - La fonction parcourt les \u00e9l\u00e9ments suivants (`e.next()`) jusqu'\u00e0 atteindre le nombre d'\u00e9l\u00e9ments demand\u00e9 (`size`).\n   - Si le nombre d'\u00e9l\u00e9ments disponibles est inf\u00e9rieur \u00e0 `size`, et qu'un `placeholder` est fourni, il est ajout\u00e9 \u00e0 la liste pour compl\u00e9ter.\n\n4. **Retour** : La fonction retourne une liste contenant les \u00e9l\u00e9ments du contexte de droite, \u00e9ventuellement compl\u00e9t\u00e9s par des `placeholder`.\n\nEn r\u00e9sum\u00e9, cette fonction aide \u00e0 extraire et \u00e0 compl\u00e9ter le contexte \u00e0 droite d'un \u00e9l\u00e9ment, en tenant compte des limites d\u00e9finies par `scope` et en utilisant un `placeholder` si n\u00e9cessaire."
  },
  {
    "code": "def context(self, size, placeholder=None, scope=None):\n        \"\"\"Returns this word in context, {size} words to the left, the current word, and {size} words to the right\"\"\"\n        return self.leftcontext(size, placeholder,scope) + [self] + self.rightcontext(size, placeholder,scope)",
    "docstring": "Returns this word in context, {size} words to the left, the current word, and {size} words to the right",
    "summary": "Cette fonction, nomm\u00e9e `context`, permet d'obtenir un mot dans son contexte, c'est-\u00e0-dire qu'elle retourne une liste de mots comprenant :\n\n1. **{size} mots \u00e0 gauche** du mot actuel (gr\u00e2ce \u00e0 la fonction `self.leftcontext`).\n2. **Le mot actuel** lui-m\u00eame (repr\u00e9sent\u00e9 par `[self]`).\n3. **{size} mots \u00e0 droite** du mot actuel (gr\u00e2ce \u00e0 la fonction `self.rightcontext`).\n\nEn r\u00e9sum\u00e9, elle cr\u00e9e une fen\u00eatre de mots centr\u00e9e sur le mot actuel, avec un nombre sp\u00e9cifi\u00e9 de mots de chaque c\u00f4t\u00e9. Les param\u00e8tres `placeholder` et `scope` sont optionnels et peuvent \u00eatre utilis\u00e9s pour personnaliser le comportement de la fonction, mais leur r\u00f4le exact d\u00e9pend de l'impl\u00e9mentation des fonctions `leftcontext` et `rightcontext`."
  },
  {
    "code": "def relaxng(cls, includechildren=True,extraattribs = None, extraelements=None, origclass = None):\n        \"\"\"Returns a RelaxNG definition for this element (as an XML element (lxml.etree) rather than a string)\"\"\"\n\n        E = ElementMaker(namespace=\"http://relaxng.org/ns/structure/1.0\",nsmap={None:'http://relaxng.org/ns/structure/1.0' , 'folia': \"http://ilk.uvt.nl/folia\", 'xml' : \"http://www.w3.org/XML/1998/namespace\",'a':\"http://relaxng.org/ns/annotation/0.9\" })\n\n        if origclass: cls = origclass\n\n        preamble = []\n        try:\n            if cls.__doc__:\n                E2 = ElementMaker(namespace=\"http://relaxng.org/ns/annotation/0.9\", nsmap={'a':'http://relaxng.org/ns/annotation/0.9'} )\n                preamble.append(E2.documentation(cls.__doc__))\n        except AttributeError:\n            pass\n\n        if cls.REQUIRED_ATTRIBS is None: cls.REQUIRED_ATTRIBS = () #bit hacky\n        if cls.OPTIONAL_ATTRIBS is None: cls.OPTIONAL_ATTRIBS = () #bit hacky\n\n\n        attribs = [ ]\n        if cls.REQUIRED_ATTRIBS and Attrib.ID in cls.REQUIRED_ATTRIBS:\n            attribs.append( E.attribute(E.data(type='ID',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'),name='id', ns=\"http://www.w3.org/XML/1998/namespace\") )\n        elif Attrib.ID in cls.OPTIONAL_ATTRIBS:\n            attribs.append( E.optional( E.attribute(E.data(type='ID',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'), name='id', ns=\"http://www.w3.org/XML/1998/namespace\") ) )\n        if Attrib.CLASS in cls.REQUIRED_ATTRIBS:\n            #Set is a tough one, we can't require it as it may be defined in the declaration: we make it optional and need schematron to resolve this later\n            attribs.append( E.attribute(E.data(type='string',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'),name='class') )\n            attribs.append( E.optional( E.attribute( E.data(type='string',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'),name='set' ) ) )\n        elif Attrib.CLASS in cls.OPTIONAL_ATTRIBS:\n            attribs.append( E.optional( E.attribute(E.data(type='string',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'),name='class') ) )\n            attribs.append( E.optional( E.attribute(E.data(type='string',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'), name='set' ) ) )\n        if Attrib.ANNOTATOR in cls.REQUIRED_ATTRIBS or Attrib.ANNOTATOR in cls.OPTIONAL_ATTRIBS:\n            #Similarly tough\n            attribs.append( E.optional( E.attribute(E.data(type='string',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'), name='annotator') ) )\n            attribs.append( E.optional( E.attribute(name='annotatortype') ) )\n        if Attrib.CONFIDENCE in cls.REQUIRED_ATTRIBS:\n            attribs.append(  E.attribute(E.data(type='double',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'), name='confidence') )\n        elif Attrib.CONFIDENCE in cls.OPTIONAL_ATTRIBS:\n            attribs.append(  E.optional( E.attribute(E.data(type='double',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'), name='confidence') ) )\n        if Attrib.N in cls.REQUIRED_ATTRIBS:\n            attribs.append( E.attribute( E.data(type='string',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'),name='n') )\n        elif Attrib.N in cls.OPTIONAL_ATTRIBS:\n            attribs.append( E.optional( E.attribute( E.data(type='string',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'),name='n') ) )\n        if Attrib.DATETIME in cls.REQUIRED_ATTRIBS:\n            attribs.append( E.attribute(E.data(type='dateTime',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'), name='datetime') )\n        elif Attrib.DATETIME in cls.OPTIONAL_ATTRIBS:\n            attribs.append( E.optional( E.attribute( E.data(type='dateTime',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'),  name='datetime') ) )\n        if Attrib.BEGINTIME in cls.REQUIRED_ATTRIBS:\n            attribs.append(E.attribute(name='begintime') )\n        elif Attrib.BEGINTIME in cls.OPTIONAL_ATTRIBS:\n            attribs.append( E.optional( E.attribute(name='begintime') ) )\n        if Attrib.ENDTIME in cls.REQUIRED_ATTRIBS:\n            attribs.append(E.attribute(name='endtime') )\n        elif Attrib.ENDTIME in cls.OPTIONAL_ATTRIBS:\n            attribs.append( E.optional( E.attribute(name='endtime') ) )\n        if Attrib.SRC in cls.REQUIRED_ATTRIBS:\n            attribs.append(E.attribute(E.data(type='anyURI',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'),name='src') )\n        elif Attrib.SRC in cls.OPTIONAL_ATTRIBS:\n            attribs.append( E.optional( E.attribute(E.data(type='anyURI',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'),name='src') ) )\n        if Attrib.SPEAKER in cls.REQUIRED_ATTRIBS:\n            attribs.append(E.attribute(E.data(type='string',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'), name='speaker') )\n        elif Attrib.SPEAKER in cls.OPTIONAL_ATTRIBS:\n            attribs.append( E.optional( E.attribute(E.data(type='string',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'),name='speaker') ) )\n        if Attrib.TEXTCLASS in cls.REQUIRED_ATTRIBS:\n            attribs.append(E.attribute(name='textclass') )\n        elif Attrib.TEXTCLASS in cls.OPTIONAL_ATTRIBS:\n            attribs.append( E.optional( E.attribute(name='textclass') ) )\n        if Attrib.METADATA in cls.REQUIRED_ATTRIBS:\n            attribs.append(E.attribute(name='metadata') )\n        elif Attrib.METADATA in cls.OPTIONAL_ATTRIBS:\n            attribs.append( E.optional( E.attribute(name='metadata') ) )\n        if cls.XLINK:\n            attribs += [ #loose interpretation of specs, not checking whether xlink combinations are valid\n                    E.optional(E.attribute(name='href',ns=\"http://www.w3.org/1999/xlink\"),E.attribute(name='type',ns=\"http://www.w3.org/1999/xlink\") ),\n                    E.optional(E.attribute(name='role',ns=\"http://www.w3.org/1999/xlink\")),\n                    E.optional(E.attribute(name='title',ns=\"http://www.w3.org/1999/xlink\")),\n                    E.optional(E.attribute(name='label',ns=\"http://www.w3.org/1999/xlink\")),\n                    E.optional(E.attribute(name='show',ns=\"http://www.w3.org/1999/xlink\")),\n            ]\n\n        attribs.append( E.optional( E.attribute( name='auth' ) ) )\n\n\n\n        if extraattribs:\n            for e in extraattribs:\n                attribs.append(e) #s\n\n        attribs.append( E.ref(name=\"allow_foreign_attributes\") )\n\n\n        elements = [] #(including attributes)\n        if cls.TEXTCONTAINER or cls.PHONCONTAINER:\n            elements.append( E.text())\n            #We actually want to require non-empty text (E.text() is not sufficient)\n            #but this is not solved yet, see https://github.com/proycon/folia/issues/19\n            #elements.append( E.data(E.param(r\".+\",name=\"pattern\"),type='string'))\n            #elements.append( E.data(E.param(r\"(.|\\n|\\r)*\\S+(.|\\n|\\r)*\",name=\"pattern\"),type='string'))\n        done = {}\n        if includechildren and cls.ACCEPTED_DATA: #pylint: disable=too-many-nested-blocks\n            for c in cls.ACCEPTED_DATA:\n                if c.__name__[:8] == 'Abstract' and inspect.isclass(c):\n                    for c2 in globals().values():\n                        try:\n                            if inspect.isclass(c2) and issubclass(c2, c):\n                                try:\n                                    if c2.XMLTAG and c2.XMLTAG not in done:\n                                        if c2.OCCURRENCES == 1:\n                                            elements.append( E.optional( E.ref(name=c2.XMLTAG) ) )\n                                        else:\n                                            elements.append( E.zeroOrMore( E.ref(name=c2.XMLTAG) ) )\n                                            if c2.XMLTAG == 'item': #nasty hack for backward compatibility with deprecated listitem element\n                                                elements.append( E.zeroOrMore( E.ref(name='listitem') ) )\n                                        done[c2.XMLTAG] = True\n                                except AttributeError:\n                                    continue\n                        except TypeError:\n                            pass\n                elif issubclass(c, Feature) and c.SUBSET:\n                    attribs.append( E.optional( E.attribute(name=c.SUBSET)))  #features as attributes\n                else:\n                    try:\n                        if c.XMLTAG and c.XMLTAG not in done:\n                            if cls.REQUIRED_DATA and c in cls.REQUIRED_DATA:\n                                if c.OCCURRENCES == 1:\n                                    elements.append( E.ref(name=c.XMLTAG) )\n                                else:\n                                    elements.append( E.oneOrMore( E.ref(name=c.XMLTAG) ) )\n                            elif c.OCCURRENCES == 1:\n                                elements.append( E.optional( E.ref(name=c.XMLTAG) ) )\n                            else:\n                                elements.append( E.zeroOrMore( E.ref(name=c.XMLTAG) ) )\n                                if c.XMLTAG == 'item':\n                                    #nasty hack for backward compatibility with deprecated listitem element\n                                    elements.append( E.zeroOrMore( E.ref(name='listitem') )  )\n                            done[c.XMLTAG] = True\n                    except AttributeError:\n                        continue\n\n        if extraelements:\n            for e in extraelements:\n                elements.append( e )\n\n        if elements:\n            if len(elements) > 1:\n                attribs.append( E.interleave(*elements) )\n            else:\n                attribs.append( *elements )\n\n        if not attribs:\n            attribs.append( E.empty() )\n\n        if cls.XMLTAG in ('desc','comment'):\n            return E.define( E.element(E.text(), *(preamble + attribs), **{'name': cls.XMLTAG}), name=cls.XMLTAG, ns=NSFOLIA)\n        else:\n            return E.define( E.element(*(preamble + attribs), **{'name': cls.XMLTAG}), name=cls.XMLTAG, ns=NSFOLIA)",
    "docstring": "Returns a RelaxNG definition for this element (as an XML element (lxml.etree) rather than a string)",
    "summary": "Cette fonction, `relaxng`, g\u00e9n\u00e8re une d\u00e9finition **RelaxNG** (un langage de sch\u00e9ma XML) pour un \u00e9l\u00e9ment donn\u00e9. Voici une explication simplifi\u00e9e en fran\u00e7ais :\n\n1. **Objectif** : La fonction cr\u00e9e une d\u00e9finition RelaxNG sous forme d'un \u00e9l\u00e9ment XML (utilisant la biblioth\u00e8que `lxml.etree`) pour une classe donn\u00e9e (`cls`). Cette d\u00e9finition d\u00e9crit la structure et les r\u00e8gles de l'\u00e9l\u00e9ment XML correspondant.\n\n2. **Param\u00e8tres** :\n   - `cls` : La classe pour laquelle g\u00e9n\u00e9rer la d\u00e9finition RelaxNG.\n   - `includechildren` : Indique si les \u00e9l\u00e9ments enfants doivent \u00eatre inclus dans la d\u00e9finition.\n   - `extraattribs` et `extraelements` : Permettent d'ajouter des attributs ou des \u00e9l\u00e9ments suppl\u00e9mentaires \u00e0 la d\u00e9finition.\n   - `origclass` : Une classe alternative \u00e0 utiliser si n\u00e9cessaire.\n\n3. **Fonctionnement** :\n   - **Pr\u00e9ambule** : Si la classe a une documentation (`__doc__`), elle est ajout\u00e9e comme annotation dans la d\u00e9finition.\n   - **Attributs** : La fonction examine les attributs requis et optionnels de la classe (`REQUIRED_ATTRIBS` et `OPTIONAL_ATTRIBS`) et les ajoute \u00e0 la d\u00e9finition. Par exemple, si l'attribut `id` est requis, il est ajout\u00e9 avec le type de donn\u00e9es appropri\u00e9.\n   - **\u00c9l\u00e9ments** : Si la classe accepte des donn\u00e9es enfants (`ACCEPTED_DATA`), ces \u00e9l\u00e9ments sont ajout\u00e9s \u00e0 la d\u00e9finition. La fonction g\u00e8re \u00e9galement les cas o\u00f9 les \u00e9l\u00e9ments peuvent appara\u00eetre plusieurs fois ou sont optionnels.\n   - **\u00c9l\u00e9ments suppl\u00e9mentaires** : Si des \u00e9l\u00e9ments ou attributs suppl\u00e9mentaires sont fournis via `extraattribs` ou `extraelements`, ils sont int\u00e9gr\u00e9s \u00e0 la d\u00e9finition.\n\n4. **R\u00e9sultat** : La fonction retourne un \u00e9l\u00e9ment XML repr\u00e9sentant la d\u00e9finition RelaxNG pour la classe donn\u00e9e. Cette d\u00e9finition peut \u00eatre utilis\u00e9e pour valider des documents XML conformes \u00e0 la structure d\u00e9crite.\n\nEn r\u00e9sum\u00e9, cette fonction automatise la cr\u00e9ation de sch\u00e9mas RelaxNG pour des classes Python, en tenant compte de leurs attributs, \u00e9l\u00e9ments enfants et r\u00e8gles de structure."
  },
  {
    "code": "def parsexml(Class, node, doc, **kwargs): #pylint: disable=bad-classmethod-argument\n        \"\"\"Internal class method used for turning an XML element into an instance of the Class.\n\n        Args:\n            * ``node`` - XML Element\n            * ``doc`` - Document\n\n        Returns:\n            An instance of the current Class.\n        \"\"\"\n\n        assert issubclass(Class, AbstractElement)\n\n        if doc.preparsexmlcallback:\n            result = doc.preparsexmlcallback(node)\n            if not result:\n                return None\n            if isinstance(result, AbstractElement):\n                return result\n\n\n\n        dcoi = node.tag.startswith('{' + NSDCOI + '}')\n        args = []\n        if not kwargs: kwargs = {}\n        text = None #for dcoi support\n        if (Class.TEXTCONTAINER or Class.PHONCONTAINER) and node.text:\n            args.append(node.text)\n\n\n        for subnode in node: #pylint: disable=too-many-nested-blocks\n            #don't trip over comments\n            if isinstance(subnode, ElementTree._Comment): #pylint: disable=protected-access\n                if (Class.TEXTCONTAINER or Class.PHONCONTAINER) and subnode.tail:\n                    args.append(subnode.tail)\n            else:\n                if subnode.tag.startswith('{' + NSFOLIA + '}'):\n                    if doc.debug >= 1: print(\"[PyNLPl FoLiA DEBUG] Processing subnode \" + subnode.tag[nslen:],file=stderr)\n                    try:\n                        e = doc.parsexml(subnode, Class)\n                    except ParseError as e:\n                        raise #just re-raise deepest parseError\n                    except Exception as e:\n                        #Python 3 will preserve full original traceback, Python 2 does not, original cause is explicitly passed to ParseError anyway:\n                        raise ParseError(\"FoLiA exception in handling of <\" + subnode.tag[len(NSFOLIA)+2:] + \"> @ line \" + str(subnode.sourceline) + \": [\" + e.__class__.__name__ + \"] \" + str(e), cause=e)\n                    if e is not None:\n                        args.append(e)\n                    if (Class.TEXTCONTAINER or Class.PHONCONTAINER) and subnode.tail:\n                        args.append(subnode.tail)\n                elif subnode.tag.startswith('{' + NSDCOI + '}'):\n                    #Dcoi support\n                    if Class is Text and subnode.tag[nslendcoi:] == 'body':\n                        for subsubnode in subnode:\n                            if doc.debug >= 1: print(\"[PyNLPl FoLiA DEBUG] Processing DCOI subnode \" + subnode.tag[nslendcoi:],file=stderr)\n                            e = doc.parsexml(subsubnode, Class)\n                            if e is not None:\n                                args.append(e)\n                    else:\n                        if doc.debug >= 1: print( \"[PyNLPl FoLiA DEBUG] Processing DCOI subnode \" + subnode.tag[nslendcoi:],file=stderr)\n                        e = doc.parsexml(subnode, Class)\n                        if e is not None:\n                            args.append(e)\n                elif doc.debug >= 1:\n                    print(\"[PyNLPl FoLiA DEBUG] Ignoring subnode outside of FoLiA namespace: \" + subnode.tag,file=stderr)\n\n\n\n        if dcoi:\n            dcoipos = dcoilemma = dcoicorrection = dcoicorrectionoriginal = None\n        for key, value in node.attrib.items():\n            if key[0] == '{' or key =='XMLid':\n                if key == '{http://www.w3.org/XML/1998/namespace}id' or key == 'XMLid':\n                    key = 'id'\n                elif key.startswith( '{' + NSFOLIA + '}'):\n                    key = key[nslen:]\n                    if key == 'id':\n                        #ID in FoLiA namespace is always a reference, passed in kwargs as follows:\n                        key = 'idref'\n                elif Class.XLINK and key.startswith('{http://www.w3.org/1999/xlink}'):\n                    key = key[30:]\n                    if key != 'href':\n                        key = 'xlink' + key #xlinktype, xlinkrole, xlinklabel, xlinkshow, etc..\n                elif key.startswith('{' + NSDCOI + '}'):\n                    key = key[nslendcoi:]\n\n            #D-Coi support:\n            if dcoi:\n                if Class is Word and key == 'pos':\n                    dcoipos = value\n                    continue\n                elif Class is Word and  key == 'lemma':\n                    dcoilemma = value\n                    continue\n                elif Class is Word and  key == 'correction':\n                    dcoicorrection = value #class\n                    continue\n                elif Class is Word and  key == 'original':\n                    dcoicorrectionoriginal = value\n                    continue\n                elif Class is Gap and  key == 'reason':\n                    key = 'class'\n                elif Class is Gap and  key == 'hand':\n                    key = 'annotator'\n                elif Class is Division and  key == 'type':\n                    key = 'cls'\n\n            kwargs[key] = value\n\n        #D-Coi support:\n        if dcoi and TextContent in Class.ACCEPTED_DATA and node.text:\n            text = node.text.strip()\n\n            kwargs['text'] = text\n            if not AnnotationType.TOKEN in doc.annotationdefaults:\n                doc.declare(AnnotationType.TOKEN, set='http://ilk.uvt.nl/folia/sets/ilktok.foliaset')\n\n        if doc.debug >= 1: print(\"[PyNLPl FoLiA DEBUG] Found \" + node.tag[nslen:],file=stderr)\n        instance = Class(doc, *args, **kwargs)\n        #if id:\n        #    if doc.debug >= 1: print >>stderr, \"[PyNLPl FoLiA DEBUG] Adding to index: \" + id\n        #    doc.index[id] = instance\n        if dcoi:\n            if dcoipos:\n                if not AnnotationType.POS in doc.annotationdefaults:\n                    doc.declare(AnnotationType.POS, set='http://ilk.uvt.nl/folia/sets/cgn-legacy.foliaset')\n                instance.append( PosAnnotation(doc, cls=dcoipos) )\n            if dcoilemma:\n                if not AnnotationType.LEMMA in doc.annotationdefaults:\n                    doc.declare(AnnotationType.LEMMA, set='http://ilk.uvt.nl/folia/sets/mblem-nl.foliaset')\n                instance.append( LemmaAnnotation(doc, cls=dcoilemma) )\n            if dcoicorrection and dcoicorrectionoriginal and text:\n                if not AnnotationType.CORRECTION in doc.annotationdefaults:\n                    doc.declare(AnnotationType.CORRECTION, set='http://ilk.uvt.nl/folia/sets/dcoi-corrections.foliaset')\n                instance.correct(generate_id_in=instance, cls=dcoicorrection, original=dcoicorrectionoriginal, new=text)\n\n        if doc.parsexmlcallback:\n            result = doc.parsexmlcallback(instance)\n            if not result:\n                return None\n            if isinstance(result, AbstractElement):\n                return result\n\n        return instance",
    "docstring": "Internal class method used for turning an XML element into an instance of the Class.\n\n        Args:\n            * ``node`` - XML Element\n            * ``doc`` - Document\n\n        Returns:\n            An instance of the current Class.",
    "summary": "Cette fonction, `parsexml`, est une m\u00e9thode interne utilis\u00e9e pour transformer un \u00e9l\u00e9ment XML en une instance d'une classe sp\u00e9cifique (`Class`). Voici une explication simplifi\u00e9e en fran\u00e7ais :\n\n1. **Objectif** : La fonction prend un \u00e9l\u00e9ment XML (`node`) et un document (`doc`), puis cr\u00e9e une instance de la classe (`Class`) en utilisant les informations contenues dans l'\u00e9l\u00e9ment XML.\n\n2. **Arguments** :\n   - `Class` : La classe \u00e0 instancier.\n   - `node` : L'\u00e9l\u00e9ment XML \u00e0 traiter.\n   - `doc` : Le document XML contenant l'\u00e9l\u00e9ment.\n   - `**kwargs` : Des arguments suppl\u00e9mentaires optionnels.\n\n3. **Fonctionnement** :\n   - **V\u00e9rification** : Elle v\u00e9rifie d'abord que `Class` est une sous-classe de `AbstractElement`.\n   - **Pr\u00e9-traitement** : Si une fonction de pr\u00e9-traitement (`preparsexmlcallback`) est d\u00e9finie dans le document, elle est ex\u00e9cut\u00e9e. Si elle retourne `None`, la fonction s'arr\u00eate.\n   - **Traitement des attributs** : Les attributs de l'\u00e9l\u00e9ment XML sont trait\u00e9s et ajout\u00e9s aux arguments (`kwargs`) pour la cr\u00e9ation de l'instance.\n   - **Traitement des sous-\u00e9l\u00e9ments** : Les sous-\u00e9l\u00e9ments de l'\u00e9l\u00e9ment XML sont parcourus. Ceux qui appartiennent \u00e0 un espace de noms sp\u00e9cifique (comme FoLiA ou DCOI) sont trait\u00e9s r\u00e9cursivement pour cr\u00e9er des instances de classes appropri\u00e9es.\n   - **Cr\u00e9ation de l'instance** : Une instance de `Class` est cr\u00e9\u00e9e en utilisant les arguments collect\u00e9s (`args` et `kwargs`).\n   - **Post-traitement** : Si une fonction de post-traitement (`parsexmlcallback`) est d\u00e9finie, elle est ex\u00e9cut\u00e9e sur l'instance cr\u00e9\u00e9e.\n\n4. **Retour** : La fonction retourne l'instance de la classe cr\u00e9\u00e9e, ou `None` si une \u00e9tape de traitement a \u00e9chou\u00e9.\n\nEn r\u00e9sum\u00e9, cette fonction est un outil pour convertir des \u00e9l\u00e9ments XML en objets Python structur\u00e9s, en tenant compte des sp\u00e9cificit\u00e9s des espaces de noms XML et en permettant des personnalisations via des callbacks."
  },
  {
    "code": "def remove(self, child):\n        \"\"\"Removes the child element\"\"\"\n        if not isinstance(child, AbstractElement):\n            raise ValueError(\"Expected AbstractElement, got \" + str(type(child)))\n        if child.parent == self:\n            child.parent = None\n        self.data.remove(child)\n        #delete from index\n        if child.id and self.doc and child.id in self.doc.index:\n            del self.doc.index[child.id]",
    "docstring": "Removes the child element",
    "summary": "Cette fonction, nomm\u00e9e `remove`, sert \u00e0 supprimer un \u00e9l\u00e9ment enfant (`child`) d'une structure de donn\u00e9es. Voici ce qu'elle fait \u00e9tape par \u00e9tape en fran\u00e7ais simple :\n\n1. **V\u00e9rification du type de l'\u00e9l\u00e9ment** : Elle v\u00e9rifie d'abord si l'\u00e9l\u00e9ment \u00e0 supprimer (`child`) est bien du type attendu (`AbstractElement`). Si ce n'est pas le cas, elle d\u00e9clenche une erreur (`ValueError`).\n\n2. **Suppression du lien parent-enfant** : Si l'\u00e9l\u00e9ment \u00e0 supprimer est effectivement un enfant de l'\u00e9l\u00e9ment courant (`self`), elle rompt ce lien en mettant le parent de l'enfant \u00e0 `None`.\n\n3. **Suppression de l'\u00e9l\u00e9ment des donn\u00e9es** : Elle retire ensuite l'\u00e9l\u00e9ment enfant de la liste des donn\u00e9es (`self.data`) de l'\u00e9l\u00e9ment courant.\n\n4. **Suppression de l'index** : Si l'\u00e9l\u00e9ment enfant a un identifiant (`id`), et s'il est index\u00e9 dans un document (`self.doc`), elle supprime cet identifiant de l'index du document.\n\nEn r\u00e9sum\u00e9, cette fonction supprime un \u00e9l\u00e9ment enfant d'une structure, en s'assurant que toutes les r\u00e9f\u00e9rences \u00e0 cet \u00e9l\u00e9ment sont correctement nettoy\u00e9es."
  },
  {
    "code": "def incorrection(self):\n        \"\"\"Is this element part of a correction? If it is, it returns the Correction element (evaluating to True), otherwise it returns None\"\"\"\n        e = self.parent\n\n        while e:\n            if isinstance(e, Correction):\n                return e\n            if isinstance(e, AbstractStructureElement):\n                break\n            e = e.parent\n        return None",
    "docstring": "Is this element part of a correction? If it is, it returns the Correction element (evaluating to True), otherwise it returns None",
    "summary": "Cette fonction, nomm\u00e9e `incorrection`, v\u00e9rifie si l'\u00e9l\u00e9ment sur lequel elle est appel\u00e9e fait partie d'une correction. Voici comment elle fonctionne en termes simples :\n\n1. **Recherche des parents** : Elle commence par examiner l'\u00e9l\u00e9ment parent de l'\u00e9l\u00e9ment actuel (`self.parent`).  \n2. **Parcours des anc\u00eatres** : Elle remonte ensuite dans la hi\u00e9rarchie des \u00e9l\u00e9ments parents (comme une arborescence) jusqu'\u00e0 ce qu'elle trouve un \u00e9l\u00e9ment de type `Correction` ou qu'elle atteigne un certain type d'\u00e9l\u00e9ment (`AbstractStructureElement`) qui arr\u00eate la recherche.  \n3. **Retour du r\u00e9sultat** :  \n   - Si elle trouve un \u00e9l\u00e9ment de type `Correction`, elle le retourne (ce qui \u00e9valu\u00e9 \u00e0 `True`).  \n   - Si elle ne trouve rien, elle retourne `None`.  \n\nEn r\u00e9sum\u00e9, cette fonction r\u00e9pond \u00e0 la question : *\"Est-ce que cet \u00e9l\u00e9ment fait partie d'une correction ?\"* Si oui, elle retourne l'\u00e9l\u00e9ment `Correction` correspondant ; sinon, elle retourne `None`."
  },
  {
    "code": "def correct(self, **kwargs):\n        \"\"\"Apply a correction (TODO: documentation to be written still)\"\"\"\n\n        if 'insertindex_offset' in kwargs:\n            del kwargs['insertindex_offset'] #dealt with in an earlier stage\n\n        if 'confidence' in kwargs and kwargs['confidence'] is None:\n            del kwargs['confidence']\n\n        if 'reuse' in kwargs:\n            #reuse an existing correction instead of making a new one\n            if isinstance(kwargs['reuse'], Correction):\n                c = kwargs['reuse']\n            else: #assume it's an index\n                try:\n                    c = self.doc.index[kwargs['reuse']]\n                    assert isinstance(c, Correction)\n                except:\n                    raise ValueError(\"reuse= must point to an existing correction (id or instance)! Got \" + str(kwargs['reuse']))\n\n            suggestionsonly = (not c.hasnew(True) and not c.hasoriginal(True) and c.hassuggestions(True))\n\n            if 'new' in kwargs and c.hascurrent():\n                #can't add new if there's current, so first set original to current, and then delete current\n\n                if 'current' in kwargs:\n                    raise Exception(\"Can't set both new= and current= !\")\n                if 'original' not in kwargs:\n                    kwargs['original'] = c.current()\n\n                c.remove(c.current())\n        else:\n            if 'id' not in kwargs and 'generate_id_in' not in kwargs:\n                kwargs['generate_id_in'] = self\n            kwargs2 = copy(kwargs)\n            for x in ['new','original','suggestion', 'suggestions','current', 'insertindex','nooriginal']:\n                if x in kwargs2:\n                    del kwargs2[x]\n            c = Correction(self.doc, **kwargs2)\n\n        addnew = False\n        if 'insertindex' in kwargs:\n            insertindex = int(kwargs['insertindex'])\n            del kwargs['insertindex']\n        else:\n            insertindex = -1 #append\n\n        if 'nooriginal' in kwargs and kwargs['nooriginal']:\n            nooriginal = True\n            del kwargs['nooriginal']\n        else:\n            nooriginal = False\n\n        if 'current' in kwargs:\n            if 'original' in kwargs or 'new' in kwargs: raise Exception(\"When setting current=, original= and new= can not be set!\")\n            if not isinstance(kwargs['current'], list) and not isinstance(kwargs['current'], tuple): kwargs['current'] = [kwargs['current']] #support both lists (for multiple elements at once), as well as single element\n            c.replace(Current(self.doc, *kwargs['current']))\n            for o in kwargs['current']: #delete current from current element\n                if o in self and isinstance(o, AbstractElement): #pylint: disable=unsupported-membership-test\n                    if insertindex == -1: insertindex = self.data.index(o)\n                    self.remove(o)\n            del kwargs['current']\n        if 'new' in kwargs:\n            if not isinstance(kwargs['new'], list) and not isinstance(kwargs['new'], tuple): kwargs['new'] = [kwargs['new']] #support both lists (for multiple elements at once), as well as single element\n            addnew = New(self.doc, *kwargs['new']) #pylint: disable=redefined-variable-type\n            c.replace(addnew)\n            for current in c.select(Current): #delete current if present\n                c.remove(current)\n            del kwargs['new']\n        if 'original' in kwargs and kwargs['original']:\n            if not isinstance(kwargs['original'], list) and not isinstance(kwargs['original'], tuple): kwargs['original'] = [kwargs['original']] #support both lists (for multiple elements at once), as well as single element\n            c.replace(Original(self.doc, *kwargs['original']))\n            for o in kwargs['original']: #delete original from current element\n                if o in self and isinstance(o, AbstractElement): #pylint: disable=unsupported-membership-test\n                    if insertindex == -1: insertindex = self.data.index(o)\n                    self.remove(o)\n            for o in kwargs['original']: #make sure IDs are still properly set after removal\n                o.addtoindex()\n            for current in c.select(Current):  #delete current if present\n                c.remove(current)\n            del kwargs['original']\n        elif addnew and not nooriginal:\n            #original not specified, find automagically:\n            original = []\n            for new in addnew:\n                kwargs2 = {}\n                if isinstance(new, TextContent):\n                    kwargs2['cls'] = new.cls\n                try:\n                    set = new.set\n                except AttributeError:\n                    set = None\n                #print(\"DEBUG: Finding replaceables within \" + str(repr(self)) + \" for \", str(repr(new)), \" set \" ,set , \" args \" ,repr(kwargs2),file=sys.stderr)\n                replaceables = new.__class__.findreplaceables(self, set, **kwargs2)\n                #print(\"DEBUG: \" , len(replaceables) , \" found\",file=sys.stderr)\n                original += replaceables\n            if not original:\n                #print(\"DEBUG: \", self.xmlstring(),file=sys.stderr)\n                raise Exception(\"No original= specified and unable to automatically infer on \" + str(repr(self)) + \" for \" + str(repr(new)) + \" with set \" + set)\n            else:\n                c.replace( Original(self.doc, *original))\n                for current in c.select(Current):  #delete current if present\n                    c.remove(current)\n\n        if addnew and not nooriginal:\n            for original in c.original():\n                if original in self: #pylint: disable=unsupported-membership-test\n                    self.remove(original)\n\n        if 'suggestion' in kwargs:\n            kwargs['suggestions'] = [kwargs['suggestion']]\n            del kwargs['suggestion']\n        if 'suggestions' in kwargs:\n            for suggestion in kwargs['suggestions']:\n                if isinstance(suggestion, Suggestion):\n                    c.append(suggestion)\n                elif isinstance(suggestion, list) or isinstance(suggestion, tuple):\n                    c.append(Suggestion(self.doc, *suggestion))\n                else:\n                    c.append(Suggestion(self.doc, suggestion))\n            del kwargs['suggestions']\n\n\n\n\n        if 'reuse' in kwargs:\n            if addnew and suggestionsonly:\n                #What was previously only a suggestion, now becomes a real correction\n                #If annotator, annotatortypes\n                #are associated with the correction as a whole, move it to the suggestions\n                #correction-wide annotator, annotatortypes might be overwritten\n                for suggestion in c.suggestions():\n                    if c.annotator and not suggestion.annotator:\n                        suggestion.annotator = c.annotator\n                    if c.annotatortype and not suggestion.annotatortype:\n                        suggestion.annotatortype = c.annotatortype\n\n            if 'annotator' in kwargs:\n                c.annotator = kwargs['annotator'] #pylint: disable=attribute-defined-outside-init\n            if 'annotatortype' in kwargs:\n                c.annotatortype = kwargs['annotatortype'] #pylint: disable=attribute-defined-outside-init\n            if 'confidence' in kwargs:\n                c.confidence = float(kwargs['confidence']) #pylint: disable=attribute-defined-outside-init\n            c.addtoindex()\n            del kwargs['reuse']\n        else:\n            c.addtoindex()\n            if insertindex == -1:\n                self.append(c)\n            else:\n                self.insert(insertindex, c)\n        return c",
    "docstring": "Apply a correction (TODO: documentation to be written still)",
    "summary": "Cette fonction, `correct`, est utilis\u00e9e pour appliquer ou g\u00e9rer des corrections dans un document. Voici une explication simplifi\u00e9e de ce qu'elle fait :\n\n1. **Nettoyage des param\u00e8tres** : Elle commence par nettoyer les param\u00e8tres d'entr\u00e9e (`kwargs`) en supprimant ou en ajustant certaines cl\u00e9s comme `insertindex_offset` ou `confidence` si elles sont pr\u00e9sentes ou non pertinentes.\n\n2. **R\u00e9utilisation d'une correction existante** : Si le param\u00e8tre `reuse` est fourni, la fonction tente de r\u00e9utiliser une correction existante plut\u00f4t que d'en cr\u00e9er une nouvelle. Elle v\u00e9rifie si `reuse` pointe vers une instance de correction valide ou vers un index de correction.\n\n3. **Gestion des \u00e9l\u00e9ments nouveaux, originaux et actuels** : La fonction g\u00e8re les \u00e9l\u00e9ments `new`, `original`, et `current` pour appliquer des modifications au document. Par exemple, si un nouvel \u00e9l\u00e9ment (`new`) est fourni, elle le remplace dans la correction et supprime l'\u00e9l\u00e9ment actuel s'il existe.\n\n4. **Insertion ou ajout de la correction** : Selon la pr\u00e9sence du param\u00e8tre `insertindex`, la correction est soit ins\u00e9r\u00e9e \u00e0 une position sp\u00e9cifique dans le document, soit ajout\u00e9e \u00e0 la fin.\n\n5. **Gestion des suggestions** : Si des suggestions (`suggestion` ou `suggestions`) sont fournies, elles sont ajout\u00e9es \u00e0 la correction.\n\n6. **Mise \u00e0 jour des m\u00e9tadonn\u00e9es** : Si des informations suppl\u00e9mentaires comme `annotator`, `annotatortype`, ou `confidence` sont fournies, elles sont associ\u00e9es \u00e0 la correction.\n\n7. **Retour de la correction** : Enfin, la fonction retourne l'instance de correction cr\u00e9\u00e9e ou mise \u00e0 jour.\n\nEn r\u00e9sum\u00e9, cette fonction permet de g\u00e9rer des corrections dans un document en ajoutant, modifiant ou r\u00e9utilisant des \u00e9l\u00e9ments, tout en g\u00e9rant les m\u00e9tadonn\u00e9es associ\u00e9es."
  },
  {
    "code": "def annotations(self,Class,set=None):\n        \"\"\"Obtain child elements (annotations) of the specified class.\n\n        A further restriction can be made based on set.\n\n        Arguments:\n            Class (class): The class to select; any python class (not instance) subclassed off :class:`AbstractElement`\n            Set (str): The set to match against, only elements pertaining to this set will be returned. If set to None (default), all elements regardless of set will be returned.\n\n        Yields:\n            Elements (instances derived from :class:`AbstractElement`)\n\n        Example::\n\n            for sense in text.annotations(folia.Sense, 'http://some/path/cornetto'):\n                ..\n\n        See also:\n            :meth:`AbstractElement.select`\n\n        Raises:\n            :meth:`AllowTokenAnnotation.annotations`\n            :class:`NoSuchAnnotation` if no such annotation exists\n        \"\"\"\n        found = False\n        for e in self.select(Class,set,True,default_ignore_annotations):\n            found = True\n            yield e\n        if not found:\n            raise NoSuchAnnotation()",
    "docstring": "Obtain child elements (annotations) of the specified class.\n\n        A further restriction can be made based on set.\n\n        Arguments:\n            Class (class): The class to select; any python class (not instance) subclassed off :class:`AbstractElement`\n            Set (str): The set to match against, only elements pertaining to this set will be returned. If set to None (default), all elements regardless of set will be returned.\n\n        Yields:\n            Elements (instances derived from :class:`AbstractElement`)\n\n        Example::\n\n            for sense in text.annotations(folia.Sense, 'http://some/path/cornetto'):\n                ..\n\n        See also:\n            :meth:`AbstractElement.select`\n\n        Raises:\n            :meth:`AllowTokenAnnotation.annotations`\n            :class:`NoSuchAnnotation` if no such annotation exists",
    "summary": "Cette fonction, `annotations`, permet de r\u00e9cup\u00e9rer les \u00e9l\u00e9ments enfants (appel\u00e9s annotations) d'une classe sp\u00e9cifique dans une structure de donn\u00e9es. Voici une explication simplifi\u00e9e en fran\u00e7ais :\n\n1. **Objectif** : La fonction recherche et retourne les annotations qui sont des instances d'une classe particuli\u00e8re (`Class`). Ces annotations sont des \u00e9l\u00e9ments enfants dans une hi\u00e9rarchie de donn\u00e9es.\n\n2. **Param\u00e8tres** :\n   - `Class` : La classe Python (pas une instance, mais la classe elle-m\u00eame) que vous voulez s\u00e9lectionner. Cette classe doit \u00eatre un sous-type de `AbstractElement`.\n   - `set` (optionnel) : Un filtre suppl\u00e9mentaire pour ne retourner que les annotations qui appartiennent \u00e0 un ensemble sp\u00e9cifique (`set`). Si `set` est `None` (par d\u00e9faut), toutes les annotations de la classe sp\u00e9cifi\u00e9e sont retourn\u00e9es, quel que soit leur ensemble.\n\n3. **R\u00e9sultat** : La fonction utilise `yield` pour retourner un g\u00e9n\u00e9rateur, ce qui signifie qu'elle produit les annotations une par une au fur et \u00e0 mesure qu'elles sont trouv\u00e9es. Chaque annotation retourn\u00e9e est une instance de la classe sp\u00e9cifi\u00e9e (`Class`).\n\n4. **Exemple** : L'exemple montre comment parcourir les annotations de type `folia.Sense` qui appartiennent \u00e0 l'ensemble `'http://some/path/cornetto'`.\n\n5. **Exceptions** :\n   - Si aucune annotation correspondant aux crit\u00e8res n'est trouv\u00e9e, la fonction l\u00e8ve une exception `NoSuchAnnotation`.\n\n6. **M\u00e9thode interne** : La fonction utilise `self.select` pour effectuer la recherche r\u00e9elle des annotations, en appliquant les filtres sp\u00e9cifi\u00e9s.\n\nEn r\u00e9sum\u00e9, cette fonction est un outil pour extraire des annotations sp\u00e9cifiques d'une structure de donn\u00e9es, en fonction de leur classe et \u00e9ventuellement de leur ensemble."
  },
  {
    "code": "def hasannotation(self,Class,set=None):\n        \"\"\"Returns an integer indicating whether such as annotation exists, and if so, how many.\n\n        See :meth:`AllowTokenAnnotation.annotations`` for a description of the parameters.\"\"\"\n        return sum( 1 for _ in self.select(Class,set,True,default_ignore_annotations))",
    "docstring": "Returns an integer indicating whether such as annotation exists, and if so, how many.\n\n        See :meth:`AllowTokenAnnotation.annotations`` for a description of the parameters.",
    "summary": "Cette fonction, `hasannotation`, v\u00e9rifie si une annotation sp\u00e9cifique existe pour une classe donn\u00e9e (`Class`) et, si oui, elle compte combien d'annotations de ce type sont pr\u00e9sentes. \n\nVoici une explication \u00e9tape par \u00e9tape :\n\n1. **Param\u00e8tres** :\n   - `self` : fait r\u00e9f\u00e9rence \u00e0 l'instance de la classe dans laquelle cette m\u00e9thode est d\u00e9finie.\n   - `Class` : la classe pour laquelle on cherche les annotations.\n   - `set` : un ensemble optionnel qui peut \u00eatre utilis\u00e9 pour filtrer les annotations (par d\u00e9faut, `None`).\n\n2. **Fonctionnement** :\n   - La m\u00e9thode utilise `self.select(Class, set, True, default_ignore_annotations)` pour s\u00e9lectionner les annotations pertinentes.\n   - Elle compte ensuite le nombre d'annotations trouv\u00e9es en utilisant une expression g\u00e9n\u00e9ratrice (`1 for _ in ...`), qui incr\u00e9mente un compteur pour chaque annotation correspondante.\n   - La fonction `sum` additionne tous ces compteurs pour donner le nombre total d'annotations.\n\n3. **R\u00e9sultat** :\n   - La fonction retourne un entier :\n     - **0** si aucune annotation n'est trouv\u00e9e.\n     - Un nombre sup\u00e9rieur \u00e0 0 indiquant le nombre d'annotations existantes.\n\nEn r\u00e9sum\u00e9, cette fonction permet de v\u00e9rifier la pr\u00e9sence et de compter les annotations sp\u00e9cifiques pour une classe donn\u00e9e."
  },
  {
    "code": "def annotation(self, type, set=None):\n        \"\"\"Obtain a single annotation element.\n\n        A further restriction can be made based on set.\n\n        Arguments:\n            Class (class): The class to select; any python class (not instance) subclassed off :class:`AbstractElement`\n            Set (str): The set to match against, only elements pertaining to this set will be returned. If set to None (default), all elements regardless of set will be returned.\n\n        Returns:\n            An element (instance derived from :class:`AbstractElement`)\n\n        Example::\n\n            sense = word.annotation(folia.Sense, 'http://some/path/cornetto').cls\n\n        See also:\n            :meth:`AllowTokenAnnotation.annotations`\n            :meth:`AbstractElement.select`\n\n        Raises:\n            :class:`NoSuchAnnotation` if no such annotation exists\n        \"\"\"\n        \"\"\"Will return a **single** annotation (even if there are multiple). Raises a ``NoSuchAnnotation`` exception if none was found\"\"\"\n        for e in self.select(type,set,True,default_ignore_annotations):\n            return e\n        raise NoSuchAnnotation()",
    "docstring": "Obtain a single annotation element.\n\n        A further restriction can be made based on set.\n\n        Arguments:\n            Class (class): The class to select; any python class (not instance) subclassed off :class:`AbstractElement`\n            Set (str): The set to match against, only elements pertaining to this set will be returned. If set to None (default), all elements regardless of set will be returned.\n\n        Returns:\n            An element (instance derived from :class:`AbstractElement`)\n\n        Example::\n\n            sense = word.annotation(folia.Sense, 'http://some/path/cornetto').cls\n\n        See also:\n            :meth:`AllowTokenAnnotation.annotations`\n            :meth:`AbstractElement.select`\n\n        Raises:\n            :class:`NoSuchAnnotation` if no such annotation exists",
    "summary": "Cette fonction, nomm\u00e9e `annotation`, permet de r\u00e9cup\u00e9rer un \u00e9l\u00e9ment d'annotation sp\u00e9cifique \u00e0 partir d'un objet. Voici une explication simplifi\u00e9e en fran\u00e7ais :\n\n1. **Objectif** : La fonction cherche et retourne un seul \u00e9l\u00e9ment d'annotation qui correspond \u00e0 certains crit\u00e8res.\n\n2. **Param\u00e8tres** :\n   - `type` : C'est le type d'annotation que vous cherchez. Il doit s'agir d'une classe Python qui h\u00e9rite de `AbstractElement`.\n   - `set` (optionnel) : Un filtre suppl\u00e9mentaire pour s\u00e9lectionner uniquement les annotations qui appartiennent \u00e0 un ensemble sp\u00e9cifique. Si `set` est `None` (par d\u00e9faut), toutes les annotations du type sp\u00e9cifi\u00e9 sont consid\u00e9r\u00e9es.\n\n3. **Fonctionnement** :\n   - La fonction parcourt les \u00e9l\u00e9ments disponibles en utilisant la m\u00e9thode `select` avec les crit\u00e8res sp\u00e9cifi\u00e9s (`type` et `set`).\n   - Si elle trouve un \u00e9l\u00e9ment correspondant, elle le retourne imm\u00e9diatement.\n   - Si aucun \u00e9l\u00e9ment correspondant n'est trouv\u00e9, elle l\u00e8ve une exception `NoSuchAnnotation` pour indiquer qu'aucune annotation ne correspond aux crit\u00e8res.\n\n4. **Exemple** :\n   - Si vous cherchez une annotation de type `folia.Sense` appartenant \u00e0 l'ensemble `'http://some/path/cornetto'`, la fonction retournera le premier \u00e9l\u00e9ment qui correspond \u00e0 ces crit\u00e8res.\n\n5. **Remarque** :\n   - La fonction retourne **un seul** \u00e9l\u00e9ment, m\u00eame s'il existe plusieurs annotations correspondantes.\n   - Si aucune annotation n'est trouv\u00e9e, une erreur `NoSuchAnnotation` est d\u00e9clench\u00e9e.\n\nEn r\u00e9sum\u00e9, cette fonction est un outil pour extraire une annotation sp\u00e9cifique en fonction de son type et \u00e9ventuellement de son ensemble, avec gestion des cas o\u00f9 l'annotation n'existe pas."
  },
  {
    "code": "def append(self, child, *args, **kwargs):\n        \"\"\"See ``AbstractElement.append()``\"\"\"\n        e = super(AbstractStructureElement,self).append(child, *args, **kwargs)\n        self._setmaxid(e)\n        return e",
    "docstring": "See ``AbstractElement.append()``",
    "summary": "Cette fonction, nomm\u00e9e `append`, est une m\u00e9thode qui permet d'ajouter un \u00e9l\u00e9ment (repr\u00e9sent\u00e9 par `child`) \u00e0 une structure existante. Voici ce qu'elle fait \u00e9tape par \u00e9tape :\n\n1. **Ajout de l'\u00e9l\u00e9ment** : Elle utilise la m\u00e9thode `append` de la classe parente (`super`) pour ajouter l'\u00e9l\u00e9ment `child` \u00e0 la structure, en tenant compte des arguments suppl\u00e9mentaires (`*args` et `**kwargs`).\n\n2. **Mise \u00e0 jour de l'ID maximum** : Apr\u00e8s avoir ajout\u00e9 l'\u00e9l\u00e9ment, elle appelle une autre m\u00e9thode interne `_setmaxid` pour mettre \u00e0 jour l'ID maximum de la structure, en fonction de l'\u00e9l\u00e9ment ajout\u00e9 (`e`).\n\n3. **Retour de l'\u00e9l\u00e9ment ajout\u00e9** : Enfin, elle retourne l'\u00e9l\u00e9ment qui vient d'\u00eatre ajout\u00e9 (`e`).\n\nEn r\u00e9sum\u00e9, cette fonction ajoute un \u00e9l\u00e9ment \u00e0 une structure, met \u00e0 jour l'ID maximum de la structure, et retourne l'\u00e9l\u00e9ment ajout\u00e9. C'est une m\u00e9thode utile pour g\u00e9rer des structures hi\u00e9rarchiques ou des listes d'\u00e9l\u00e9ments de mani\u00e8re organis\u00e9e."
  },
  {
    "code": "def words(self, index = None):\n        \"\"\"Returns a generator of Word elements found (recursively) under this element.\n\n        Arguments:\n            * ``index``: If set to an integer, will retrieve and return the n'th element (starting at 0) instead of returning the list of all\n        \"\"\"\n        if index is None:\n            return self.select(Word,None,True,default_ignore_structure)\n        else:\n            if index < 0:\n                index = self.count(Word,None,True,default_ignore_structure) + index\n            for i, e in enumerate(self.select(Word,None,True,default_ignore_structure)):\n                if i == index:\n                    return e\n            raise IndexError",
    "docstring": "Returns a generator of Word elements found (recursively) under this element.\n\n        Arguments:\n            * ``index``: If set to an integer, will retrieve and return the n'th element (starting at 0) instead of returning the list of all",
    "summary": "Cette fonction, nomm\u00e9e `words`, permet de r\u00e9cup\u00e9rer des \u00e9l\u00e9ments de type `Word` (mots) qui se trouvent sous l'\u00e9l\u00e9ment actuel (de mani\u00e8re r\u00e9cursive). Voici une explication simple en fran\u00e7ais :\n\n1. **Sans argument (`index = None`)** :  \n   La fonction retourne un **g\u00e9n\u00e9rateur** (une sorte de liste sp\u00e9ciale) contenant tous les mots trouv\u00e9s sous l'\u00e9l\u00e9ment actuel. Cela permet de parcourir les mots un par un sans charger tous les r\u00e9sultats en m\u00e9moire.\n\n2. **Avec un argument (`index` fourni)** :  \n   - Si `index` est un entier positif, la fonction retourne **un seul mot** : celui situ\u00e9 \u00e0 la position `index` (en commen\u00e7ant \u00e0 0).  \n   - Si `index` est n\u00e9gatif, il est interpr\u00e9t\u00e9 comme un index \u00e0 partir de la fin (par exemple, `-1` pour le dernier mot).  \n   - Si l'index est invalide (trop grand ou trop petit), une erreur `IndexError` est lev\u00e9e.\n\n**En r\u00e9sum\u00e9** :  \n- Sans index : donne tous les mots.  \n- Avec index : donne un mot sp\u00e9cifique (ou une erreur si l'index n'existe pas)."
  },
  {
    "code": "def paragraphs(self, index = None):\n        \"\"\"Returns a generator of Paragraph elements found (recursively) under this element.\n\n        Arguments:\n            index (int or None): If set to an integer, will retrieve and return the n'th element (starting at 0) instead of returning the generator of all\n        \"\"\"\n        if index is None:\n            return self.select(Paragraph,None,True,default_ignore_structure)\n        else:\n            if index < 0:\n                index = self.count(Paragraph,None,True,default_ignore_structure) + index\n            for i,e in enumerate(self.select(Paragraph,None,True,default_ignore_structure)):\n                if i == index:\n                    return e\n            raise IndexError",
    "docstring": "Returns a generator of Paragraph elements found (recursively) under this element.\n\n        Arguments:\n            index (int or None): If set to an integer, will retrieve and return the n'th element (starting at 0) instead of returning the generator of all",
    "summary": "Cette fonction, `paragraphs`, permet de r\u00e9cup\u00e9rer des \u00e9l\u00e9ments de type `Paragraph` (paragraphe) qui se trouvent sous l'\u00e9l\u00e9ment actuel dans une structure hi\u00e9rarchique (comme un document ou un arbre XML). Voici ce qu'elle fait en termes simples :\n\n1. **Sans indice (`index = None`)** :  \n   Elle retourne un **g\u00e9n\u00e9rateur** qui parcourt r\u00e9cursivement tous les paragraphes pr\u00e9sents sous l'\u00e9l\u00e9ment actuel. Un g\u00e9n\u00e9rateur permet d'it\u00e9rer sur les \u00e9l\u00e9ments un par un sans les charger tous en m\u00e9moire.\n\n2. **Avec un indice (`index` entier)** :  \n   - Si l'indice est n\u00e9gatif, il est converti en un indice positif en comptant \u00e0 partir de la fin de la liste des paragraphes.  \n   - Elle parcourt les paragraphes un par un et retourne uniquement le paragraphe correspondant \u00e0 l'indice sp\u00e9cifi\u00e9.  \n   - Si l'indice est hors des limites (trop grand ou trop petit), elle l\u00e8ve une erreur `IndexError`.\n\nEn r\u00e9sum\u00e9, cette fonction permet soit de r\u00e9cup\u00e9rer tous les paragraphes, soit d'acc\u00e9der directement \u00e0 un paragraphe sp\u00e9cifique en utilisant un indice."
  },
  {
    "code": "def sentences(self, index = None):\n        \"\"\"Returns a generator of Sentence elements found (recursively) under this element\n\n        Arguments:\n            index (int or None): If set to an integer, will retrieve and return the n'th element (starting at 0) instead of returning a generator of all\n        \"\"\"\n        if index is None:\n            return self.select(Sentence,None,True,default_ignore_structure)\n        else:\n            if index < 0:\n                index = self.count(Sentence,None,True,default_ignore_structure) + index\n            for i,e in enumerate(self.select(Sentence,None,True,default_ignore_structure)):\n                if i == index:\n                    return e\n            raise IndexError",
    "docstring": "Returns a generator of Sentence elements found (recursively) under this element\n\n        Arguments:\n            index (int or None): If set to an integer, will retrieve and return the n'th element (starting at 0) instead of returning a generator of all",
    "summary": "Cette fonction, `sentences`, permet de r\u00e9cup\u00e9rer des phrases (repr\u00e9sent\u00e9es par des objets `Sentence`) \u00e0 partir d'un \u00e9l\u00e9ment donn\u00e9. Voici une explication simple en fran\u00e7ais :\n\n1. **Sans indice (`index = None`)** :  \n   La fonction retourne un **g\u00e9n\u00e9rateur** qui parcourt **r\u00e9cursivement** tous les \u00e9l\u00e9ments `Sentence` trouv\u00e9s sous l'\u00e9l\u00e9ment actuel. Un g\u00e9n\u00e9rateur permet d'it\u00e9rer sur les phrases une par une sans les charger toutes en m\u00e9moire.\n\n2. **Avec un indice (`index` entier)** :  \n   - Si `index` est n\u00e9gatif, il est converti en un indice positif en comptant \u00e0 partir de la fin de la liste des phrases.  \n   - La fonction parcourt les phrases et retourne **uniquement la phrase \u00e0 la position sp\u00e9cifi\u00e9e par `index`**.  \n   - Si l'indice est hors des limites (trop grand ou trop petit), une erreur `IndexError` est lev\u00e9e.\n\nEn r\u00e9sum\u00e9, cette fonction permet soit de r\u00e9cup\u00e9rer toutes les phrases (sans indice), soit d'acc\u00e9der directement \u00e0 une phrase sp\u00e9cifique (avec un indice)."
  },
  {
    "code": "def layers(self, annotationtype=None,set=None):\n        \"\"\"Returns a list of annotation layers found *directly* under this element, does not include alternative layers\"\"\"\n        if inspect.isclass(annotationtype): annotationtype = annotationtype.ANNOTATIONTYPE\n        return [ x for x in self.select(AbstractAnnotationLayer,set,False,True) if annotationtype is None or x.ANNOTATIONTYPE == annotationtype ]",
    "docstring": "Returns a list of annotation layers found *directly* under this element, does not include alternative layers",
    "summary": "Cette fonction, nomm\u00e9e `layers`, permet de r\u00e9cup\u00e9rer une liste de couches d'annotations qui se trouvent **directement** sous un \u00e9l\u00e9ment donn\u00e9. Voici une explication d\u00e9taill\u00e9e en fran\u00e7ais :\n\n1. **Param\u00e8tres** :\n   - `annotationtype` : Optionnel. Si sp\u00e9cifi\u00e9, la fonction ne retournera que les couches d'annotations de ce type particulier.\n   - `set` : Optionnel. Permet de filtrer les couches d'annotations en fonction d'un ensemble sp\u00e9cifique.\n\n2. **Fonctionnement** :\n   - La fonction v\u00e9rifie d'abord si `annotationtype` est une classe. Si c'est le cas, elle utilise la propri\u00e9t\u00e9 `ANNOTATIONTYPE` de cette classe.\n   - Elle utilise ensuite la m\u00e9thode `select` pour r\u00e9cup\u00e9rer toutes les couches d'annotations (`AbstractAnnotationLayer`) qui se trouvent directement sous l'\u00e9l\u00e9ment courant.\n   - La fonction filtre ensuite ces couches pour ne garder que celles qui correspondent au type d'annotation sp\u00e9cifi\u00e9 (`annotationtype`), si un type a \u00e9t\u00e9 fourni. Si aucun type n'est sp\u00e9cifi\u00e9, toutes les couches sont retourn\u00e9es.\n\n3. **Retour** :\n   - La fonction retourne une liste de couches d'annotations qui r\u00e9pondent aux crit\u00e8res sp\u00e9cifi\u00e9s.\n\nEn r\u00e9sum\u00e9, cette fonction permet de lister les couches d'annotations directement li\u00e9es \u00e0 un \u00e9l\u00e9ment, avec la possibilit\u00e9 de filtrer par type d'annotation ou par ensemble sp\u00e9cifique."
  },
  {
    "code": "def hasannotationlayer(self, annotationtype=None,set=None):\n        \"\"\"Does the specified annotation layer exist?\"\"\"\n        l = self.layers(annotationtype, set)\n        return (len(l) > 0)",
    "docstring": "Does the specified annotation layer exist?",
    "summary": "Cette fonction, `hasannotationlayer`, v\u00e9rifie si une couche d'annotation sp\u00e9cifique existe dans un objet donn\u00e9. Voici comment elle fonctionne en termes simples :\n\n1. **Entr\u00e9es** :\n   - `annotationtype` : Le type d'annotation que vous cherchez (par exemple, des notes, des commentaires, etc.). Si vous ne sp\u00e9cifiez rien, elle v\u00e9rifie n'importe quel type.\n   - `set` : Un ensemble ou un groupe sp\u00e9cifique o\u00f9 chercher l'annotation. Si vous ne sp\u00e9cifiez rien, elle cherche dans tous les ensembles disponibles.\n\n2. **Processus** :\n   - La fonction utilise `self.layers` pour r\u00e9cup\u00e9rer une liste des couches d'annotation correspondant au type et \u00e0 l'ensemble sp\u00e9cifi\u00e9s.\n   - Elle v\u00e9rifie ensuite si cette liste est vide ou non.\n\n3. **Sortie** :\n   - Si au moins une couche d'annotation correspondant aux crit\u00e8res existe, la fonction retourne `True`.\n   - Sinon, elle retourne `False`.\n\nEn r\u00e9sum\u00e9, cette fonction r\u00e9pond \u00e0 la question : *\"Y a-t-il une couche d'annotation de ce type dans cet ensemble ?\"*"
  },
  {
    "code": "def xml(self, attribs = None,elements = None, skipchildren = False):\n        \"\"\"See :meth:`AbstractElement.xml`\"\"\"\n        if not attribs: attribs = {}\n        if self.idref:\n            attribs['id'] = self.idref\n        return super(AbstractTextMarkup,self).xml(attribs,elements, skipchildren)",
    "docstring": "See :meth:`AbstractElement.xml`",
    "summary": "Cette fonction, nomm\u00e9e `xml`, est une m\u00e9thode d'une classe appel\u00e9e `AbstractTextMarkup`. Elle sert \u00e0 g\u00e9n\u00e9rer une repr\u00e9sentation XML d'un \u00e9l\u00e9ment, en tenant compte de ses attributs et de ses enfants. Voici une explication \u00e9tape par \u00e9tape en fran\u00e7ais :\n\n1. **Param\u00e8tres** :\n   - `attribs` : Un dictionnaire d'attributs XML. S'il n'est pas fourni, il est initialis\u00e9 comme un dictionnaire vide (`{}`).\n   - `elements` : Une liste d'\u00e9l\u00e9ments enfants (non expliqu\u00e9 en d\u00e9tail ici, mais il semble \u00eatre optionnel).\n   - `skipchildren` : Un bool\u00e9en indiquant si les enfants de l'\u00e9l\u00e9ment doivent \u00eatre ignor\u00e9s lors de la g\u00e9n\u00e9ration du XML.\n\n2. **V\u00e9rification de l'ID** :\n   - Si l'objet a une propri\u00e9t\u00e9 `idref` (probablement une r\u00e9f\u00e9rence \u00e0 un identifiant), cet identifiant est ajout\u00e9 aux attributs sous la cl\u00e9 `'id'`.\n\n3. **Appel \u00e0 la m\u00e9thode parente** :\n   - La m\u00e9thode appelle la m\u00e9thode `xml` de la classe parente (`super(AbstractTextMarkup, self).xml(...)`) en passant les attributs, les \u00e9l\u00e9ments et le param\u00e8tre `skipchildren`. Cela permet de r\u00e9utiliser la logique de g\u00e9n\u00e9ration XML de la classe parente tout en ajoutant des fonctionnalit\u00e9s sp\u00e9cifiques \u00e0 `AbstractTextMarkup`.\n\n**En r\u00e9sum\u00e9** : Cette fonction g\u00e9n\u00e8re une repr\u00e9sentation XML d'un \u00e9l\u00e9ment, en incluant ses attributs (y compris un identifiant s'il existe) et en d\u00e9l\u00e9guant la gestion des enfants et des autres d\u00e9tails \u00e0 la m\u00e9thode correspondante de la classe parente."
  },
  {
    "code": "def json(self,attribs =None, recurse=True, ignorelist=False):\n        \"\"\"See :meth:`AbstractElement.json`\"\"\"\n        if not attribs: attribs = {}\n        if self.idref:\n            attribs['id'] = self.idref\n        return super(AbstractTextMarkup,self).json(attribs,recurse, ignorelist)",
    "docstring": "See :meth:`AbstractElement.json`",
    "summary": "Cette fonction, nomm\u00e9e `json`, est une m\u00e9thode d'une classe appel\u00e9e `AbstractTextMarkup`. Elle sert \u00e0 g\u00e9n\u00e9rer une repr\u00e9sentation JSON (un format de donn\u00e9es l\u00e9ger et facile \u00e0 lire) de l'\u00e9l\u00e9ment sur lequel elle est appel\u00e9e. Voici ce qu'elle fait en d\u00e9tail :\n\n1. **Param\u00e8tres** :\n   - `attribs` : Un dictionnaire optionnel qui permet d'ajouter des attributs personnalis\u00e9s \u00e0 la repr\u00e9sentation JSON. S'il n'est pas fourni, il est initialis\u00e9 comme un dictionnaire vide.\n   - `recurse` : Un bool\u00e9en qui indique si la fonction doit r\u00e9cursivement g\u00e9n\u00e9rer le JSON pour les \u00e9l\u00e9ments enfants. Par d\u00e9faut, il est vrai (`True`).\n   - `ignorelist` : Un bool\u00e9en qui, s'il est vrai, ignore certaines listes lors de la g\u00e9n\u00e9ration du JSON. Par d\u00e9faut, il est faux (`False`).\n\n2. **Ajout de l'ID** :\n   - Si l'\u00e9l\u00e9ment a une propri\u00e9t\u00e9 `idref` (une r\u00e9f\u00e9rence d'ID), elle est ajout\u00e9e au dictionnaire `attribs` sous la cl\u00e9 `'id'`.\n\n3. **Appel \u00e0 la m\u00e9thode parente** :\n   - La fonction appelle ensuite la m\u00e9thode `json` de la classe parente (`AbstractElement`) en passant les param\u00e8tres `attribs`, `recurse`, et `ignorelist`. Cela permet de r\u00e9utiliser la logique de g\u00e9n\u00e9ration de JSON d\u00e9finie dans la classe parente, tout en ajoutant des fonctionnalit\u00e9s sp\u00e9cifiques \u00e0 `AbstractTextMarkup`.\n\nEn r\u00e9sum\u00e9, cette fonction g\u00e9n\u00e8re une repr\u00e9sentation JSON d'un \u00e9l\u00e9ment de texte, en incluant \u00e9ventuellement des attributs personnalis\u00e9s et en tenant compte de l'ID de l'\u00e9l\u00e9ment, tout en s'appuyant sur la logique de la classe parente pour le reste du travail."
  },
  {
    "code": "def text(self, normalize_spaces=False):\n        \"\"\"Obtain the text (unicode instance)\"\"\"\n        return super(TextContent,self).text(normalize_spaces=normalize_spaces)",
    "docstring": "Obtain the text (unicode instance)",
    "summary": "Cette fonction, nomm\u00e9e `text`, est une m\u00e9thode d'une classe (probablement appel\u00e9e `TextContent`) qui permet d'obtenir le texte contenu dans un objet. Voici une explication simple en fran\u00e7ais :\n\n1. **But de la fonction** : Elle r\u00e9cup\u00e8re le texte associ\u00e9 \u00e0 l'objet sur lequel elle est appel\u00e9e.  \n2. **Param\u00e8tre `normalize_spaces=False`** :  \n   - Si ce param\u00e8tre est d\u00e9fini sur `True`, les espaces dans le texte seront normalis\u00e9s (par exemple, plusieurs espaces cons\u00e9cutifs pourraient \u00eatre r\u00e9duits \u00e0 un seul).  \n   - Par d\u00e9faut, ce param\u00e8tre est `False`, donc les espaces ne sont pas modifi\u00e9s.  \n3. **Retour** : La fonction retourne le texte sous forme d'une cha\u00eene de caract\u00e8res Unicode.  \n\nEn r\u00e9sum\u00e9, cette fonction permet d'extraire le texte d'un objet, avec la possibilit\u00e9 de normaliser les espaces si n\u00e9cessaire."
  },
  {
    "code": "def getreference(self, validate=True):\n        \"\"\"Returns and validates the Text Content's reference. Raises UnresolvableTextContent when invalid\"\"\"\n\n        if self.offset is None: return None #nothing to test\n        if self.ref:\n            ref = self.doc[self.ref]\n        else:\n            ref = self.finddefaultreference()\n\n        if not ref:\n            raise UnresolvableTextContent(\"Default reference for textcontent not found!\")\n        elif not ref.hastext(self.cls):\n            raise UnresolvableTextContent(\"Reference (ID \" + str(ref.id) + \") has no such text (class=\" + self.cls+\")\")\n        elif validate and self.text() != ref.textcontent(self.cls).text()[self.offset:self.offset+len(self.data[0])]:\n            raise UnresolvableTextContent(\"Reference (ID \" + str(ref.id) + \", class=\" + self.cls+\") found but no text match at specified offset (\"+str(self.offset)+\")! Expected '\" + self.text() + \"', got '\" + ref.textcontent(self.cls).text()[self.offset:self.offset+len(self.data[0])] +\"'\")\n        else:\n            #finally, we made it!\n            return ref",
    "docstring": "Returns and validates the Text Content's reference. Raises UnresolvableTextContent when invalid",
    "summary": "Cette fonction, `getreference`, est utilis\u00e9e pour r\u00e9cup\u00e9rer et valider une r\u00e9f\u00e9rence associ\u00e9e \u00e0 un contenu textuel. Voici ce qu'elle fait \u00e9tape par \u00e9tape :\n\n1. **V\u00e9rification de l'offset** : Si `self.offset` est `None`, la fonction retourne `None` car il n'y a rien \u00e0 tester.\n  \n2. **R\u00e9cup\u00e9ration de la r\u00e9f\u00e9rence** :\n   - Si `self.ref` existe, elle utilise cette r\u00e9f\u00e9rence.\n   - Sinon, elle cherche une r\u00e9f\u00e9rence par d\u00e9faut en appelant `self.finddefaultreference()`.\n\n3. **Validation de la r\u00e9f\u00e9rence** :\n   - Si aucune r\u00e9f\u00e9rence n'est trouv\u00e9e, elle l\u00e8ve une exception `UnresolvableTextContent` indiquant que la r\u00e9f\u00e9rence par d\u00e9faut n'a pas \u00e9t\u00e9 trouv\u00e9e.\n   - Si la r\u00e9f\u00e9rence n'a pas de texte correspondant \u00e0 la classe sp\u00e9cifi\u00e9e (`self.cls`), elle l\u00e8ve une exception indiquant que la r\u00e9f\u00e9rence n'a pas le texte attendu.\n   - Si `validate` est `True`, elle v\u00e9rifie si le texte \u00e0 l'offset sp\u00e9cifi\u00e9 correspond \u00e0 ce qui est attendu. Si ce n'est pas le cas, elle l\u00e8ve une exception indiquant que le texte ne correspond pas.\n\n4. **Retour de la r\u00e9f\u00e9rence** : Si toutes les validations passent, la fonction retourne la r\u00e9f\u00e9rence.\n\nEn r\u00e9sum\u00e9, cette fonction s'assure que la r\u00e9f\u00e9rence associ\u00e9e au contenu textuel est valide et correspond \u00e0 ce qui est attendu, en levant des erreurs si quelque chose ne va pas."
  },
  {
    "code": "def xml(self, attribs = None,elements = None, skipchildren = False):\n        \"\"\"See :meth:`AbstractElement.xml`\"\"\"\n        attribs = {}\n        if not self.offset is None:\n            attribs['{' + NSFOLIA + '}offset'] = str(self.offset)\n        if self.parent and self.ref:\n            attribs['{' + NSFOLIA + '}ref'] = self.ref\n\n        #if self.cls != 'current' and not (self.cls == 'original' and any( isinstance(x, Original) for x in self.ancestors() )  ):\n        #    attribs['{' + NSFOLIA + '}class'] = self.cls\n        #else:\n        #    if '{' + NSFOLIA + '}class' in attribs:\n        #        del attribs['{' + NSFOLIA + '}class']\n        #return E.t(self.value, **attribs)\n\n        e = super(TextContent,self).xml(attribs,elements,skipchildren)\n        if '{' + NSFOLIA + '}class' in e.attrib and e.attrib['{' + NSFOLIA + '}class'] == \"current\":\n            #delete 'class=current'\n            del e.attrib['{' + NSFOLIA + '}class']\n\n        return e",
    "docstring": "See :meth:`AbstractElement.xml`",
    "summary": "Cette fonction, nomm\u00e9e `xml`, est une m\u00e9thode d'une classe (probablement appel\u00e9e `TextContent`) qui g\u00e9n\u00e8re une repr\u00e9sentation XML d'un \u00e9l\u00e9ment. Voici une explication simplifi\u00e9e de ce qu'elle fait :\n\n1. **Initialisation des attributs** : Elle commence par cr\u00e9er un dictionnaire vide `attribs` pour stocker les attributs XML de l'\u00e9l\u00e9ment.\n\n2. **Ajout d'attributs sp\u00e9cifiques** :\n   - Si l'\u00e9l\u00e9ment a une propri\u00e9t\u00e9 `offset`, elle ajoute un attribut XML avec le nom `{NSFOLIA}offset` et la valeur de `offset`.\n   - Si l'\u00e9l\u00e9ment a un parent et une r\u00e9f\u00e9rence (`ref`), elle ajoute un attribut XML avec le nom `{NSFOLIA}ref` et la valeur de `ref`.\n\n3. **Appel \u00e0 la m\u00e9thode parente** : Elle utilise `super()` pour appeler la m\u00e9thode `xml` de la classe parente (`AbstractElement`), en passant les attributs, les \u00e9l\u00e9ments et un drapeau `skipchildren`. Cela g\u00e9n\u00e8re l'\u00e9l\u00e9ment XML de base.\n\n4. **Suppression d'un attribut sp\u00e9cifique** : Si l'\u00e9l\u00e9ment XML g\u00e9n\u00e9r\u00e9 a un attribut `{NSFOLIA}class` avec la valeur `\"current\"`, elle supprime cet attribut.\n\n5. **Retour de l'\u00e9l\u00e9ment XML** : Enfin, elle retourne l'\u00e9l\u00e9ment XML complet, \u00e9ventuellement modifi\u00e9.\n\nEn r\u00e9sum\u00e9, cette fonction g\u00e9n\u00e8re une repr\u00e9sentation XML d'un \u00e9l\u00e9ment, en ajoutant des attributs sp\u00e9cifiques et en nettoyant un attribut particulier si n\u00e9cessaire."
  },
  {
    "code": "def getreference(self, validate=True):\n        \"\"\"Return and validate the Phonetic Content's reference. Raises UnresolvableTextContent when invalid\"\"\"\n\n        if self.offset is None: return None #nothing to test\n        if self.ref:\n            ref = self.doc[self.ref]\n        else:\n            ref = self.finddefaultreference()\n\n        if not ref:\n            raise UnresolvableTextContent(\"Default reference for phonetic content not found!\")\n        elif not ref.hasphon(self.cls):\n            raise UnresolvableTextContent(\"Reference has no such phonetic content (class=\" + self.cls+\")\")\n        elif validate and self.phon() != ref.textcontent(self.cls).phon()[self.offset:self.offset+len(self.data[0])]:\n            raise UnresolvableTextContent(\"Reference (class=\" + self.cls+\") found but no phonetic match at specified offset (\"+str(self.offset)+\")! Expected '\" + self.text() + \"', got '\" + ref.textcontent(self.cls).text()[self.offset:self.offset+len(self.data[0])] +\"'\")\n        else:\n            #finally, we made it!\n            return ref",
    "docstring": "Return and validate the Phonetic Content's reference. Raises UnresolvableTextContent when invalid",
    "summary": "Cette fonction, `getreference`, est utilis\u00e9e pour r\u00e9cup\u00e9rer et valider une r\u00e9f\u00e9rence li\u00e9e \u00e0 un contenu phon\u00e9tique. Voici une explication \u00e9tape par \u00e9tape en fran\u00e7ais :\n\n1. **V\u00e9rification de l'offset** : Si `self.offset` est `None`, la fonction retourne `None` car il n'y a rien \u00e0 tester.  \n2. **R\u00e9cup\u00e9ration de la r\u00e9f\u00e9rence** :  \n   - Si une r\u00e9f\u00e9rence (`self.ref`) existe d\u00e9j\u00e0, elle est r\u00e9cup\u00e9r\u00e9e depuis `self.doc`.  \n   - Sinon, la fonction cherche une r\u00e9f\u00e9rence par d\u00e9faut en utilisant `self.finddefaultreference()`.  \n3. **Validation de la r\u00e9f\u00e9rence** :  \n   - Si aucune r\u00e9f\u00e9rence n'est trouv\u00e9e, une erreur `UnresolvableTextContent` est lev\u00e9e avec un message indiquant que la r\u00e9f\u00e9rence par d\u00e9faut n'a pas \u00e9t\u00e9 trouv\u00e9e.  \n   - Si la r\u00e9f\u00e9rence n'a pas le contenu phon\u00e9tique attendu (d\u00e9termin\u00e9 par `self.cls`), une erreur est lev\u00e9e pour signaler l'absence de ce contenu.  \n   - Si `validate` est `True`, la fonction v\u00e9rifie si le contenu phon\u00e9tique correspond \u00e0 ce qui est attendu \u00e0 l'offset sp\u00e9cifi\u00e9. Si ce n'est pas le cas, une erreur est lev\u00e9e pour indiquer la discordance.  \n4. **Retour de la r\u00e9f\u00e9rence** : Si toutes les v\u00e9rifications sont r\u00e9ussies, la r\u00e9f\u00e9rence est retourn\u00e9e.  \n\nEn r\u00e9sum\u00e9, cette fonction assure que la r\u00e9f\u00e9rence phon\u00e9tique est valide et correspond aux attentes, en levant des erreurs si des probl\u00e8mes sont d\u00e9tect\u00e9s."
  },
  {
    "code": "def finddefaultreference(self):\n        \"\"\"Find the default reference for text offsets:\n          The parent of the current textcontent's parent (counting only Structure Elements and Subtoken Annotation Elements)\n\n          Note: This returns not a TextContent element, but its parent. Whether the textcontent actually exists is checked later/elsewhere\n        \"\"\"\n\n        depth = 0\n        e = self\n        while True:\n            if e.parent:\n                e = e.parent #pylint: disable=redefined-variable-type\n            else:\n                #no parent, breaking\n                return False\n\n            if isinstance(e,AbstractStructureElement) or isinstance(e,AbstractSubtokenAnnotation):\n                depth += 1\n                if depth == 2:\n                    return e\n\n\n        return False",
    "docstring": "Find the default reference for text offsets:\n          The parent of the current textcontent's parent (counting only Structure Elements and Subtoken Annotation Elements)\n\n          Note: This returns not a TextContent element, but its parent. Whether the textcontent actually exists is checked later/elsewhere",
    "summary": "Voici une explication en fran\u00e7ais de ce que fait cette fonction :\n\nLa fonction `finddefaultreference` a pour but de trouver la r\u00e9f\u00e9rence par d\u00e9faut pour les d\u00e9calages de texte. Elle fonctionne de la mani\u00e8re suivante :\n\n1. **Objectif** : Elle recherche l'anc\u00eatre d'un \u00e9l\u00e9ment de texte actuel, en remontant dans la hi\u00e9rarchie des parents, mais en ne comptant que les \u00e9l\u00e9ments de structure (Structure Elements) et les \u00e9l\u00e9ments d'annotation de sous-jetons (Subtoken Annotation Elements).\n\n2. **Processus** :\n   - Elle commence \u00e0 partir de l'\u00e9l\u00e9ment actuel (`self`).\n   - Elle remonte dans la hi\u00e9rarchie des parents en v\u00e9rifiant chaque parent.\n   - Elle ignore les parents qui ne sont ni des \u00e9l\u00e9ments de structure ni des \u00e9l\u00e9ments d'annotation de sous-jetons.\n   - Elle compte le nombre de niveaux (profondeur) qu'elle parcourt.\n   - Lorsqu'elle atteint une profondeur de 2 (c'est-\u00e0-dire qu'elle a trouv\u00e9 deux \u00e9l\u00e9ments cons\u00e9cutifs de type Structure ou Annotation de sous-jetons), elle retourne le parent actuel.\n\n3. **R\u00e9sultat** :\n   - Si elle trouve la r\u00e9f\u00e9rence par d\u00e9faut (profondeur de 2), elle retourne cet \u00e9l\u00e9ment parent.\n   - Si elle ne trouve pas de parent correspondant (par exemple, si elle atteint la racine sans trouver deux \u00e9l\u00e9ments cons\u00e9cutifs de type Structure ou Annotation de sous-jetons), elle retourne `False`.\n\nEn r\u00e9sum\u00e9, cette fonction cherche l'anc\u00eatre d'un \u00e9l\u00e9ment de texte actuel, en se concentrant uniquement sur les \u00e9l\u00e9ments de structure et d'annotation de sous-jetons, et retourne le parent trouv\u00e9 apr\u00e8s avoir remont\u00e9 deux niveaux dans la hi\u00e9rarchie. Si elle ne trouve pas de tel parent, elle retourne `False`."
  },
  {
    "code": "def findreplaceables(Class, parent, set, **kwargs):#pylint: disable=bad-classmethod-argument\n        \"\"\"(Method for internal usage, see AbstractElement)\"\"\"\n        #some extra behaviour for text content elements, replace also based on the 'corrected' attribute:\n        if 'cls' not in kwargs:\n            kwargs['cls'] = 'current'\n        replace = super(PhonContent, Class).findreplaceables(parent, set, **kwargs)\n        replace = [ x for x in replace if x.cls == kwargs['cls']]\n        del kwargs['cls'] #always delete what we processed\n        return replace",
    "docstring": "(Method for internal usage, see AbstractElement)",
    "summary": "Voici une explication en fran\u00e7ais de ce que fait cette fonction :\n\nCette fonction, `findreplaceables`, est une m\u00e9thode interne utilis\u00e9e pour trouver et filtrer des \u00e9l\u00e9ments sp\u00e9cifiques dans une structure de donn\u00e9es. Elle est con\u00e7ue pour \u00eatre utilis\u00e9e dans le contexte d'une classe `PhonContent`, qui semble g\u00e9rer des \u00e9l\u00e9ments de contenu textuel.\n\n**Voici son fonctionnement \u00e9tape par \u00e9tape :**\n\n1. **V\u00e9rification et initialisation** : La fonction v\u00e9rifie si un param\u00e8tre `cls` est pr\u00e9sent dans `kwargs` (arguments suppl\u00e9mentaires). Si ce n'est pas le cas, elle l'ajoute avec la valeur `'current'`.\n\n2. **Appel \u00e0 la m\u00e9thode parente** : Elle utilise `super()` pour appeler la m\u00e9thode `findreplaceables` de la classe parente (`PhonContent`), en passant les param\u00e8tres `parent`, `set`, et les arguments suppl\u00e9mentaires (`**kwargs`). Cela permet de r\u00e9cup\u00e9rer une liste d'\u00e9l\u00e9ments rempla\u00e7ables.\n\n3. **Filtrage des \u00e9l\u00e9ments** : La fonction filtre ensuite cette liste pour ne garder que les \u00e9l\u00e9ments dont l'attribut `cls` correspond \u00e0 la valeur sp\u00e9cifi\u00e9e dans `kwargs['cls']`.\n\n4. **Nettoyage** : Apr\u00e8s le filtrage, elle supprime l'entr\u00e9e `cls` de `kwargs` pour \u00e9viter qu'elle ne soit utilis\u00e9e \u00e0 nouveau par erreur.\n\n5. **Retour du r\u00e9sultat** : Enfin, elle retourne la liste filtr\u00e9e des \u00e9l\u00e9ments rempla\u00e7ables.\n\n**En r\u00e9sum\u00e9**, cette fonction permet de trouver des \u00e9l\u00e9ments sp\u00e9cifiques dans une structure de donn\u00e9es, en se basant sur une classe (`cls`) donn\u00e9e, et retourne uniquement ceux qui correspondent \u00e0 ce crit\u00e8re. Elle est particuli\u00e8rement utile pour g\u00e9rer des \u00e9l\u00e9ments de contenu textuel avec des attributs sp\u00e9cifiques."
  },
  {
    "code": "def parsexml(Class, node, doc, **kwargs):#pylint: disable=bad-classmethod-argument\n        \"\"\"(Method for internal usage, see AbstractElement)\"\"\"\n        if not kwargs: kwargs = {}\n        if 'offset' in node.attrib:\n            kwargs['offset'] = int(node.attrib['offset'])\n        if 'ref' in node.attrib:\n            kwargs['ref'] = node.attrib['ref']\n        return super(PhonContent,Class).parsexml(node,doc, **kwargs)",
    "docstring": "(Method for internal usage, see AbstractElement)",
    "summary": "Cette fonction, `parsexml`, est une m\u00e9thode interne utilis\u00e9e pour analyser un n\u0153ud XML et cr\u00e9er une instance d'une classe sp\u00e9cifique (repr\u00e9sent\u00e9e par `Class`). Voici une explication \u00e9tape par \u00e9tape en fran\u00e7ais :\n\n1. **Objectif** : La fonction est con\u00e7ue pour traiter un n\u0153ud XML (`node`) et un document XML (`doc`), puis retourner une instance de la classe `Class` en utilisant les informations contenues dans le n\u0153ud.\n\n2. **Gestion des arguments suppl\u00e9mentaires (`kwargs`)** :\n   - Si aucun argument suppl\u00e9mentaire (`kwargs`) n'est fourni, un dictionnaire vide est initialis\u00e9.\n   - Si le n\u0153ud XML contient un attribut `offset`, sa valeur est convertie en entier et ajout\u00e9e \u00e0 `kwargs`.\n   - Si le n\u0153ud XML contient un attribut `ref`, sa valeur est directement ajout\u00e9e \u00e0 `kwargs`.\n\n3. **Appel \u00e0 la m\u00e9thode parente** :\n   - La fonction appelle ensuite la m\u00e9thode `parsexml` de la classe parente (`super(PhonContent, Class).parsexml`), en passant le n\u0153ud (`node`), le document (`doc`), et les arguments suppl\u00e9mentaires (`kwargs`) trait\u00e9s pr\u00e9c\u00e9demment.\n\n4. **Retour** : La fonction retourne l'instance de la classe `Class` cr\u00e9\u00e9e par la m\u00e9thode parente.\n\nEn r\u00e9sum\u00e9, cette fonction pr\u00e9pare les donn\u00e9es du n\u0153ud XML (en extrayant les attributs `offset` et `ref` si pr\u00e9sents) et les passe \u00e0 une m\u00e9thode parente pour cr\u00e9er une instance de la classe sp\u00e9cifi\u00e9e."
  },
  {
    "code": "def morphemes(self,set=None):\n        \"\"\"Generator yielding all morphemes (in a particular set if specified). For retrieving one specific morpheme by index, use morpheme() instead\"\"\"\n        for layer in self.select(MorphologyLayer):\n            for m in layer.select(Morpheme, set):\n                yield m",
    "docstring": "Generator yielding all morphemes (in a particular set if specified). For retrieving one specific morpheme by index, use morpheme() instead",
    "summary": "Cette fonction, `morphemes`, est un g\u00e9n\u00e9rateur qui produit tous les morph\u00e8mes (unit\u00e9s minimales de sens dans une langue) d'un objet donn\u00e9. Voici une explication \u00e9tape par \u00e9tape en fran\u00e7ais :\n\n1. **G\u00e9n\u00e9rateur** : La fonction est con\u00e7ue pour \u00eatre utilis\u00e9e dans une boucle, o\u00f9 elle produit un morph\u00e8me \u00e0 la fois, sans les stocker tous en m\u00e9moire. C'est utile pour traiter de grandes quantit\u00e9s de donn\u00e9es sans surcharger la m\u00e9moire.\n\n2. **Param\u00e8tre `set`** : Si un ensemble sp\u00e9cifique (`set`) est fourni, la fonction ne produira que les morph\u00e8mes appartenant \u00e0 cet ensemble. Sinon, elle produira tous les morph\u00e8mes disponibles.\n\n3. **Boucle sur les couches morphologiques** : La fonction parcourt d'abord toutes les `MorphologyLayer` (couches morphologiques) disponibles dans l'objet `self`.\n\n4. **Boucle sur les morph\u00e8mes** : Pour chaque couche morphologique, elle parcourt ensuite tous les `Morpheme` (morph\u00e8mes) pr\u00e9sents dans cette couche, en tenant compte de l'ensemble sp\u00e9cifi\u00e9 si n\u00e9cessaire.\n\n5. **Production des morph\u00e8mes** : Chaque morph\u00e8me trouv\u00e9 est \"produit\" (ou \"yield\u00e9\") un par un, permettant \u00e0 l'utilisateur de les traiter au fur et \u00e0 mesure.\n\nEn r\u00e9sum\u00e9, cette fonction est un outil pratique pour parcourir et traiter tous les morph\u00e8mes d'un objet, avec la possibilit\u00e9 de filtrer par ensemble sp\u00e9cifique si besoin. Si vous avez besoin de r\u00e9cup\u00e9rer un morph\u00e8me sp\u00e9cifique par son index, la documentation sugg\u00e8re d'utiliser la fonction `morpheme()` \u00e0 la place."
  },
  {
    "code": "def phonemes(self,set=None):\n        \"\"\"Generator yielding all phonemes (in a particular set if specified). For retrieving one specific morpheme by index, use morpheme() instead\"\"\"\n        for layer in self.select(PhonologyLayer):\n            for p in layer.select(Phoneme, set):\n                yield p",
    "docstring": "Generator yielding all phonemes (in a particular set if specified). For retrieving one specific morpheme by index, use morpheme() instead",
    "summary": "Cette fonction, nomm\u00e9e `phonemes`, est une m\u00e9thode qui g\u00e9n\u00e8re et retourne tous les **phon\u00e8mes** d'un objet donn\u00e9. Voici une explication simple en fran\u00e7ais :\n\n1. **Objectif** : La fonction permet de parcourir et de r\u00e9cup\u00e9rer tous les phon\u00e8mes (unit\u00e9s de son de la parole) pr\u00e9sents dans un objet, \u00e9ventuellement en filtrant par un ensemble sp\u00e9cifique si celui-ci est fourni.\n\n2. **Fonctionnement** :\n   - Elle parcourt toutes les **couches de phonologie** (`PhonologyLayer`) disponibles dans l'objet.\n   - Pour chaque couche, elle s\u00e9lectionne les phon\u00e8mes (`Phoneme`) en tenant compte d'un ensemble sp\u00e9cifique (`set`) si celui-ci est fourni.\n   - Elle retourne chaque phon\u00e8me un par un gr\u00e2ce au mot-cl\u00e9 `yield`, ce qui en fait un **g\u00e9n\u00e9rateur**.\n\n3. **Utilisation** :\n   - Si vous voulez r\u00e9cup\u00e9rer tous les phon\u00e8mes sans filtre, appelez simplement `phonemes()`.\n   - Si vous voulez filtrer par un ensemble sp\u00e9cifique, utilisez `phonemes(set=votre_ensemble)`.\n\n4. **Remarque** : Si vous cherchez \u00e0 r\u00e9cup\u00e9rer un phon\u00e8me sp\u00e9cifique par son index, il est recommand\u00e9 d'utiliser une autre m\u00e9thode appel\u00e9e `morpheme()` plut\u00f4t que cette fonction.\n\nEn r\u00e9sum\u00e9, cette fonction est un outil pratique pour explorer et r\u00e9cup\u00e9rer les phon\u00e8mes d'un objet, avec ou sans filtrage par ensemble."
  },
  {
    "code": "def morpheme(self,index, set=None):\n        \"\"\"Returns a specific morpheme, the n'th morpheme (given the particular set if specified).\"\"\"\n        for layer in self.select(MorphologyLayer):\n            for i, m in enumerate(layer.select(Morpheme, set)):\n                if index == i:\n                    return m\n        raise NoSuchAnnotation",
    "docstring": "Returns a specific morpheme, the n'th morpheme (given the particular set if specified).",
    "summary": "Cette fonction, `morpheme`, permet de r\u00e9cup\u00e9rer un morph\u00e8me sp\u00e9cifique \u00e0 partir d'un objet qui contient des couches de morphologie. Voici comment elle fonctionne en termes simples :\n\n1. **Objectif** : Elle renvoie le *n*-i\u00e8me morph\u00e8me (c'est-\u00e0-dire le morph\u00e8me \u00e0 une position sp\u00e9cifique) dans une couche de morphologie. Si un ensemble particulier de morph\u00e8mes est sp\u00e9cifi\u00e9 (`set`), elle se limite \u00e0 cet ensemble.\n\n2. **Fonctionnement** :\n   - Elle parcourt toutes les couches de morphologie (`MorphologyLayer`) disponibles dans l'objet.\n   - Pour chaque couche, elle examine tous les morph\u00e8mes (`Morpheme`) pr\u00e9sents, en les num\u00e9rotant (avec `enumerate`).\n   - Si la position (`index`) correspond \u00e0 celle du morph\u00e8me en cours d'examen, elle renvoie ce morph\u00e8me.\n   - Si aucun morph\u00e8me correspondant n'est trouv\u00e9, elle l\u00e8ve une erreur (`NoSuchAnnotation`) pour indiquer que le morph\u00e8me demand\u00e9 n'existe pas.\n\n3. **Exemple** :\n   Si vous demandez le morph\u00e8me \u00e0 l'index `2` dans un ensemble sp\u00e9cifique, la fonction cherchera le troisi\u00e8me morph\u00e8me (car les index commencent \u00e0 0) dans cet ensemble et le renverra s'il existe.\n\nEn r\u00e9sum\u00e9, cette fonction permet de r\u00e9cup\u00e9rer un morph\u00e8me pr\u00e9cis en fonction de sa position et, \u00e9ventuellement, d'un ensemble sp\u00e9cifique."
  },
  {
    "code": "def phoneme(self,index, set=None):\n        \"\"\"Returns a specific phoneme, the n'th morpheme (given the particular set if specified).\"\"\"\n        for layer in self.select(PhonologyLayer):\n            for i, p in enumerate(layer.select(Phoneme, set)):\n                if index == i:\n                    return p\n        raise NoSuchAnnotation",
    "docstring": "Returns a specific phoneme, the n'th morpheme (given the particular set if specified).",
    "summary": "Cette fonction, `phoneme`, permet de r\u00e9cup\u00e9rer un phon\u00e8me sp\u00e9cifique dans une structure de donn\u00e9es linguistique. Voici comment elle fonctionne en termes simples :\n\n1. **Objectif** : Elle renvoie un phon\u00e8me particulier, identifi\u00e9 par son indice (sa position) dans une liste de phon\u00e8mes. Si un ensemble sp\u00e9cifique de phon\u00e8mes est fourni, elle se limite \u00e0 cet ensemble.\n\n2. **Fonctionnement** :\n   - Elle parcourt toutes les couches de phonologie (`PhonologyLayer`) disponibles.\n   - Pour chaque couche, elle examine les phon\u00e8mes (`Phoneme`) un par un, en les num\u00e9rotant (avec `enumerate`).\n   - Si l'indice (`index`) correspond \u00e0 la position actuelle du phon\u00e8me, elle le renvoie.\n   - Si aucun phon\u00e8me correspondant n'est trouv\u00e9 apr\u00e8s la recherche, elle l\u00e8ve une erreur (`NoSuchAnnotation`) pour indiquer que le phon\u00e8me demand\u00e9 n'existe pas.\n\n3. **En r\u00e9sum\u00e9** : C'est comme chercher un mot pr\u00e9cis dans un dictionnaire en utilisant son num\u00e9ro de page et, si n\u00e9cessaire, en se limitant \u00e0 une section sp\u00e9cifique du dictionnaire. Si le mot n'est pas trouv\u00e9, on re\u00e7oit un message d'erreur."
  },
  {
    "code": "def findspans(self, type,set=None):\n        \"\"\"Yields span annotation elements of the specified type that include this word.\n\n        Arguments:\n            type: The annotation type, can be passed as using any of the :class:`AnnotationType` member, or by passing the relevant :class:`AbstractSpanAnnotation` or :class:`AbstractAnnotationLayer` class.\n            set (str or None): Constrain by set\n\n        Example::\n\n            for chunk in word.findspans(folia.Chunk):\n                print(\" Chunk class=\", chunk.cls, \" words=\")\n                for word2 in chunk.wrefs(): #print all words in the chunk (of which the word is a part)\n                    print(word2, end=\"\")\n                print()\n\n        Yields:\n            Matching span annotation instances (derived from :class:`AbstractSpanAnnotation`)\n        \"\"\"\n\n        if issubclass(type, AbstractAnnotationLayer):\n            layerclass = type\n        else:\n            layerclass = ANNOTATIONTYPE2LAYERCLASS[type.ANNOTATIONTYPE]\n        e = self\n        while True:\n            if not e.parent: break\n            e = e.parent\n            for layer in e.select(layerclass,set,False):\n                if type is layerclass:\n                    for e2 in layer.select(AbstractSpanAnnotation,set,True, (True, Word, Morpheme)):\n                        if not isinstance(e2, AbstractSpanRole) and self in e2.wrefs():\n                            yield e2\n                else:\n                    for e2 in layer.select(type,set,True, (True, Word, Morpheme)):\n                        if not isinstance(e2, AbstractSpanRole) and self in e2.wrefs():\n                            yield e2",
    "docstring": "Yields span annotation elements of the specified type that include this word.\n\n        Arguments:\n            type: The annotation type, can be passed as using any of the :class:`AnnotationType` member, or by passing the relevant :class:`AbstractSpanAnnotation` or :class:`AbstractAnnotationLayer` class.\n            set (str or None): Constrain by set\n\n        Example::\n\n            for chunk in word.findspans(folia.Chunk):\n                print(\" Chunk class=\", chunk.cls, \" words=\")\n                for word2 in chunk.wrefs(): #print all words in the chunk (of which the word is a part)\n                    print(word2, end=\"\")\n                print()\n\n        Yields:\n            Matching span annotation instances (derived from :class:`AbstractSpanAnnotation`)",
    "summary": "Cette fonction, `findspans`, permet de rechercher et de retourner des annotations d'\u00e9tendue (ou *spans*) sp\u00e9cifiques dans un texte. Voici une explication simplifi\u00e9e en fran\u00e7ais :\n\n**Objectif :**  \nLa fonction identifie toutes les annotations d'\u00e9tendue d'un certain type qui incluent un mot donn\u00e9. Elle retourne ces annotations une par une (gr\u00e2ce au mot-cl\u00e9 `yield`).\n\n**Param\u00e8tres :**\n- **type** : Le type d'annotation que l'on cherche. Cela peut \u00eatre sp\u00e9cifi\u00e9 en utilisant une classe d'annotation ou un type d'annotation particulier.\n- **set** (optionnel) : Permet de limiter la recherche \u00e0 un ensemble sp\u00e9cifique d'annotations.\n\n**Fonctionnement :**\n1. La fonction v\u00e9rifie d'abord si le type d'annotation fourni correspond \u00e0 une couche d'annotation (*layer*) ou \u00e0 une annotation d'\u00e9tendue sp\u00e9cifique.\n2. Elle parcourt ensuite la hi\u00e9rarchie des \u00e9l\u00e9ments parents du mot donn\u00e9 pour trouver des couches d'annotation pertinentes.\n3. Pour chaque couche trouv\u00e9e, elle recherche les annotations d'\u00e9tendue qui incluent le mot en question.\n4. Elle exclut les annotations de r\u00f4le (*AbstractSpanRole*) et ne retourne que les annotations d'\u00e9tendue valides.\n\n**R\u00e9sultat :**  \nLa fonction g\u00e9n\u00e8re (ou *yield*) une par une les annotations d'\u00e9tendue qui correspondent aux crit\u00e8res de recherche.\n\n**Exemple d'utilisation :**  \nSi vous avez un mot dans un texte et que vous voulez trouver toutes les phrases ou groupes de mots (chunks) qui contiennent ce mot, cette fonction vous retournera ces \u00e9l\u00e9ments.\n\nEn r\u00e9sum\u00e9, `findspans` est un outil pour explorer et extraire des annotations sp\u00e9cifiques dans un texte structur\u00e9, en se concentrant sur les \u00e9tendues qui incluent un mot donn\u00e9."
  },
  {
    "code": "def deepvalidation(self):\n        \"\"\"Perform deep validation of this element.\n\n        Raises:\n            :class:`DeepValidationError`\n        \"\"\"\n        if self.doc and self.doc.deepvalidation and self.parent.set and self.parent.set[0] != '_':\n            try:\n                self.doc.setdefinitions[self.parent.set].testsubclass(self.parent.cls, self.subset, self.cls)\n            except KeyError as e:\n                if self.parent.cls and not self.doc.allowadhocsets:\n                    raise DeepValidationError(\"Set definition \" + self.parent.set + \" for \" + self.parent.XMLTAG + \" not loaded (feature validation failed)!\")\n            except DeepValidationError as e:\n                errormsg =  str(e) + \" (in set \" + self.parent.set+\" for \" + self.parent.XMLTAG\n                if self.parent.id:\n                    errormsg += \" with ID \" + self.parent.id\n                errormsg +=  \")\"\n                raise DeepValidationError(errormsg)",
    "docstring": "Perform deep validation of this element.\n\n        Raises:\n            :class:`DeepValidationError`",
    "summary": "Cette fonction, `deepvalidation`, effectue une validation approfondie d'un \u00e9l\u00e9ment donn\u00e9. Voici ce qu'elle fait en termes simples :\n\n1. **V\u00e9rification des conditions** : Elle v\u00e9rifie d'abord si certaines conditions sont remplies, comme l'existence d'un document (`self.doc`), si la validation approfondie est activ\u00e9e (`self.doc.deepvalidation`), si l'\u00e9l\u00e9ment parent a un ensemble d\u00e9fini (`self.parent.set`), et si cet ensemble ne commence pas par un soulign\u00e9 (`'_'`).\n\n2. **Test de sous-classe** : Si les conditions sont remplies, elle essaie de tester si la classe de l'\u00e9l\u00e9ment parent (`self.parent.cls`) est une sous-classe valide selon les d\u00e9finitions de l'ensemble (`self.doc.setdefinitions[self.parent.set]`).\n\n3. **Gestion des erreurs** :\n   - Si la d\u00e9finition de l'ensemble n'est pas trouv\u00e9e (`KeyError`), elle v\u00e9rifie si une classe est d\u00e9finie et si les ensembles ad hoc ne sont pas autoris\u00e9s. Si c'est le cas, elle l\u00e8ve une erreur (`DeepValidationError`) indiquant que la d\u00e9finition de l'ensemble n'a pas \u00e9t\u00e9 charg\u00e9e.\n   - Si une erreur de validation approfondie (`DeepValidationError`) se produit pendant le test, elle construit un message d'erreur d\u00e9taill\u00e9 en incluant le contexte (ensemble, balise XML, ID si disponible) et l\u00e8ve une nouvelle erreur avec ce message.\n\nEn r\u00e9sum\u00e9, cette fonction s'assure que l'\u00e9l\u00e9ment et ses propri\u00e9t\u00e9s respectent des r\u00e8gles sp\u00e9cifiques, et elle g\u00e8re les erreurs de mani\u00e8re informative si quelque chose ne va pas."
  },
  {
    "code": "def xml(self, attribs = None,elements = None, skipchildren = False):\n        \"\"\"See :meth:`AbstractElement.xml`\"\"\"\n        if not attribs: attribs = {}\n        E = ElementMaker(namespace=\"http://ilk.uvt.nl/folia\",nsmap={None: \"http://ilk.uvt.nl/folia\", 'xml' : \"http://www.w3.org/XML/1998/namespace\"})\n        e = super(AbstractSpanAnnotation,self).xml(attribs, elements, True)\n        for child in self:\n            if isinstance(child, (Word, Morpheme, Phoneme)):\n                #Include REFERENCES to word items instead of word items themselves\n                attribs['{' + NSFOLIA + '}id'] = child.id\n                if child.PRINTABLE and child.hastext(self.textclass):\n                    attribs['{' + NSFOLIA + '}t'] = child.text(self.textclass)\n                e.append( E.wref(**attribs) )\n            elif not (isinstance(child, Feature) and child.SUBSET): #Don't add pre-defined features, they are already added as attributes\n                e.append( child.xml() )\n        return e",
    "docstring": "See :meth:`AbstractElement.xml`",
    "summary": "Cette fonction, nomm\u00e9e `xml`, est une m\u00e9thode d'une classe appel\u00e9e `AbstractSpanAnnotation`. Elle est utilis\u00e9e pour g\u00e9n\u00e9rer une repr\u00e9sentation XML d'un \u00e9l\u00e9ment annot\u00e9, en tenant compte de ses attributs et de ses enfants. Voici une explication d\u00e9taill\u00e9e en fran\u00e7ais :\n\n1. **Param\u00e8tres** :\n   - `attribs` : Un dictionnaire d'attributs optionnel pour l'\u00e9l\u00e9ment XML. S'il n'est pas fourni, un dictionnaire vide est utilis\u00e9.\n   - `elements` : Un param\u00e8tre optionnel qui n'est pas utilis\u00e9 dans cette impl\u00e9mentation.\n   - `skipchildren` : Un bool\u00e9en indiquant si les enfants de l'\u00e9l\u00e9ment doivent \u00eatre ignor\u00e9s. Dans cette fonction, il est toujours d\u00e9fini sur `True` lors de l'appel \u00e0 la m\u00e9thode parente.\n\n2. **Cr\u00e9ation de l'\u00e9l\u00e9ment XML** :\n   - La fonction utilise `ElementMaker` pour cr\u00e9er des \u00e9l\u00e9ments XML avec un espace de noms sp\u00e9cifique (`http://ilk.uvt.nl/folia`).\n   - Elle appelle la m\u00e9thode `xml` de la classe parente (`super`) pour obtenir l'\u00e9l\u00e9ment XML de base.\n\n3. **Traitement des enfants** :\n   - Pour chaque enfant de l'\u00e9l\u00e9ment actuel (`self`), la fonction v\u00e9rifie son type :\n     - Si l'enfant est une instance de `Word`, `Morpheme` ou `Phoneme`, elle cr\u00e9e une r\u00e9f\u00e9rence (`wref`) \u00e0 cet \u00e9l\u00e9ment au lieu de l'inclure directement. Elle ajoute des attributs sp\u00e9cifiques (`id` et `t` si disponible) \u00e0 cette r\u00e9f\u00e9rence.\n     - Si l'enfant n'est pas une instance de `Feature` ou si c'est une instance de `Feature` mais pas un sous-ensemble pr\u00e9d\u00e9fini, elle ajoute l'enfant \u00e0 l'\u00e9l\u00e9ment XML en appelant sa propre m\u00e9thode `xml`.\n\n4. **Retour** :\n   - La fonction retourne l'\u00e9l\u00e9ment XML complet, incluant les attributs et les enfants trait\u00e9s.\n\nEn r\u00e9sum\u00e9, cette fonction g\u00e9n\u00e8re une repr\u00e9sentation XML structur\u00e9e d'une annotation, en g\u00e9rant sp\u00e9cifiquement les r\u00e9f\u00e9rences aux mots et en excluant certaines fonctionnalit\u00e9s pr\u00e9d\u00e9finies."
  },
  {
    "code": "def append(self, child, *args, **kwargs):\n        \"\"\"See :meth:`AbstractElement.append`\"\"\"\n        #Accept Word instances instead of WordReference, references will be automagically used upon serialisation\n        if isinstance(child, (Word, Morpheme, Phoneme)) and WordReference in self.ACCEPTED_DATA:\n            #We don't really append but do an insertion so all references are in proper order\n            insertionpoint = len(self.data)\n            for i, sibling in enumerate(self.data):\n                if isinstance(sibling, (Word, Morpheme, Phoneme)):\n                    try:\n                        if not sibling.precedes(child):\n                            insertionpoint = i\n                    except: #happens if we can't determine common ancestors\n                        pass\n\n            self.data.insert(insertionpoint, child)\n            return child\n        elif isinstance(child, AbstractSpanAnnotation): #(covers span roles just as well)\n            insertionpoint = len(self.data)\n            try:\n                firstword = child.wrefs(0)\n            except IndexError:\n                #we have no basis to determine an insertionpoint for this child, just append it then\n                return super(AbstractSpanAnnotation,self).append(child, *args, **kwargs)\n\n            insertionpoint = len(self.data)\n            for i, sibling in enumerate(self.data):\n                if isinstance(sibling, (Word, Morpheme, Phoneme)):\n                    try:\n                        if not sibling.precedes(firstword):\n                            insertionpoint = i\n                    except: #happens if we can't determine common ancestors\n                        pass\n            return super(AbstractSpanAnnotation,self).insert(insertionpoint, child, *args, **kwargs)\n        else:\n            return super(AbstractSpanAnnotation,self).append(child, *args, **kwargs)",
    "docstring": "See :meth:`AbstractElement.append`",
    "summary": "Cette fonction, `append`, est une m\u00e9thode qui permet d'ajouter un \u00e9l\u00e9ment (`child`) \u00e0 une structure de donn\u00e9es existante (`self`). Elle est con\u00e7ue pour g\u00e9rer diff\u00e9rents types d'\u00e9l\u00e9ments, comme des mots (`Word`), des morph\u00e8mes (`Morpheme`), des phon\u00e8mes (`Phoneme`), ou des annotations d'\u00e9tendue (`AbstractSpanAnnotation`).\n\nVoici ce qu'elle fait en d\u00e9tail :\n\n1. **V\u00e9rification du type de l'\u00e9l\u00e9ment \u00e0 ajouter (`child`)** :\n   - Si `child` est un mot, un morph\u00e8me ou un phon\u00e8me, et que la structure accepte ce type d'\u00e9l\u00e9ment (`WordReference in self.ACCEPTED_DATA`), la fonction d\u00e9termine l'endroit appropri\u00e9 pour ins\u00e9rer l'\u00e9l\u00e9ment afin de maintenir un ordre correct (par exemple, bas\u00e9 sur la position des mots).\n   - Si `child` est une annotation d'\u00e9tendue (`AbstractSpanAnnotation`), la fonction essaie de trouver le bon point d'insertion en se basant sur les r\u00e9f\u00e9rences de mots associ\u00e9es \u00e0 cette annotation.\n\n2. **Insertion ou ajout** :\n   - Pour les mots, morph\u00e8mes ou phon\u00e8mes, l'\u00e9l\u00e9ment est ins\u00e9r\u00e9 \u00e0 la position calcul\u00e9e (`insertionpoint`) pour maintenir l'ordre.\n   - Pour les annotations d'\u00e9tendue, si la position ne peut pas \u00eatre d\u00e9termin\u00e9e, l'\u00e9l\u00e9ment est simplement ajout\u00e9 \u00e0 la fin de la structure.\n\n3. **Gestion des erreurs** :\n   - Si la fonction ne peut pas d\u00e9terminer l'ordre correct (par exemple, en cas d'anc\u00eatres communs non identifiables), elle ignore l'erreur et ajoute l'\u00e9l\u00e9ment \u00e0 la fin.\n\nEn r\u00e9sum\u00e9, cette fonction ajoute intelligemment un \u00e9l\u00e9ment \u00e0 une structure de donn\u00e9es en tenant compte de son type et de sa position relative par rapport aux autres \u00e9l\u00e9ments existants."
  },
  {
    "code": "def setspan(self, *args):\n        \"\"\"Sets the span of the span element anew, erases all data inside.\n\n        Arguments:\n            *args: Instances of :class:`Word`, :class:`Morpheme` or :class:`Phoneme`\n        \"\"\"\n        self.data = []\n        for child in args:\n            self.append(child)",
    "docstring": "Sets the span of the span element anew, erases all data inside.\n\n        Arguments:\n            *args: Instances of :class:`Word`, :class:`Morpheme` or :class:`Phoneme`",
    "summary": "Cette fonction, `setspan`, permet de r\u00e9initialiser et de d\u00e9finir le contenu d'un \u00e9l\u00e9ment \"span\" (une sorte de conteneur pour des \u00e9l\u00e9ments linguistiques comme des mots, des morph\u00e8mes ou des phon\u00e8mes). Voici ce qu'elle fait en d\u00e9tail :\n\n1. **Effacement des donn\u00e9es existantes** : Elle commence par vider compl\u00e8tement le contenu actuel de l'\u00e9l\u00e9ment `span` en r\u00e9initialisant la liste `self.data` \u00e0 une liste vide (`[]`).\n\n2. **Ajout de nouveaux \u00e9l\u00e9ments** : Ensuite, elle prend tous les arguments pass\u00e9s \u00e0 la fonction (`*args`), qui peuvent \u00eatre des instances de `Word` (mot), `Morpheme` (morph\u00e8me) ou `Phoneme` (phon\u00e8me), et les ajoute un par un \u00e0 l'\u00e9l\u00e9ment `span` en utilisant la m\u00e9thode `append`.\n\nEn r\u00e9sum\u00e9, cette fonction permet de remplacer tout le contenu d'un \u00e9l\u00e9ment `span` par de nouveaux \u00e9l\u00e9ments linguistiques sp\u00e9cifi\u00e9s en arguments."
  },
  {
    "code": "def hasannotation(self,Class,set=None):\n        \"\"\"Returns an integer indicating whether such as annotation exists, and if so, how many. See ``annotations()`` for a description of the parameters.\"\"\"\n        return self.count(Class,set,True,default_ignore_annotations)",
    "docstring": "Returns an integer indicating whether such as annotation exists, and if so, how many. See ``annotations()`` for a description of the parameters.",
    "summary": "Cette fonction, `hasannotation`, v\u00e9rifie si une annotation sp\u00e9cifique existe pour une classe donn\u00e9e et, si c'est le cas, elle retourne le nombre d'annotations trouv\u00e9es. Voici une explication d\u00e9taill\u00e9e :\n\n1. **Param\u00e8tres** :\n   - `self` : C'est une r\u00e9f\u00e9rence \u00e0 l'instance de la classe dans laquelle cette m\u00e9thode est d\u00e9finie.\n   - `Class` : La classe pour laquelle on cherche l'annotation.\n   - `set` : Un ensemble optionnel qui peut \u00eatre utilis\u00e9 pour filtrer les annotations. Si aucun ensemble n'est fourni, toutes les annotations sont consid\u00e9r\u00e9es.\n\n2. **Fonctionnement** :\n   - La fonction utilise la m\u00e9thode `count` pour compter le nombre d'annotations de la classe `Class` qui correspondent aux crit\u00e8res sp\u00e9cifi\u00e9s.\n   - Le param\u00e8tre `True` indique que la fonction doit retourner un comptage.\n   - `default_ignore_annotations` est probablement une liste d'annotations \u00e0 ignorer par d\u00e9faut.\n\n3. **Retour** :\n   - La fonction retourne un entier qui repr\u00e9sente le nombre d'annotations trouv\u00e9es. Si aucune annotation n'est trouv\u00e9e, elle retourne 0.\n\nEn r\u00e9sum\u00e9, cette fonction permet de v\u00e9rifier l'existence et de compter les annotations d'une classe donn\u00e9e, en tenant compte d'\u00e9ventuels filtres ou ignorances par d\u00e9faut."
  },
  {
    "code": "def annotation(self, type, set=None):\n        \"\"\"Will return a **single** annotation (even if there are multiple). Raises a ``NoSuchAnnotation`` exception if none was found\"\"\"\n        l = list(self.select(type,set,True,default_ignore_annotations))\n        if len(l) >= 1:\n            return l[0]\n        else:\n            raise NoSuchAnnotation()",
    "docstring": "Will return a **single** annotation (even if there are multiple). Raises a ``NoSuchAnnotation`` exception if none was found",
    "summary": "Cette fonction, nomm\u00e9e `annotation`, est une m\u00e9thode d'une classe (car elle utilise `self` comme premier param\u00e8tre). Voici ce qu'elle fait en termes simples :\n\n1. **Objectif** : Elle permet de r\u00e9cup\u00e9rer une **seule** annotation sp\u00e9cifique, m\u00eame s'il en existe plusieurs correspondantes.  \n2. **Param\u00e8tres** :\n   - `type` : Le type d'annotation que l'on cherche.\n   - `set` : Un param\u00e8tre optionnel (par d\u00e9faut `None`) qui peut \u00eatre utilis\u00e9 pour filtrer les annotations.  \n3. **Fonctionnement** :\n   - Elle utilise une autre m\u00e9thode `select` pour r\u00e9cup\u00e9rer une liste d'annotations correspondant au `type` et au `set` sp\u00e9cifi\u00e9s.\n   - Si au moins une annotation est trouv\u00e9e (`len(l) >= 1`), elle retourne la **premi\u00e8re** annotation de la liste.\n   - Si aucune annotation n'est trouv\u00e9e, elle d\u00e9clenche une exception `NoSuchAnnotation` pour indiquer que l'annotation recherch\u00e9e n'existe pas.  \n\nEn r\u00e9sum\u00e9, cette fonction cherche une annotation sp\u00e9cifique et retourne la premi\u00e8re qu'elle trouve, ou signale une erreur si rien n'est trouv\u00e9."
  },
  {
    "code": "def _helper_wrefs(self, targets, recurse=True):\n        \"\"\"Internal helper function\"\"\"\n        for c in self:\n            if isinstance(c,Word) or isinstance(c,Morpheme) or isinstance(c, Phoneme):\n                targets.append(c)\n            elif isinstance(c,WordReference):\n                try:\n                    targets.append(self.doc[c.id]) #try to resolve\n                except KeyError:\n                    targets.append(c) #add unresolved\n            elif isinstance(c, AbstractSpanAnnotation) and recurse:\n                #recursion\n                c._helper_wrefs(targets) #pylint: disable=protected-access\n            elif isinstance(c, Correction) and c.auth: #recurse into corrections\n                for e in c:\n                    if isinstance(e, AbstractCorrectionChild) and e.auth:\n                        for e2 in e:\n                            if isinstance(e2, AbstractSpanAnnotation):\n                                #recursion\n                                e2._helper_wrefs(targets)",
    "docstring": "Internal helper function",
    "summary": "Cette fonction, `_helper_wrefs`, est une fonction interne qui parcourt une structure de donn\u00e9es (repr\u00e9sent\u00e9e par `self`) pour collecter des \u00e9l\u00e9ments sp\u00e9cifiques dans une liste appel\u00e9e `targets`. Voici ce qu'elle fait en d\u00e9tail :\n\n1. **Parcours des \u00e9l\u00e9ments** : Elle parcourt chaque \u00e9l\u00e9ment `c` contenu dans `self`.\n\n2. **Identification des \u00e9l\u00e9ments** :\n   - Si `c` est une instance de `Word`, `Morpheme` ou `Phoneme`, elle l'ajoute directement \u00e0 la liste `targets`.\n   - Si `c` est une instance de `WordReference`, elle essaie de r\u00e9soudre cette r\u00e9f\u00e9rence en utilisant `self.doc[c.id]`. Si la r\u00e9f\u00e9rence est r\u00e9solue, elle ajoute l'\u00e9l\u00e9ment r\u00e9solu \u00e0 `targets`. Sinon, elle ajoute la r\u00e9f\u00e9rence non r\u00e9solue.\n   - Si `c` est une instance de `AbstractSpanAnnotation` et que le param\u00e8tre `recurse` est `True`, elle appelle r\u00e9cursivement `_helper_wrefs` sur cet \u00e9l\u00e9ment pour collecter davantage d'\u00e9l\u00e9ments.\n   - Si `c` est une instance de `Correction` et qu'elle a une autorisation (`c.auth`), elle parcourt les \u00e9l\u00e9ments enfants de cette correction. Si un enfant est une instance de `AbstractCorrectionChild` et a \u00e9galement une autorisation, elle parcourt ses sous-\u00e9l\u00e9ments. Si un sous-\u00e9l\u00e9ment est une instance de `AbstractSpanAnnotation`, elle appelle r\u00e9cursivement `_helper_wrefs` sur ce sous-\u00e9l\u00e9ment.\n\n3. **R\u00e9sultat** : \u00c0 la fin, la liste `targets` contient tous les \u00e9l\u00e9ments collect\u00e9s selon les r\u00e8gles ci-dessus.\n\nEn r\u00e9sum\u00e9, cette fonction collecte des \u00e9l\u00e9ments sp\u00e9cifiques (mots, morph\u00e8mes, phon\u00e8mes, r\u00e9f\u00e9rences r\u00e9solues, etc.) \u00e0 partir d'une structure de donn\u00e9es complexe, en utilisant la r\u00e9cursion pour explorer les annotations et corrections imbriqu\u00e9es."
  },
  {
    "code": "def wrefs(self, index = None, recurse=True):\n        \"\"\"Returns a list of word references, these can be Words but also Morphemes or Phonemes.\n\n        Arguments:\n            index (int or None): If set to an integer, will retrieve and return the n'th element (starting at 0) instead of returning the list of all\n        \"\"\"\n        targets =[]\n        self._helper_wrefs(targets, recurse)\n        if index is None:\n            return targets\n        else:\n            return targets[index]",
    "docstring": "Returns a list of word references, these can be Words but also Morphemes or Phonemes.\n\n        Arguments:\n            index (int or None): If set to an integer, will retrieve and return the n'th element (starting at 0) instead of returning the list of all",
    "summary": "Cette fonction, nomm\u00e9e `wrefs`, permet de r\u00e9cup\u00e9rer une liste de r\u00e9f\u00e9rences de mots (qui peuvent \u00eatre des mots entiers, des morph\u00e8mes ou des phon\u00e8mes) \u00e0 partir d'un objet donn\u00e9. Voici une explication d\u00e9taill\u00e9e en fran\u00e7ais :\n\n1. **Param\u00e8tres** :\n   - `index` (optionnel, par d\u00e9faut `None`) : Si un entier est fourni, la fonction retournera uniquement l'\u00e9l\u00e9ment \u00e0 la position sp\u00e9cifi\u00e9e (en commen\u00e7ant \u00e0 0) dans la liste des r\u00e9f\u00e9rences. Si `None`, elle retourne toute la liste.\n   - `recurse` (optionnel, par d\u00e9faut `True`) : Indique si la recherche doit \u00eatre effectu\u00e9e de mani\u00e8re r\u00e9cursive (par exemple, pour explorer des structures imbriqu\u00e9es).\n\n2. **Fonctionnement** :\n   - La fonction initialise une liste vide appel\u00e9e `targets` pour stocker les r\u00e9f\u00e9rences de mots.\n   - Elle appelle une m\u00e9thode auxiliaire `_helper_wrefs` pour remplir cette liste, en tenant compte du param\u00e8tre `recurse`.\n   - Si `index` est `None`, la fonction retourne toute la liste `targets`.\n   - Sinon, elle retourne uniquement l'\u00e9l\u00e9ment \u00e0 la position sp\u00e9cifi\u00e9e par `index` dans la liste `targets`.\n\n3. **Exemple** :\n   - Si `index = 2`, la fonction retournera le troisi\u00e8me \u00e9l\u00e9ment de la liste `targets` (car les indices commencent \u00e0 0).\n\nEn r\u00e9sum\u00e9, cette fonction permet de r\u00e9cup\u00e9rer soit une liste compl\u00e8te de r\u00e9f\u00e9rences de mots, soit un \u00e9l\u00e9ment sp\u00e9cifique de cette liste, en fonction des param\u00e8tres fournis."
  },
  {
    "code": "def addtoindex(self,norecurse=None):\n        \"\"\"Makes sure this element (and all subelements), are properly added to the index\"\"\"\n        if not norecurse: norecurse = (Word, Morpheme, Phoneme)\n        if self.id:\n            self.doc.index[self.id] = self\n        for e in self.data:\n            if all([not isinstance(e, C) for C in norecurse]):\n                try:\n                    e.addtoindex(norecurse)\n                except AttributeError:\n                    pass",
    "docstring": "Makes sure this element (and all subelements), are properly added to the index",
    "summary": "Cette fonction, `addtoindex`, s'assure qu'un \u00e9l\u00e9ment et tous ses sous-\u00e9l\u00e9ments sont correctement ajout\u00e9s \u00e0 un index. Voici une explication \u00e9tape par \u00e9tape en fran\u00e7ais :\n\n1. **Param\u00e8tre `norecurse`**: Ce param\u00e8tre permet de sp\u00e9cifier des types d'\u00e9l\u00e9ments pour lesquels la fonction ne doit pas \u00eatre appel\u00e9e r\u00e9cursivement. Par d\u00e9faut, si `norecurse` n'est pas fourni, il est initialis\u00e9 avec les classes `Word`, `Morpheme`, et `Phoneme`.\n\n2. **V\u00e9rification de l'ID**: Si l'\u00e9l\u00e9ment actuel (`self`) poss\u00e8de un identifiant (`id`), il est ajout\u00e9 \u00e0 l'index du document (`self.doc.index`) avec son ID comme cl\u00e9.\n\n3. **Parcours des sous-\u00e9l\u00e9ments**: La fonction parcourt ensuite tous les sous-\u00e9l\u00e9ments (`e`) contenus dans `self.data`.\n\n4. **V\u00e9rification du type de sous-\u00e9l\u00e9ment**: Pour chaque sous-\u00e9l\u00e9ment, la fonction v\u00e9rifie s'il ne fait pas partie des types sp\u00e9cifi\u00e9s dans `norecurse`. Si ce n'est pas le cas, elle tente d'appeler r\u00e9cursivement la m\u00e9thode `addtoindex` sur ce sous-\u00e9l\u00e9ment.\n\n5. **Gestion des erreurs**: Si un sous-\u00e9l\u00e9ment ne poss\u00e8de pas la m\u00e9thode `addtoindex` (ce qui provoquerait une `AttributeError`), l'erreur est ignor\u00e9e gr\u00e2ce \u00e0 la structure `try-except`.\n\nEn r\u00e9sum\u00e9, cette fonction assure que tous les \u00e9l\u00e9ments et leurs sous-\u00e9l\u00e9ments (sauf ceux sp\u00e9cifi\u00e9s dans `norecurse`) sont correctement index\u00e9s dans le document."
  },
  {
    "code": "def copychildren(self, newdoc=None, idsuffix=\"\"):\n        \"\"\"Generator creating a deep copy of the children of this element. If idsuffix is a string, if set to True, a random idsuffix will be generated including a random 32-bit hash\"\"\"\n        if idsuffix is True: idsuffix = \".copy.\" + \"%08x\" % random.getrandbits(32) #random 32-bit hash for each copy, same one will be reused for all children\n        for c in self:\n            if isinstance(c, Word):\n                yield WordReference(newdoc, id=c.id)\n            else:\n                yield c.copy(newdoc,idsuffix)",
    "docstring": "Generator creating a deep copy of the children of this element. If idsuffix is a string, if set to True, a random idsuffix will be generated including a random 32-bit hash",
    "summary": "Voici une explication simple en fran\u00e7ais de ce que fait cette fonction :\n\nLa fonction `copychildren` est un g\u00e9n\u00e9rateur qui cr\u00e9e une **copie profonde** (deep copy) des enfants d'un \u00e9l\u00e9ment donn\u00e9. Voici ce qu'elle fait en d\u00e9tail :\n\n1. **Gestion du suffixe d'ID (`idsuffix`)** :\n   - Si `idsuffix` est d\u00e9fini sur `True`, un suffixe d'ID al\u00e9atoire est g\u00e9n\u00e9r\u00e9. Ce suffixe inclut un hachage al\u00e9atoire de 32 bits pour garantir l'unicit\u00e9.\n   - Ce suffixe sera utilis\u00e9 pour modifier les ID des \u00e9l\u00e9ments copi\u00e9s.\n\n2. **Parcours des enfants** :\n   - La fonction parcourt chaque enfant (`c`) de l'\u00e9l\u00e9ment actuel (`self`).\n\n3. **Copie des enfants** :\n   - Si l'enfant est une instance de `Word`, elle cr\u00e9e une r\u00e9f\u00e9rence (`WordReference`) \u00e0 cet \u00e9l\u00e9ment dans le nouveau document (`newdoc`), en conservant son ID d'origine.\n   - Pour les autres types d'enfants, elle utilise la m\u00e9thode `copy` de l'enfant pour cr\u00e9er une copie profonde, en appliquant le suffixe d'ID si n\u00e9cessaire.\n\n4. **R\u00e9sultat** :\n   - La fonction retourne chaque copie d'enfant une par une, gr\u00e2ce au m\u00e9canisme de g\u00e9n\u00e9rateur (`yield`).\n\nEn r\u00e9sum\u00e9, cette fonction permet de dupliquer les enfants d'un \u00e9l\u00e9ment tout en g\u00e9rant les ID de mani\u00e8re unique si n\u00e9cessaire, et en adaptant la copie selon le type d'enfant."
  },
  {
    "code": "def xml(self, attribs = None,elements = None, skipchildren = False):\n        \"\"\"See :meth:`AbstractElement.xml`\"\"\"\n        if self.set is False or self.set is None:\n            if len(self.data) == 0: #just skip if there are no children\n                return None\n            else:\n                raise ValueError(\"No set specified or derivable for annotation layer \" + self.__class__.__name__)\n        return super(AbstractAnnotationLayer, self).xml(attribs, elements, skipchildren)",
    "docstring": "See :meth:`AbstractElement.xml`",
    "summary": "Cette fonction, nomm\u00e9e `xml`, est une m\u00e9thode d'une classe appel\u00e9e `AbstractAnnotationLayer`. Elle est utilis\u00e9e pour g\u00e9n\u00e9rer une repr\u00e9sentation XML d'un \u00e9l\u00e9ment d'annotation. Voici ce qu'elle fait en termes simples :\n\n1. **V\u00e9rification des conditions** :  \n   - Elle v\u00e9rifie d'abord si l'attribut `set` de l'objet est `False` ou `None`. Si c'est le cas, elle v\u00e9rifie \u00e9galement si l'objet contient des donn\u00e9es (`self.data`).  \n   - Si l'objet n'a pas de donn\u00e9es, la fonction retourne `None` (elle ne fait rien).  \n   - Si l'objet a des donn\u00e9es mais que `set` n'est pas d\u00e9fini correctement, elle l\u00e8ve une erreur (`ValueError`) en indiquant qu'il manque une information n\u00e9cessaire pour l'annotation.\n\n2. **G\u00e9n\u00e9ration du XML** :  \n   - Si les conditions pr\u00e9c\u00e9dentes sont satisfaites (c'est-\u00e0-dire si `set` est correctement d\u00e9fini), la fonction appelle la m\u00e9thode `xml` de la classe parente (`super`) pour g\u00e9n\u00e9rer la repr\u00e9sentation XML de l'\u00e9l\u00e9ment.  \n   - Elle prend en compte les param\u00e8tres `attribs` (attributs XML), `elements` (\u00e9l\u00e9ments enfants), et `skipchildren` (pour ignorer ou non les enfants).\n\nEn r\u00e9sum\u00e9, cette fonction g\u00e9n\u00e8re un XML pour un \u00e9l\u00e9ment d'annotation, mais seulement si les conditions n\u00e9cessaires sont remplies. Si ce n'est pas le cas, elle soit retourne `None`, soit l\u00e8ve une erreur."
  },
  {
    "code": "def append(self, child, *args, **kwargs):\n        \"\"\"See :meth:`AbstractElement.append`\"\"\"\n        #if no set is associated with the layer yet, we learn it from span annotation elements that are added\n        if self.set is False or self.set is None:\n            if inspect.isclass(child):\n                if issubclass(child,AbstractSpanAnnotation):\n                    if 'set' in kwargs:\n                        self.set = kwargs['set']\n            elif isinstance(child, AbstractSpanAnnotation):\n                if child.set:\n                    self.set = child.set\n            elif isinstance(child, Correction):\n                #descend into corrections to find the proper set for this layer (derived from span annotation elements)\n                for e in itertools.chain( child.new(), child.original(), child.suggestions() ):\n                    if isinstance(e, AbstractSpanAnnotation) and e.set:\n                        self.set = e.set\n                        break\n\n        return super(AbstractAnnotationLayer, self).append(child, *args, **kwargs)",
    "docstring": "See :meth:`AbstractElement.append`",
    "summary": "Cette fonction, `append`, est une m\u00e9thode qui permet d'ajouter un \u00e9l\u00e9ment (`child`) \u00e0 une couche d'annotation (`AbstractAnnotationLayer`). Voici ce qu'elle fait en termes simples :\n\n1. **V\u00e9rification de l'ensemble associ\u00e9** :  \n   Si la couche n'a pas encore d'ensemble (`set`) associ\u00e9 (c'est-\u00e0-dire si `self.set` est `False` ou `None`), la fonction essaie de d\u00e9terminer quel ensemble utiliser en fonction de l'\u00e9l\u00e9ment ajout\u00e9 (`child`).\n\n2. **Analyse de l'\u00e9l\u00e9ment ajout\u00e9** :  \n   - Si `child` est une classe ou une instance d'annotation d'intervalle (`AbstractSpanAnnotation`), la fonction v\u00e9rifie si un ensemble est sp\u00e9cifi\u00e9 dans les arguments (`kwargs`) ou si l'\u00e9l\u00e9ment lui-m\u00eame a un ensemble associ\u00e9. Si c'est le cas, elle associe cet ensemble \u00e0 la couche.  \n   - Si `child` est une correction (`Correction`), la fonction explore les \u00e9l\u00e9ments contenus dans la correction (nouveaux, originaux ou suggestions) pour trouver une annotation d'intervalle avec un ensemble associ\u00e9, et l'utilise pour la couche.\n\n3. **Ajout de l'\u00e9l\u00e9ment** :  \n   Une fois que l'ensemble est d\u00e9termin\u00e9 (si n\u00e9cessaire), la fonction appelle la m\u00e9thode `append` de la classe parente (`AbstractElement`) pour ajouter effectivement l'\u00e9l\u00e9ment \u00e0 la couche.\n\nEn r\u00e9sum\u00e9, cette fonction ajoute un \u00e9l\u00e9ment \u00e0 une couche d'annotation tout en s'assurant que la couche est associ\u00e9e au bon ensemble d'annotations, si ce n'est pas d\u00e9j\u00e0 fait."
  },
  {
    "code": "def alternatives(self, Class=None, set=None):\n        \"\"\"Generator over alternatives, either all or only of a specific annotation type, and possibly restrained also by set.\n\n        Arguments:\n            * ``Class`` - The Class you want to retrieve (e.g. PosAnnotation). Or set to None to select all alternatives regardless of what type they are.\n            * ``set``   - The set you want to retrieve (defaults to None, which selects irregardless of set)\n\n        Returns:\n            Generator over Alternative elements\n        \"\"\"\n\n        for e in self.select(AlternativeLayers,None, True, ['Original','Suggestion']): #pylint: disable=too-many-nested-blocks\n            if Class is None:\n                yield e\n            elif len(e) >= 1: #child elements?\n                for e2 in e:\n                    try:\n                        if isinstance(e2, Class):\n                            try:\n                                if set is None or e2.set == set:\n                                    yield e #not e2\n                                    break #yield an alternative only once (in case there are multiple matches)\n                            except AttributeError:\n                                continue\n                    except AttributeError:\n                        continue",
    "docstring": "Generator over alternatives, either all or only of a specific annotation type, and possibly restrained also by set.\n\n        Arguments:\n            * ``Class`` - The Class you want to retrieve (e.g. PosAnnotation). Or set to None to select all alternatives regardless of what type they are.\n            * ``set``   - The set you want to retrieve (defaults to None, which selects irregardless of set)\n\n        Returns:\n            Generator over Alternative elements",
    "summary": "Cette fonction, nomm\u00e9e `alternatives`, est un g\u00e9n\u00e9rateur qui parcourt et retourne des \u00e9l\u00e9ments de type `Alternative` en fonction de certains crit\u00e8res. Voici une explication simple en fran\u00e7ais :\n\n1. **Objectif** : La fonction permet de r\u00e9cup\u00e9rer des alternatives, soit toutes les alternatives disponibles, soit uniquement celles d'un type sp\u00e9cifique d'annotation (`Class`), et \u00e9ventuellement limit\u00e9es \u00e0 un ensemble particulier (`set`).\n\n2. **Param\u00e8tres** :\n   - `Class` : Le type d'annotation que vous souhaitez r\u00e9cup\u00e9rer (par exemple, `PosAnnotation`). Si `None`, toutes les alternatives sont retourn\u00e9es, quel que soit leur type.\n   - `set` : L'ensemble sp\u00e9cifique d'alternatives que vous voulez r\u00e9cup\u00e9rer. Par d\u00e9faut, c'est `None`, ce qui signifie que toutes les alternatives sont consid\u00e9r\u00e9es, ind\u00e9pendamment de leur ensemble.\n\n3. **Fonctionnement** :\n   - La fonction parcourt tous les \u00e9l\u00e9ments de type `AlternativeLayers`.\n   - Si `Class` est `None`, elle retourne chaque \u00e9l\u00e9ment `e` directement.\n   - Sinon, elle v\u00e9rifie si l'\u00e9l\u00e9ment `e` contient des \u00e9l\u00e9ments enfants (`e2`).\n   - Pour chaque enfant `e2`, elle v\u00e9rifie si `e2` est une instance de la classe sp\u00e9cifi\u00e9e (`Class`).\n   - Si c'est le cas, elle v\u00e9rifie \u00e9galement si l'ensemble de `e2` correspond \u00e0 celui sp\u00e9cifi\u00e9 (`set`), ou si `set` est `None`.\n   - Si toutes les conditions sont remplies, elle retourne l'\u00e9l\u00e9ment `e` (et non `e2`) et passe \u00e0 l'alternative suivante pour \u00e9viter les doublons.\n\n4. **Retour** : La fonction retourne un g\u00e9n\u00e9rateur qui produit des \u00e9l\u00e9ments `Alternative` un par un, en fonction des crit\u00e8res sp\u00e9cifi\u00e9s.\n\nEn r\u00e9sum\u00e9, cette fonction permet de filtrer et de r\u00e9cup\u00e9rer des alternatives en fonction de leur type d'annotation et de leur ensemble, de mani\u00e8re efficace et sans doublons."
  },
  {
    "code": "def findspan(self, *words):\n        \"\"\"Returns the span element which spans over the specified words or morphemes.\n\n        See also:\n            :meth:`Word.findspans`\n        \"\"\"\n\n        for span in self.select(AbstractSpanAnnotation,None,True):\n            if tuple(span.wrefs()) == words:\n                return span\n        raise NoSuchAnnotation",
    "docstring": "Returns the span element which spans over the specified words or morphemes.\n\n        See also:\n            :meth:`Word.findspans`",
    "summary": "Cette fonction, `findspan`, recherche un \u00e9l\u00e9ment d'annotation (appel\u00e9 \"span\") qui couvre exactement les mots ou morph\u00e8mes sp\u00e9cifi\u00e9s en entr\u00e9e. Voici comment elle fonctionne en termes simples :\n\n1. **Entr\u00e9e** : Elle prend une liste de mots ou morph\u00e8mes (pass\u00e9s sous forme d'arguments variables `*words`).\n2. **Recherche** : Elle parcourt toutes les annotations de type \"span\" disponibles dans l'objet courant (`self`).\n3. **V\u00e9rification** : Pour chaque annotation \"span\", elle v\u00e9rifie si les mots ou morph\u00e8mes qu'elle couvre correspondent exactement \u00e0 ceux fournis en entr\u00e9e.\n4. **Retour** : Si elle trouve une annotation \"span\" qui correspond, elle la retourne.\n5. **Erreur** : Si aucune annotation correspondante n'est trouv\u00e9e, elle l\u00e8ve une exception (`NoSuchAnnotation`) pour indiquer que l'annotation recherch\u00e9e n'existe pas.\n\nEn r\u00e9sum\u00e9, cette fonction permet de retrouver une annotation sp\u00e9cifique qui couvre une s\u00e9quence exacte de mots ou morph\u00e8mes."
  },
  {
    "code": "def relaxng(cls, includechildren=True,extraattribs = None, extraelements=None, origclass = None):\n        \"\"\"Returns a RelaxNG definition for this element (as an XML element (lxml.etree) rather than a string)\"\"\"\n        E = ElementMaker(namespace=\"http://relaxng.org/ns/structure/1.0\",nsmap={None:'http://relaxng.org/ns/structure/1.0' , 'folia': \"http://ilk.uvt.nl/folia\", 'xml' : \"http://www.w3.org/XML/1998/namespace\",'a':\"http://relaxng.org/ns/annotation/0.9\" })\n        if not extraattribs:\n            extraattribs = []\n        extraattribs.append(E.optional(E.attribute(E.text(), name='set')) )\n        return AbstractElement.relaxng(includechildren, extraattribs, extraelements, cls)",
    "docstring": "Returns a RelaxNG definition for this element (as an XML element (lxml.etree) rather than a string)",
    "summary": "Cette fonction, nomm\u00e9e `relaxng`, g\u00e9n\u00e8re une d\u00e9finition **RelaxNG** (un langage de sch\u00e9ma XML) pour un \u00e9l\u00e9ment donn\u00e9. Voici une explication simplifi\u00e9e en fran\u00e7ais :\n\n1. **Objectif** : La fonction cr\u00e9e une d\u00e9finition RelaxNG sous forme d'un \u00e9l\u00e9ment XML (utilisant la biblioth\u00e8que `lxml.etree`), et non sous forme de cha\u00eene de caract\u00e8res.\n\n2. **Param\u00e8tres** :\n   - `cls` : La classe de l'\u00e9l\u00e9ment pour lequel la d\u00e9finition RelaxNG est g\u00e9n\u00e9r\u00e9e.\n   - `includechildren` : Indique si les enfants de l'\u00e9l\u00e9ment doivent \u00eatre inclus dans la d\u00e9finition (par d\u00e9faut, `True`).\n   - `extraattribs` : Une liste d'attributs suppl\u00e9mentaires \u00e0 inclure dans la d\u00e9finition.\n   - `extraelements` : Des \u00e9l\u00e9ments suppl\u00e9mentaires \u00e0 inclure dans la d\u00e9finition.\n   - `origclass` : La classe originale (utilis\u00e9e pour des cas sp\u00e9cifiques).\n\n3. **Fonctionnement** :\n   - Elle utilise `ElementMaker` pour cr\u00e9er des \u00e9l\u00e9ments XML dans l'espace de noms RelaxNG.\n   - Si `extraattribs` n'est pas fourni, elle initialise une liste vide.\n   - Elle ajoute un attribut optionnel `set` \u00e0 la liste `extraattribs`.\n   - Enfin, elle appelle la m\u00e9thode `relaxng` de la classe `AbstractElement` pour g\u00e9n\u00e9rer la d\u00e9finition RelaxNG en utilisant les param\u00e8tres fournis.\n\n4. **R\u00e9sultat** : La fonction retourne un \u00e9l\u00e9ment XML repr\u00e9sentant la d\u00e9finition RelaxNG pour l'\u00e9l\u00e9ment sp\u00e9cifi\u00e9.\n\nEn r\u00e9sum\u00e9, cette fonction automatise la cr\u00e9ation d'un sch\u00e9ma RelaxNG pour un \u00e9l\u00e9ment XML, en tenant compte de ses attributs, enfants et \u00e9l\u00e9ments suppl\u00e9mentaires si n\u00e9cessaire."
  },
  {
    "code": "def hasnew(self,allowempty=False):\n        \"\"\"Does the correction define new corrected annotations?\"\"\"\n        for e in  self.select(New,None,False, False):\n            if not allowempty and len(e) == 0: continue\n            return True\n        return False",
    "docstring": "Does the correction define new corrected annotations?",
    "summary": "Cette fonction, nomm\u00e9e `hasnew`, v\u00e9rifie si une correction d\u00e9finit de nouvelles annotations corrig\u00e9es. Voici comment elle fonctionne en termes simples :\n\n1. **Objectif** : La fonction d\u00e9termine s'il y a de nouvelles annotations corrig\u00e9es dans un ensemble donn\u00e9.\n  \n2. **Param\u00e8tre** :\n   - `allowempty=False` : Un param\u00e8tre optionnel qui indique si les annotations vides doivent \u00eatre prises en compte. Par d\u00e9faut, les annotations vides sont ignor\u00e9es.\n\n3. **Fonctionnement** :\n   - Elle parcourt une liste d'\u00e9l\u00e9ments (probablement des annotations) en utilisant `self.select(New, None, False, False)`.\n   - Pour chaque \u00e9l\u00e9ment (`e`) :\n     - Si `allowempty` est `False` et que l'\u00e9l\u00e9ment est vide (`len(e) == 0`), elle passe \u00e0 l'\u00e9l\u00e9ment suivant.\n     - Sinon, si elle trouve un \u00e9l\u00e9ment non vide, elle retourne imm\u00e9diatement `True`, indiquant qu'il y a au moins une nouvelle annotation corrig\u00e9e.\n   - Si elle parcourt tous les \u00e9l\u00e9ments sans trouver d'annotation non vide, elle retourne `False`, signifiant qu'il n'y a pas de nouvelles annotations corrig\u00e9es.\n\nEn r\u00e9sum\u00e9, cette fonction r\u00e9pond \u00e0 la question : *\"Y a-t-il de nouvelles annotations corrig\u00e9es, en ignorant \u00e9ventuellement les annotations vides ?\"*"
  },
  {
    "code": "def hasoriginal(self,allowempty=False):\n        \"\"\"Does the correction record the old annotations prior to correction?\"\"\"\n        for e in self.select(Original,None,False, False):\n            if not allowempty and len(e) == 0: continue\n            return True\n        return False",
    "docstring": "Does the correction record the old annotations prior to correction?",
    "summary": "Cette fonction, nomm\u00e9e `hasoriginal`, v\u00e9rifie si un enregistrement de correction contient des annotations originales (c'est-\u00e0-dire les annotations qui existaient avant la correction). Voici comment elle fonctionne en termes simples :\n\n1. **Param\u00e8tre `allowempty`**: Ce param\u00e8tre indique si les annotations vides sont autoris\u00e9es. Si `allowempty` est `False`, les annotations vides seront ignor\u00e9es.\n\n2. **Boucle sur les annotations originales**: La fonction parcourt toutes les annotations originales associ\u00e9es \u00e0 l'objet `self` (probablement un objet repr\u00e9sentant un enregistrement de correction).\n\n3. **V\u00e9rification des annotations vides**: Si `allowempty` est `False` et qu'une annotation est vide (c'est-\u00e0-dire que sa longueur est 0), la fonction passe \u00e0 l'annotation suivante.\n\n4. **Retour de la valeur**: Si la fonction trouve au moins une annotation originale non vide, elle retourne `True`. Si elle ne trouve aucune annotation originale non vide apr\u00e8s avoir parcouru toutes les annotations, elle retourne `False`.\n\nEn r\u00e9sum\u00e9, cette fonction r\u00e9pond \u00e0 la question : **\"L'enregistrement de correction contient-il des annotations originales (non vides, si `allowempty` est `False`) ?\"**"
  },
  {
    "code": "def hascurrent(self, allowempty=False):\n        \"\"\"Does the correction record the current authoritative annotation (needed only in a structural context when suggestions are proposed)\"\"\"\n        for e in self.select(Current,None,False, False):\n            if not allowempty and len(e) == 0: continue\n            return True\n        return False",
    "docstring": "Does the correction record the current authoritative annotation (needed only in a structural context when suggestions are proposed)",
    "summary": "Cette fonction, `hascurrent`, v\u00e9rifie si un enregistrement de correction contient l'annotation actuelle et autoritaire (ce qui est n\u00e9cessaire uniquement dans un contexte structurel lorsque des suggestions sont propos\u00e9es). Voici comment elle fonctionne en termes simples :\n\n1. **Parcours des \u00e9l\u00e9ments** : La fonction parcourt tous les \u00e9l\u00e9ments s\u00e9lectionn\u00e9s par `self.select(Current, None, False, False)`. Ces \u00e9l\u00e9ments repr\u00e9sentent probablement des annotations ou des donn\u00e9es sp\u00e9cifiques.\n  \n2. **V\u00e9rification de la pr\u00e9sence d'annotations** :\n   - Si `allowempty` est `False` (c'est-\u00e0-dire que les annotations vides ne sont pas autoris\u00e9es), la fonction ignore les \u00e9l\u00e9ments vides (c'est-\u00e0-dire ceux dont la longueur est 0).\n   - Si un \u00e9l\u00e9ment non vide est trouv\u00e9, la fonction retourne `True`, indiquant qu'il y a au moins une annotation actuelle.\n\n3. **R\u00e9sultat final** : Si aucun \u00e9l\u00e9ment non vide n'est trouv\u00e9 apr\u00e8s avoir parcouru tous les \u00e9l\u00e9ments, la fonction retourne `False`, indiquant qu'il n'y a pas d'annotation actuelle.\n\nEn r\u00e9sum\u00e9, cette fonction r\u00e9pond \u00e0 la question : **\"Y a-t-il une annotation actuelle et non vide dans l'enregistrement de correction ?\"**"
  },
  {
    "code": "def hassuggestions(self,allowempty=False):\n        \"\"\"Does the correction propose suggestions for correction?\"\"\"\n        for e in self.select(Suggestion,None,False, False):\n            if not allowempty and len(e) == 0: continue\n            return True\n        return False",
    "docstring": "Does the correction propose suggestions for correction?",
    "summary": "Cette fonction, `hassuggestions`, v\u00e9rifie si une correction propose des suggestions pour corriger un texte. Voici comment elle fonctionne en termes simples :\n\n1. **Param\u00e8tre `allowempty`**:  \n   - Si `allowempty` est `False` (par d\u00e9faut), la fonction ignore les suggestions vides (c'est-\u00e0-dire celles qui ne contiennent rien).  \n   - Si `allowempty` est `True`, elle prend en compte m\u00eame les suggestions vides.\n\n2. **Parcours des suggestions**:  \n   La fonction parcourt toutes les suggestions disponibles (via `self.select(Suggestion, None, False, False)`).\n\n3. **V\u00e9rification des suggestions**:  \n   - Si `allowempty` est `False`, elle saute les suggestions vides (celles dont la longueur est 0).  \n   - D\u00e8s qu'elle trouve une suggestion non vide, elle retourne `True`, indiquant qu'il y a au moins une suggestion valable.\n\n4. **R\u00e9sultat final**:  \n   - Si aucune suggestion n'est trouv\u00e9e (ou si toutes sont vides et `allowempty` est `False`), la fonction retourne `False`.\n\nEn r\u00e9sum\u00e9, cette fonction r\u00e9pond \u00e0 la question : **\"Y a-t-il des suggestions de correction propos\u00e9es ?\"** en tenant compte (ou non) des suggestions vides selon le param\u00e8tre `allowempty`."
  },
  {
    "code": "def textcontent(self, cls='current', correctionhandling=CorrectionHandling.CURRENT):\n        \"\"\"See :meth:`AbstractElement.textcontent`\"\"\"\n        if cls == 'original': correctionhandling = CorrectionHandling.ORIGINAL #backward compatibility\n        if correctionhandling in (CorrectionHandling.CURRENT, CorrectionHandling.EITHER):\n            for e in self:\n                if isinstance(e, New) or isinstance(e, Current):\n                    return e.textcontent(cls,correctionhandling)\n        if correctionhandling in (CorrectionHandling.ORIGINAL, CorrectionHandling.EITHER):\n            for e in self:\n                if isinstance(e, Original):\n                    return e.textcontent(cls,correctionhandling)\n        raise NoSuchText",
    "docstring": "See :meth:`AbstractElement.textcontent`",
    "summary": "Cette fonction, `textcontent`, est une m\u00e9thode qui permet de r\u00e9cup\u00e9rer le contenu textuel d'un \u00e9l\u00e9ment, en tenant compte de certaines options de gestion des corrections. Voici une explication simplifi\u00e9e en fran\u00e7ais :\n\n1. **Param\u00e8tres** :\n   - `cls='current'` : Par d\u00e9faut, la classe de l'\u00e9l\u00e9ment est consid\u00e9r\u00e9e comme \"current\" (actuel).\n   - `correctionhandling=CorrectionHandling.CURRENT` : Par d\u00e9faut, la gestion des corrections est d\u00e9finie pour utiliser la version actuelle du texte.\n\n2. **Fonctionnement** :\n   - Si `cls` est d\u00e9fini sur `'original'`, la gestion des corrections est forc\u00e9e pour utiliser la version originale du texte (pour la compatibilit\u00e9 avec des versions ant\u00e9rieures).\n   - La fonction v\u00e9rifie ensuite le type de gestion des corrections (`correctionhandling`) :\n     - Si c'est `CURRENT` ou `EITHER`, elle parcourt les \u00e9l\u00e9ments (`for e in self`) et retourne le contenu textuel du premier \u00e9l\u00e9ment de type `New` ou `Current`.\n     - Si c'est `ORIGINAL` ou `EITHER`, elle parcourt les \u00e9l\u00e9ments et retourne le contenu textuel du premier \u00e9l\u00e9ment de type `Original`.\n   - Si aucun texte correspondant n'est trouv\u00e9, une erreur `NoSuchText` est lev\u00e9e.\n\n3. **R\u00e9sum\u00e9** :\n   Cette fonction permet de r\u00e9cup\u00e9rer le contenu textuel d'un \u00e9l\u00e9ment en fonction de sa classe (`cls`) et de la mani\u00e8re dont les corrections sont g\u00e9r\u00e9es (`correctionhandling`). Elle privil\u00e9gie les versions actuelles ou originales du texte selon les param\u00e8tres fournis."
  },
  {
    "code": "def phoncontent(self, cls='current', correctionhandling=CorrectionHandling.CURRENT):\n        \"\"\"See :meth:`AbstractElement.phoncontent`\"\"\"\n        if cls == 'original': correctionhandling = CorrectionHandling.ORIGINAL #backward compatibility\n        if correctionhandling in (CorrectionHandling.CURRENT, CorrectionHandling.EITHER):\n            for e in self:\n                if isinstance(e, New) or isinstance(e, Current):\n                    return e.phoncontent(cls, correctionhandling)\n        if correctionhandling in (CorrectionHandling.ORIGINAL, CorrectionHandling.EITHER):\n            for e in self:\n                if isinstance(e, Original):\n                    return e.phoncontent(cls, correctionhandling)\n        raise NoSuchPhon",
    "docstring": "See :meth:`AbstractElement.phoncontent`",
    "summary": "Cette fonction, `phoncontent`, semble \u00eatre une m\u00e9thode d'une classe qui g\u00e8re des \u00e9l\u00e9ments de type `AbstractElement`. Voici une explication simplifi\u00e9e en fran\u00e7ais :\n\n1. **Objectif** : La fonction r\u00e9cup\u00e8re le contenu phon\u00e9tique d'un \u00e9l\u00e9ment sp\u00e9cifique, en fonction de certains param\u00e8tres.\n\n2. **Param\u00e8tres** :\n   - `cls='current'` : Par d\u00e9faut, elle cherche le contenu phon\u00e9tique de l'\u00e9l\u00e9ment actuel (`current`). On peut aussi lui demander de chercher dans l'\u00e9l\u00e9ment original (`'original'`).\n   - `correctionhandling=CorrectionHandling.CURRENT` : D\u00e9termine comment g\u00e9rer les corrections. Par d\u00e9faut, elle utilise les corrections actuelles (`CURRENT`), mais peut aussi utiliser les originales (`ORIGINAL`) ou les deux (`EITHER`).\n\n3. **Fonctionnement** :\n   - Si `cls` est `'original'`, elle met \u00e0 jour `correctionhandling` pour assurer la compatibilit\u00e9 avec d'anciennes versions.\n   - Elle parcourt les \u00e9l\u00e9ments (`for e in self`) pour trouver celui qui correspond aux crit\u00e8res :\n     - Si `correctionhandling` est `CURRENT` ou `EITHER`, elle cherche un \u00e9l\u00e9ment de type `New` ou `Current` et retourne son contenu phon\u00e9tique.\n     - Si `correctionhandling` est `ORIGINAL` ou `EITHER`, elle cherche un \u00e9l\u00e9ment de type `Original` et retourne son contenu phon\u00e9tique.\n   - Si aucun \u00e9l\u00e9ment correspondant n'est trouv\u00e9, elle l\u00e8ve une erreur (`NoSuchPhon`).\n\n4. **En r\u00e9sum\u00e9** : Cette fonction cherche et retourne le contenu phon\u00e9tique d'un \u00e9l\u00e9ment sp\u00e9cifique, en fonction de s'il s'agit de la version actuelle ou originale, et en tenant compte des corrections appliqu\u00e9es."
  },
  {
    "code": "def hastext(self, cls='current',strict=True, correctionhandling=CorrectionHandling.CURRENT):\n        \"\"\"See :meth:`AbstractElement.hastext`\"\"\"\n        if cls == 'original': correctionhandling = CorrectionHandling.ORIGINAL #backward compatibility\n        if correctionhandling in (CorrectionHandling.CURRENT, CorrectionHandling.EITHER):\n            for e in self:\n                if isinstance(e, New) or isinstance(e, Current):\n                    return e.hastext(cls,strict, correctionhandling)\n        if correctionhandling in (CorrectionHandling.ORIGINAL, CorrectionHandling.EITHER):\n            for e in self:\n                if isinstance(e, Original):\n                    return e.hastext(cls,strict, correctionhandling)\n        return False",
    "docstring": "See :meth:`AbstractElement.hastext`",
    "summary": "Cette fonction, `hastext`, v\u00e9rifie si un \u00e9l\u00e9ment sp\u00e9cifique (ou un de ses \u00e9l\u00e9ments enfants) contient du texte en fonction de certains crit\u00e8res. Voici une explication simplifi\u00e9e en fran\u00e7ais :\n\n1. **Param\u00e8tres** :\n   - `cls='current'` : D\u00e9finit le type de texte \u00e0 v\u00e9rifier (par d\u00e9faut, il v\u00e9rifie le texte \"actuel\").\n   - `strict=True` : Indique si la v\u00e9rification doit \u00eatre stricte ou non.\n   - `correctionhandling=CorrectionHandling.CURRENT` : D\u00e9termine comment g\u00e9rer les corrections (par d\u00e9faut, il utilise les corrections actuelles).\n\n2. **Fonctionnement** :\n   - Si `cls` est d\u00e9fini sur `'original'`, la fonction ajuste `correctionhandling` pour assurer la compatibilit\u00e9 avec les versions pr\u00e9c\u00e9dentes.\n   - La fonction parcourt les \u00e9l\u00e9ments enfants de l'\u00e9l\u00e9ment actuel (`self`).\n   - Selon la valeur de `correctionhandling`, elle v\u00e9rifie si un \u00e9l\u00e9ment enfant est de type `New`, `Current` ou `Original`.\n   - Si un \u00e9l\u00e9ment correspondant est trouv\u00e9, elle appelle r\u00e9cursivement la m\u00e9thode `hastext` sur cet \u00e9l\u00e9ment.\n   - Si aucun \u00e9l\u00e9ment correspondant n'est trouv\u00e9 apr\u00e8s la v\u00e9rification, la fonction retourne `False`.\n\n3. **Objectif** :\n   - D\u00e9terminer si un \u00e9l\u00e9ment ou un de ses enfants contient du texte, en tenant compte des corrections et du type de texte sp\u00e9cifi\u00e9.\n\nEn r\u00e9sum\u00e9, cette fonction recherche la pr\u00e9sence de texte dans un \u00e9l\u00e9ment ou ses enfants, en appliquant des r\u00e8gles sp\u00e9cifiques bas\u00e9es sur les param\u00e8tres fournis."
  },
  {
    "code": "def text(self, cls = 'current', retaintokenisation=False, previousdelimiter=\"\",strict=False, correctionhandling=CorrectionHandling.CURRENT, normalize_spaces=False):\n        \"\"\"See :meth:`AbstractElement.text`\"\"\"\n        if cls == 'original': correctionhandling = CorrectionHandling.ORIGINAL #backward compatibility\n        if correctionhandling in (CorrectionHandling.CURRENT, CorrectionHandling.EITHER):\n            for e in self:\n                if isinstance(e, New) or isinstance(e, Current):\n                    s = previousdelimiter + e.text(cls, retaintokenisation,\"\", strict, correctionhandling)\n                    if normalize_spaces:\n                        return norm_spaces(s)\n                    else:\n                        return s\n        if correctionhandling in (CorrectionHandling.ORIGINAL, CorrectionHandling.EITHER):\n            for e in self:\n                if isinstance(e, Original):\n                    s =  previousdelimiter + e.text(cls, retaintokenisation,\"\", strict, correctionhandling)\n                    if normalize_spaces:\n                        return norm_spaces(s)\n                    else:\n                        return s\n        raise NoSuchText",
    "docstring": "See :meth:`AbstractElement.text`",
    "summary": "Cette fonction, nomm\u00e9e `text`, semble \u00eatre une m\u00e9thode d'une classe (probablement une classe repr\u00e9sentant un \u00e9l\u00e9ment abstrait, comme `AbstractElement`). Voici une explication simplifi\u00e9e de ce qu'elle fait :\n\n1. **Param\u00e8tres** :\n   - `cls` : D\u00e9finit le type de texte \u00e0 r\u00e9cup\u00e9rer (par d\u00e9faut, 'current').\n   - `retaintokenisation` : Indique si la tokenisation doit \u00eatre conserv\u00e9e.\n   - `previousdelimiter` : Un d\u00e9limiteur \u00e0 ajouter avant le texte r\u00e9cup\u00e9r\u00e9.\n   - `strict` : Un drapeau pour un traitement strict (non pr\u00e9cis\u00e9 ici).\n   - `correctionhandling` : D\u00e9finit comment g\u00e9rer les corrections (par d\u00e9faut, `CorrectionHandling.CURRENT`).\n   - `normalize_spaces` : Indique si les espaces doivent \u00eatre normalis\u00e9s dans le texte r\u00e9cup\u00e9r\u00e9.\n\n2. **Fonctionnement** :\n   - Si `cls` est 'original', elle change `correctionhandling` pour `CorrectionHandling.ORIGINAL` (pour la compatibilit\u00e9 descendante).\n   - Elle parcourt les \u00e9l\u00e9ments (`e`) de l'objet courant (`self`).\n   - Selon la valeur de `correctionhandling`, elle r\u00e9cup\u00e8re le texte des \u00e9l\u00e9ments de type `New`, `Current` ou `Original`.\n   - Elle ajoute le d\u00e9limiteur (`previousdelimiter`) avant le texte r\u00e9cup\u00e9r\u00e9.\n   - Si `normalize_spaces` est `True`, elle normalise les espaces dans le texte \u00e0 l'aide de la fonction `norm_spaces`.\n   - Elle retourne le texte trait\u00e9.\n\n3. **Erreur** :\n   - Si aucun texte correspondant n'est trouv\u00e9, elle l\u00e8ve une exception `NoSuchText`.\n\nEn r\u00e9sum\u00e9, cette fonction r\u00e9cup\u00e8re et traite le texte d'\u00e9l\u00e9ments sp\u00e9cifiques en fonction de param\u00e8tres donn\u00e9s, en g\u00e9rant les corrections et la normalisation des espaces si n\u00e9cessaire."
  },
  {
    "code": "def phon(self, cls = 'current', previousdelimiter=\"\",strict=False, correctionhandling=CorrectionHandling.CURRENT):\n        \"\"\"See :meth:`AbstractElement.phon`\"\"\"\n        if cls == 'original': correctionhandling = CorrectionHandling.ORIGINAL #backward compatibility\n        if correctionhandling in (CorrectionHandling.CURRENT, CorrectionHandling.EITHER):\n            for e in self:\n                if isinstance(e, New) or isinstance(e, Current):\n                    return previousdelimiter + e.phon(cls, \"\", strict, correctionhandling)\n        if correctionhandling in (CorrectionHandling.ORIGINAL, CorrectionHandling.EITHER):\n            for e in self:\n                if isinstance(e, Original):\n                    return previousdelimiter + e.phon(cls, \"\", correctionhandling)\n        raise NoSuchPhon",
    "docstring": "See :meth:`AbstractElement.phon`",
    "summary": "Cette fonction, nomm\u00e9e `phon`, semble \u00eatre une m\u00e9thode d'une classe (probablement une classe repr\u00e9sentant un \u00e9l\u00e9ment abstrait, comme indiqu\u00e9 par le commentaire `See :meth:`AbstractElement.phon``). Voici une explication simplifi\u00e9e de ce qu'elle fait :\n\n1. **Param\u00e8tres** :\n   - `cls` : d\u00e9termine le type de phon\u00e8me \u00e0 r\u00e9cup\u00e9rer (par d\u00e9faut, 'current').\n   - `previousdelimiter` : une cha\u00eene de caract\u00e8res utilis\u00e9e pour s\u00e9parer les phon\u00e8mes (par d\u00e9faut, une cha\u00eene vide).\n   - `strict` : un bool\u00e9en qui indique si la recherche doit \u00eatre stricte ou non.\n   - `correctionhandling` : sp\u00e9cifie comment g\u00e9rer les corrections (par d\u00e9faut, `CorrectionHandling.CURRENT`).\n\n2. **Fonctionnement** :\n   - Si `cls` est \u00e9gal \u00e0 'original', `correctionhandling` est mis \u00e0 jour pour assurer la compatibilit\u00e9 avec les versions pr\u00e9c\u00e9dentes.\n   - La fonction parcourt les \u00e9l\u00e9ments de l'objet (`for e in self`).\n   - Selon la valeur de `correctionhandling`, elle recherche des \u00e9l\u00e9ments de type `New`, `Current` ou `Original`.\n   - Si un \u00e9l\u00e9ment correspondant est trouv\u00e9, elle appelle la m\u00e9thode `phon` de cet \u00e9l\u00e9ment et concat\u00e8ne le r\u00e9sultat avec `previousdelimiter`.\n   - Si aucun \u00e9l\u00e9ment correspondant n'est trouv\u00e9, une exception `NoSuchPhon` est lev\u00e9e.\n\n3. **Objectif** :\n   - L'objectif principal de cette fonction est de r\u00e9cup\u00e9rer une repr\u00e9sentation phon\u00e9tique d'un \u00e9l\u00e9ment, en tenant compte des corrections et des pr\u00e9f\u00e9rences sp\u00e9cifi\u00e9es par les param\u00e8tres.\n\nEn r\u00e9sum\u00e9, cette fonction permet d'obtenir une repr\u00e9sentation phon\u00e9tique d'un \u00e9l\u00e9ment, en fonction de param\u00e8tres sp\u00e9cifi\u00e9s, et g\u00e8re les cas o\u00f9 plusieurs versions (originale, actuelle, etc.) peuvent exister."
  },
  {
    "code": "def gettextdelimiter(self, retaintokenisation=False):\n        \"\"\"See :meth:`AbstractElement.gettextdelimiter`\"\"\"\n        for e in self:\n            if isinstance(e, New) or isinstance(e, Current):\n                return e.gettextdelimiter(retaintokenisation)\n        return \"\"",
    "docstring": "See :meth:`AbstractElement.gettextdelimiter`",
    "summary": "Cette fonction, `gettextdelimiter`, est une m\u00e9thode qui fait partie d'une classe (probablement une classe repr\u00e9sentant un \u00e9l\u00e9ment abstrait, comme `AbstractElement`). Voici ce qu'elle fait en termes simples :\n\n1. **Objectif** : Elle tente de r\u00e9cup\u00e9rer un d\u00e9limiteur de texte (`text delimiter`) \u00e0 partir des \u00e9l\u00e9ments contenus dans l'instance actuelle (`self`).\n\n2. **Fonctionnement** :\n   - Elle parcourt tous les \u00e9l\u00e9ments (`e`) pr\u00e9sents dans `self` (probablement une collection ou une s\u00e9quence d'\u00e9l\u00e9ments).\n   - Pour chaque \u00e9l\u00e9ment, elle v\u00e9rifie s'il est de type `New` ou `Current` (deux classes sp\u00e9cifiques).\n   - Si un \u00e9l\u00e9ment est de l'un de ces types, elle appelle la m\u00e9thode `gettextdelimiter` de cet \u00e9l\u00e9ment avec le param\u00e8tre `retaintokenisation`.\n   - Si aucun \u00e9l\u00e9ment de type `New` ou `Current` n'est trouv\u00e9, la fonction retourne une cha\u00eene vide (`\"\"`).\n\n3. **Param\u00e8tre** :\n   - `retaintokenisation` : Un param\u00e8tre optionnel qui est pass\u00e9 \u00e0 la m\u00e9thode `gettextdelimiter` des \u00e9l\u00e9ments `New` ou `Current` si ceux-ci sont trouv\u00e9s.\n\n4. **R\u00e9sultat** :\n   - Si un d\u00e9limiteur de texte est trouv\u00e9 dans un \u00e9l\u00e9ment `New` ou `Current`, il est retourn\u00e9.\n   - Sinon, une cha\u00eene vide est retourn\u00e9e.\n\nEn r\u00e9sum\u00e9, cette fonction cherche un d\u00e9limiteur de texte sp\u00e9cifique dans les \u00e9l\u00e9ments qu'elle contient et le retourne s'il est trouv\u00e9, sinon elle retourne rien (une cha\u00eene vide)."
  },
  {
    "code": "def new(self,index = None):\n        \"\"\"Get the new corrected annotation.\n\n        This returns only one annotation if multiple exist, use `index` to select another in the sequence.\n\n        Returns:\n            an annotation element (:class:`AbstractElement`)\n\n        Raises:\n            :class:`NoSuchAnnotation`\n        \"\"\"\n\n        if index is None:\n            try:\n                return next(self.select(New,None,False))\n            except StopIteration:\n                raise NoSuchAnnotation\n        else:\n            for e in self.select(New,None,False):\n                return e[index]\n            raise NoSuchAnnotation",
    "docstring": "Get the new corrected annotation.\n\n        This returns only one annotation if multiple exist, use `index` to select another in the sequence.\n\n        Returns:\n            an annotation element (:class:`AbstractElement`)\n\n        Raises:\n            :class:`NoSuchAnnotation`",
    "summary": "Cette fonction, nomm\u00e9e `new`, permet de r\u00e9cup\u00e9rer une annotation corrig\u00e9e \u00e0 partir d'un ensemble d'annotations. Voici une explication simple en fran\u00e7ais :\n\n1. **Objectif** : La fonction retourne une annotation corrig\u00e9e (repr\u00e9sent\u00e9e par un \u00e9l\u00e9ment de type `AbstractElement`). Si plusieurs annotations corrig\u00e9es existent, elle en retourne une par d\u00e9faut, mais vous pouvez en s\u00e9lectionner une sp\u00e9cifique en utilisant l'argument `index`.\n\n2. **Fonctionnement** :\n   - Si `index` n'est pas sp\u00e9cifi\u00e9 (`None`), la fonction essaie de retourner la premi\u00e8re annotation corrig\u00e9e disponible en utilisant `self.select(New, None, False)`. Si aucune annotation n'est trouv\u00e9e, elle l\u00e8ve une exception `NoSuchAnnotation`.\n   - Si `index` est sp\u00e9cifi\u00e9, la fonction parcourt les annotations corrig\u00e9es disponibles et retourne celle correspondant \u00e0 l'indice `index`. Si l'indice est invalide, elle l\u00e8ve \u00e9galement une exception `NoSuchAnnotation`.\n\n3. **R\u00e9sum\u00e9** : C'est une fonction pour r\u00e9cup\u00e9rer une annotation corrig\u00e9e sp\u00e9cifique, avec la possibilit\u00e9 de choisir laquelle si plusieurs existent. Si l'annotation demand\u00e9e n'existe pas, elle signale une erreur."
  },
  {
    "code": "def original(self,index=None):\n        \"\"\"Get the old annotation prior to correction.\n\n        This returns only one annotation if multiple exist, use `index` to select another in the sequence.\n\n        Returns:\n            an annotation element (:class:`AbstractElement`)\n\n        Raises:\n            :class:`NoSuchAnnotation`\n        \"\"\"\n        if index is None:\n            try:\n                return next(self.select(Original,None,False, False))\n            except StopIteration:\n                raise NoSuchAnnotation\n        else:\n            for e in self.select(Original,None,False, False):\n                return e[index]\n            raise NoSuchAnnotation",
    "docstring": "Get the old annotation prior to correction.\n\n        This returns only one annotation if multiple exist, use `index` to select another in the sequence.\n\n        Returns:\n            an annotation element (:class:`AbstractElement`)\n\n        Raises:\n            :class:`NoSuchAnnotation`",
    "summary": "Cette fonction, nomm\u00e9e `original`, permet de r\u00e9cup\u00e9rer une ancienne annotation avant qu'elle ne soit corrig\u00e9e. Voici une explication \u00e9tape par \u00e9tape :\n\n1. **Objectif** : La fonction est con\u00e7ue pour obtenir une annotation sp\u00e9cifique parmi celles qui existaient avant une correction.\n\n2. **Param\u00e8tre `index`** :\n   - Si `index` n'est pas fourni (c'est-\u00e0-dire qu'il est `None`), la fonction retourne la premi\u00e8re annotation disponible dans la s\u00e9quence.\n   - Si `index` est fourni, la fonction retourne l'annotation \u00e0 la position sp\u00e9cifi\u00e9e par `index` dans la s\u00e9quence.\n\n3. **Fonctionnement** :\n   - La fonction utilise `self.select(Original, None, False, False)` pour r\u00e9cup\u00e9rer une s\u00e9quence d'annotations originales.\n   - Si `index` est `None`, elle tente de retourner la premi\u00e8re annotation de cette s\u00e9quence \u00e0 l'aide de `next()`.\n   - Si `index` est sp\u00e9cifi\u00e9, elle parcourt la s\u00e9quence et retourne l'annotation \u00e0 la position `index`.\n\n4. **Exceptions** :\n   - Si aucune annotation n'est trouv\u00e9e (que ce soit avec ou sans `index`), la fonction l\u00e8ve une exception `NoSuchAnnotation`, indiquant qu'il n'y a pas d'annotation correspondante.\n\nEn r\u00e9sum\u00e9, cette fonction permet de r\u00e9cup\u00e9rer une annotation originale sp\u00e9cifique, soit la premi\u00e8re disponible, soit celle \u00e0 une position donn\u00e9e, et g\u00e8re le cas o\u00f9 aucune annotation n'est trouv\u00e9e."
  },
  {
    "code": "def current(self,index=None):\n        \"\"\"Get the current authoritative annotation (used with suggestions in a structural context)\n\n        This returns only one annotation if multiple exist, use `index` to select another in the sequence.\n\n        Returns:\n            an annotation element (:class:`AbstractElement`)\n\n        Raises:\n            :class:`NoSuchAnnotation`\n        \"\"\"\n        if index is None:\n            try:\n                return next(self.select(Current,None,False))\n            except StopIteration:\n                raise NoSuchAnnotation\n        else:\n            for e in self.select(Current,None,False):\n                return e[index]\n            raise NoSuchAnnotation",
    "docstring": "Get the current authoritative annotation (used with suggestions in a structural context)\n\n        This returns only one annotation if multiple exist, use `index` to select another in the sequence.\n\n        Returns:\n            an annotation element (:class:`AbstractElement`)\n\n        Raises:\n            :class:`NoSuchAnnotation`",
    "summary": "Cette fonction, nomm\u00e9e `current`, permet de r\u00e9cup\u00e9rer l'annotation actuelle et officielle (appel\u00e9e \"authoritative annotation\") parmi plusieurs suggestions dans un contexte structurel. Voici ce qu'elle fait en d\u00e9tail :\n\n1. **Objectif principal** : Elle retourne une seule annotation, m\u00eame s'il en existe plusieurs. Si vous voulez une annotation sp\u00e9cifique parmi plusieurs, vous pouvez utiliser le param\u00e8tre `index` pour la s\u00e9lectionner.\n\n2. **Fonctionnement** :\n   - Si `index` n'est pas sp\u00e9cifi\u00e9 (`None`), la fonction essaie de retourner la premi\u00e8re annotation disponible en utilisant `self.select(Current, None, False)`.\n   - Si aucune annotation n'est trouv\u00e9e, elle l\u00e8ve une exception `NoSuchAnnotation`.\n   - Si `index` est sp\u00e9cifi\u00e9, la fonction parcourt les annotations disponibles et retourne celle correspondant \u00e0 l'indice donn\u00e9. Si l'indice est invalide, elle l\u00e8ve \u00e9galement une exception `NoSuchAnnotation`.\n\n3. **Retour** : La fonction retourne un \u00e9l\u00e9ment d'annotation de type `AbstractElement`.\n\n4. **Exceptions** : Si aucune annotation n'est trouv\u00e9e, elle l\u00e8ve une exception `NoSuchAnnotation`.\n\nEn r\u00e9sum\u00e9, cette fonction permet de r\u00e9cup\u00e9rer une annotation sp\u00e9cifique parmi plusieurs suggestions, en utilisant un indice si n\u00e9cessaire, et g\u00e8re les cas o\u00f9 aucune annotation n'est disponible."
  },
  {
    "code": "def suggestions(self,index=None):\n        \"\"\"Get suggestions for correction.\n\n        Yields:\n            :class:`Suggestion` element that encapsulate the suggested annotations (if index is ``None``, default)\n\n        Returns:\n            a :class:`Suggestion` element that encapsulate the suggested annotations (if index is set)\n\n        Raises:\n            :class:`IndexError`\n        \"\"\"\n        if index is None:\n            return self.select(Suggestion,None,False, False)\n        else:\n            for i, e in enumerate(self.select(Suggestion,None,False, False)):\n                if index == i:\n                    return e\n            raise IndexError",
    "docstring": "Get suggestions for correction.\n\n        Yields:\n            :class:`Suggestion` element that encapsulate the suggested annotations (if index is ``None``, default)\n\n        Returns:\n            a :class:`Suggestion` element that encapsulate the suggested annotations (if index is set)\n\n        Raises:\n            :class:`IndexError`",
    "summary": "Cette fonction, nomm\u00e9e `suggestions`, permet d'obtenir des suggestions de correction. Voici ce qu'elle fait en termes simples :\n\n1. **Si aucun index n'est fourni (`index=None`)** :  \n   La fonction retourne **toutes les suggestions de correction** disponibles, sous forme d'une liste d'\u00e9l\u00e9ments appel\u00e9s `Suggestion`. Chaque `Suggestion` contient des annotations propos\u00e9es pour une correction.\n\n2. **Si un index est fourni (`index` est d\u00e9fini)** :  \n   La fonction parcourt la liste des suggestions et retourne **uniquement la suggestion correspondant \u00e0 l'index sp\u00e9cifi\u00e9**. Si l'index est invalide (par exemple, trop grand ou n\u00e9gatif), elle d\u00e9clenche une erreur de type `IndexError`.\n\nEn r\u00e9sum\u00e9, cette fonction permet soit de r\u00e9cup\u00e9rer toutes les suggestions, soit d'en s\u00e9lectionner une sp\u00e9cifique en fonction de son positionnement (index) dans la liste."
  },
  {
    "code": "def select(self, Class, set=None, recursive=True,  ignore=True, node=None):\n        \"\"\"See :meth:`AbstractElement.select`\"\"\"\n        if self.include:\n            return self.subdoc.data[0].select(Class,set,recursive, ignore, node) #pass it on to the text node of the subdoc\n        else:\n            return iter([])",
    "docstring": "See :meth:`AbstractElement.select`",
    "summary": "Cette fonction, nomm\u00e9e `select`, est une m\u00e9thode qui permet de s\u00e9lectionner des \u00e9l\u00e9ments sp\u00e9cifiques dans une structure de donn\u00e9es, probablement un document ou un arbre de donn\u00e9es. Voici une explication simplifi\u00e9e en fran\u00e7ais :\n\n1. **Objectif** : La fonction `select` est utilis\u00e9e pour trouver et retourner des \u00e9l\u00e9ments d'une certaine classe (`Class`) dans une structure de donn\u00e9es.\n\n2. **Param\u00e8tres** :\n   - `Class` : Le type d'\u00e9l\u00e9ment que vous voulez s\u00e9lectionner.\n   - `set` : Optionnel, peut \u00eatre utilis\u00e9 pour filtrer les \u00e9l\u00e9ments s\u00e9lectionn\u00e9s.\n   - `recursive` : Si `True`, la recherche se fait de mani\u00e8re r\u00e9cursive dans les sous-structures.\n   - `ignore` : Si `True`, certains \u00e9l\u00e9ments peuvent \u00eatre ignor\u00e9s pendant la recherche.\n   - `node` : Optionnel, sp\u00e9cifie un n\u0153ud de d\u00e9part pour la recherche.\n\n3. **Fonctionnement** :\n   - Si `self.include` est `True`, la fonction d\u00e9l\u00e8gue la recherche \u00e0 un autre \u00e9l\u00e9ment (`self.subdoc.data[0]`) pour effectuer la s\u00e9lection.\n   - Si `self.include` est `False`, la fonction retourne un it\u00e9rateur vide (`iter([])`), ce qui signifie qu'aucun \u00e9l\u00e9ment n'est s\u00e9lectionn\u00e9.\n\n4. **R\u00e9sultat** : La fonction retourne un it\u00e9rateur sur les \u00e9l\u00e9ments s\u00e9lectionn\u00e9s, ou un it\u00e9rateur vide si aucune s\u00e9lection n'est effectu\u00e9e.\n\nEn r\u00e9sum\u00e9, cette fonction permet de rechercher et de retourner des \u00e9l\u00e9ments sp\u00e9cifiques dans une structure de donn\u00e9es, en fonction de crit\u00e8res d\u00e9finis par les param\u00e8tres. Si la recherche est activ\u00e9e (`self.include` est `True`), elle est d\u00e9l\u00e9gu\u00e9e \u00e0 un autre \u00e9l\u00e9ment pour effectuer la s\u00e9lection. Sinon, elle retourne un r\u00e9sultat vide."
  },
  {
    "code": "def xml(self, attribs = None,elements = None, skipchildren = False):\n        \"\"\"Serialises the FoLiA element to XML, by returning an XML Element (in lxml.etree) for this element and all its children. For string output, consider the xmlstring() method instead.\"\"\"\n        E = ElementMaker(namespace=NSFOLIA,nsmap={None: NSFOLIA, 'xml' : \"http://www.w3.org/XML/1998/namespace\"})\n\n        if not attribs: attribs = {}\n        if not elements: elements = []\n\n        if self.id:\n            attribs['id'] = self.id\n            try:\n                w = self.doc[self.id]\n                attribs['t'] = w.text()\n            except KeyError:\n                pass\n\n        e  = makeelement(E, '{' + NSFOLIA + '}' + self.XMLTAG, **attribs)\n        return e",
    "docstring": "Serialises the FoLiA element to XML, by returning an XML Element (in lxml.etree) for this element and all its children. For string output, consider the xmlstring() method instead.",
    "summary": "Cette fonction, nomm\u00e9e `xml`, est utilis\u00e9e pour convertir un \u00e9l\u00e9ment FoLiA (Format for Linguistic Annotation) en un \u00e9l\u00e9ment XML. Voici une explication \u00e9tape par \u00e9tape en fran\u00e7ais :\n\n1. **Objectif** : La fonction g\u00e9n\u00e8re une repr\u00e9sentation XML d'un \u00e9l\u00e9ment FoLiA, y compris ses attributs et ses enfants (si `skipchildren` est `False`).\n\n2. **Param\u00e8tres** :\n   - `attribs` : Un dictionnaire d'attributs \u00e0 inclure dans l'\u00e9l\u00e9ment XML. S'il n'est pas fourni, un dictionnaire vide est utilis\u00e9.\n   - `elements` : Une liste d'\u00e9l\u00e9ments enfants \u00e0 inclure. S'il n'est pas fourni, une liste vide est utilis\u00e9e.\n   - `skipchildren` : Un bool\u00e9en indiquant si les enfants de l'\u00e9l\u00e9ment doivent \u00eatre ignor\u00e9s (`True`) ou inclus (`False`).\n\n3. **Cr\u00e9ation de l'\u00e9l\u00e9ment XML** :\n   - `E = ElementMaker(...)` : Cr\u00e9e un constructeur d'\u00e9l\u00e9ments XML avec un espace de noms sp\u00e9cifique \u00e0 FoLiA.\n   - Si l'\u00e9l\u00e9ment a un identifiant (`self.id`), il est ajout\u00e9 aux attributs, ainsi que le texte associ\u00e9 \u00e0 cet identifiant (s'il existe).\n\n4. **Construction de l'\u00e9l\u00e9ment** :\n   - `e = makeelement(E, '{' + NSFOLIA + '}' + self.XMLTAG, **attribs)` : Cr\u00e9e l'\u00e9l\u00e9ment XML avec le nom d'\u00e9tiquette appropri\u00e9 et les attributs fournis.\n\n5. **Retour** : La fonction retourne l'\u00e9l\u00e9ment XML cr\u00e9\u00e9 (`e`), pr\u00eat \u00e0 \u00eatre utilis\u00e9 ou s\u00e9rialis\u00e9.\n\nEn r\u00e9sum\u00e9, cette fonction transforme un \u00e9l\u00e9ment FoLiA en un \u00e9l\u00e9ment XML structur\u00e9, en tenant compte de ses attributs et de ses enfants (si demand\u00e9). Pour obtenir une cha\u00eene XML directement, il est recommand\u00e9 d'utiliser la m\u00e9thode `xmlstring()` mentionn\u00e9e dans le docstring."
  },
  {
    "code": "def annotation(self, type, set=None):\n        \"\"\"Will return a **single** annotation (even if there are multiple). Raises a ``NoSuchAnnotation`` exception if none was found\"\"\"\n        l = self.count(type,set,True,default_ignore_annotations)\n        if len(l) >= 1:\n            return l[0]\n        else:\n            raise NoSuchAnnotation()",
    "docstring": "Will return a **single** annotation (even if there are multiple). Raises a ``NoSuchAnnotation`` exception if none was found",
    "summary": "Cette fonction, nomm\u00e9e `annotation`, est con\u00e7ue pour r\u00e9cup\u00e9rer une annotation sp\u00e9cifique \u00e0 partir d'un ensemble de donn\u00e9es. Voici une explication \u00e9tape par \u00e9tape en fran\u00e7ais :\n\n1. **Param\u00e8tres** :\n   - `self` : fait r\u00e9f\u00e9rence \u00e0 l'instance de la classe dans laquelle cette m\u00e9thode est d\u00e9finie.\n   - `type` : sp\u00e9cifie le type d'annotation que l'on cherche \u00e0 r\u00e9cup\u00e9rer.\n   - `set` : optionnel, permet de pr\u00e9ciser un ensemble sp\u00e9cifique dans lequel chercher l'annotation.\n\n2. **Fonctionnement** :\n   - La fonction utilise `self.count` pour compter les annotations du type sp\u00e9cifi\u00e9, en tenant compte de l'ensemble (`set`) et en ignorant certaines annotations par d\u00e9faut (`default_ignore_annotations`).\n   - Elle stocke le r\u00e9sultat dans la variable `l`.\n\n3. **Retour** :\n   - Si au moins une annotation est trouv\u00e9e (`len(l) >= 1`), la fonction retourne la premi\u00e8re annotation de la liste (`l[0]`).\n   - Si aucune annotation n'est trouv\u00e9e, elle l\u00e8ve une exception `NoSuchAnnotation` pour indiquer que l'annotation recherch\u00e9e n'existe pas.\n\nEn r\u00e9sum\u00e9, cette fonction permet de r\u00e9cup\u00e9rer une seule annotation d'un type sp\u00e9cifique, m\u00eame s'il y en a plusieurs, et signale une erreur si aucune annotation correspondante n'est trouv\u00e9e."
  },
  {
    "code": "def findspans(self, type,set=None):\n        \"\"\"Find span annotation of the specified type that include this word\"\"\"\n        if issubclass(type, AbstractAnnotationLayer):\n            layerclass = type\n        else:\n            layerclass = ANNOTATIONTYPE2LAYERCLASS[type.ANNOTATIONTYPE]\n        e = self\n        while True:\n            if not e.parent: break\n            e = e.parent\n            for layer in e.select(layerclass,set,False):\n                for e2 in layer:\n                    if isinstance(e2, AbstractSpanAnnotation):\n                        if self in e2.wrefs():\n                            yield e2",
    "docstring": "Find span annotation of the specified type that include this word",
    "summary": "Voici une explication en fran\u00e7ais de ce que fait cette fonction :\n\nLa fonction `findspans` permet de **trouver toutes les annotations de type \"span\" (intervalle de texte)** qui incluent un mot sp\u00e9cifique. Voici comment elle fonctionne \u00e9tape par \u00e9tape :\n\n1. **V\u00e9rification du type d'annotation** :  \n   Elle v\u00e9rifie si le type d'annotation fourni (`type`) est une sous-classe de `AbstractAnnotationLayer`. Si ce n'est pas le cas, elle r\u00e9cup\u00e8re la classe de couche correspondante \u00e0 partir d'un dictionnaire (`ANNOTATIONTYPE2LAYERCLASS`).\n\n2. **Recherche dans la hi\u00e9rarchie** :  \n   Elle commence par l'\u00e9l\u00e9ment actuel (`self`, probablement un mot) et remonte dans la hi\u00e9rarchie des \u00e9l\u00e9ments parents (`e.parent`) pour explorer les annotations \u00e0 des niveaux sup\u00e9rieurs.\n\n3. **S\u00e9lection des couches d'annotation** :  \n   Pour chaque niveau hi\u00e9rarchique, elle s\u00e9lectionne les couches d'annotation du type sp\u00e9cifi\u00e9 (`layerclass`) en utilisant la m\u00e9thode `select`.\n\n4. **V\u00e9rification des annotations span** :  \n   Elle parcourt chaque annotation dans ces couches et v\u00e9rifie si elles sont de type `AbstractSpanAnnotation` (c'est-\u00e0-dire des annotations qui couvrent un intervalle de texte).\n\n5. **Inclusion du mot** :  \n   Si l'annotation span contient le mot actuel (`self`) parmi ses r\u00e9f\u00e9rences de mots (`wrefs`), elle retourne cette annotation.\n\n6. **R\u00e9sultat** :  \n   La fonction utilise `yield` pour retourner chaque annotation span trouv\u00e9e, une par une, au fur et \u00e0 mesure de leur d\u00e9couverte.\n\nEn r\u00e9sum\u00e9, cette fonction recherche et retourne toutes les annotations span qui incluent le mot sur lequel elle est appel\u00e9e, en explorant les niveaux hi\u00e9rarchiques sup\u00e9rieurs si n\u00e9cessaire."
  },
  {
    "code": "def correctwords(self, originalwords, newwords, **kwargs):\n        \"\"\"Generic correction method for words. You most likely want to use the helper functions\n           :meth:`Sentence.splitword` , :meth:`Sentence.mergewords`, :meth:`deleteword`, :meth:`insertword` instead\"\"\"\n        for w in originalwords:\n            if not isinstance(w, Word):\n                raise Exception(\"Original word is not a Word instance: \" + str(type(w)))\n            elif w.sentence() != self:\n                raise Exception(\"Original not found as member of sentence!\")\n        for w in newwords:\n            if not isinstance(w, Word):\n                raise Exception(\"New word is not a Word instance: \" + str(type(w)))\n        if 'suggest' in kwargs and kwargs['suggest']:\n            del kwargs['suggest']\n            return self.correct(suggestion=newwords,current=originalwords, **kwargs)\n        else:\n            return self.correct(original=originalwords, new=newwords, **kwargs)",
    "docstring": "Generic correction method for words. You most likely want to use the helper functions\n           :meth:`Sentence.splitword` , :meth:`Sentence.mergewords`, :meth:`deleteword`, :meth:`insertword` instead",
    "summary": "Cette fonction, `correctwords`, est une m\u00e9thode g\u00e9n\u00e9rique pour corriger des mots dans une phrase. Voici ce qu'elle fait en termes simples :\n\n1. **V\u00e9rification des mots d'origine** : Elle v\u00e9rifie que chaque mot de la liste `originalwords` est bien une instance de la classe `Word` (c'est-\u00e0-dire qu'il s'agit d'un mot valide dans le contexte de la phrase). Si ce n'est pas le cas, elle l\u00e8ve une exception (une erreur). Elle v\u00e9rifie \u00e9galement que ces mots appartiennent bien \u00e0 la phrase actuelle (`self`).\n\n2. **V\u00e9rification des nouveaux mots** : Elle fait la m\u00eame v\u00e9rification pour les mots de la liste `newwords`, s'assurant qu'ils sont \u00e9galement des instances de `Word`.\n\n3. **Correction des mots** : \n   - Si le param\u00e8tre `suggest` est pr\u00e9sent et vrai dans `kwargs`, elle supprime ce param\u00e8tre et appelle la m\u00e9thode `correct` en utilisant `newwords` comme suggestion et `originalwords` comme mots actuels.\n   - Sinon, elle appelle simplement la m\u00e9thode `correct` en passant `originalwords` comme mots \u00e0 corriger et `newwords` comme nouveaux mots.\n\nEn r\u00e9sum\u00e9, cette fonction permet de remplacer des mots dans une phrase par de nouveaux mots, en s'assurant que les mots sont valides et en offrant la possibilit\u00e9 de sugg\u00e9rer des corrections plut\u00f4t que de les appliquer directement. Elle est con\u00e7ue pour \u00eatre utilis\u00e9e avec d'autres fonctions d'aide pour manipuler les mots dans une phrase."
  },
  {
    "code": "def splitword(self, originalword, *newwords, **kwargs):\n        \"\"\"TODO: Write documentation\"\"\"\n        if isstring(originalword):\n            originalword = self.doc[u(originalword)]\n        return self.correctwords([originalword], newwords, **kwargs)",
    "docstring": "TODO: Write documentation",
    "summary": "Cette fonction, `splitword`, semble \u00eatre une m\u00e9thode d'une classe (car elle utilise `self` comme premier param\u00e8tre). Voici ce qu'elle fait en termes simples :\n\n1. **Entr\u00e9es** :\n   - `originalword` : le mot d'origine que vous voulez modifier ou corriger.\n   - `*newwords` : un ou plusieurs nouveaux mots que vous souhaitez utiliser pour remplacer ou compl\u00e9ter `originalword`.\n   - `**kwargs` : des arguments suppl\u00e9mentaires (optionnels) qui peuvent influencer le comportement de la fonction.\n\n2. **Fonctionnement** :\n   - **V\u00e9rification du type** : Si `originalword` est une cha\u00eene de caract\u00e8res (un texte), la fonction le convertit en utilisant `self.doc[u(originalword)]`. Cela sugg\u00e8re qu'elle cherche peut-\u00eatre une r\u00e9f\u00e9rence ou une d\u00e9finition dans un dictionnaire ou une base de donn\u00e9es.\n   - **Correction des mots** : La fonction appelle ensuite `self.correctwords` avec `originalword` (\u00e9ventuellement converti) et les `newwords` fournis. Cette m\u00e9thode `correctwords` semble \u00eatre responsable de la logique de correction ou de modification des mots.\n\n3. **Sortie** :\n   - La fonction retourne le r\u00e9sultat de `self.correctwords`, qui est probablement une liste de mots corrig\u00e9s ou modifi\u00e9s en fonction des entr\u00e9es fournies.\n\nEn r\u00e9sum\u00e9, cette fonction prend un mot d'origine, \u00e9ventuellement des nouveaux mots, et utilise une m\u00e9thode interne pour les corriger ou les modifier, en retournant le r\u00e9sultat."
  },
  {
    "code": "def mergewords(self, newword, *originalwords, **kwargs):\n        \"\"\"TODO: Write documentation\"\"\"\n        return self.correctwords(originalwords, [newword], **kwargs)",
    "docstring": "TODO: Write documentation",
    "summary": "Cette fonction, `mergewords`, semble \u00eatre une m\u00e9thode d'une classe (car elle utilise `self` comme premier param\u00e8tre). Voici ce qu'elle fait en termes simples :\n\n1. **Objectif** : Elle permet de fusionner un nouveau mot (`newword`) avec une liste de mots existants (`originalwords`).\n2. **Param\u00e8tres** :\n   - `newword` : Le nouveau mot que vous voulez ajouter.\n   - `*originalwords` : Une liste de mots existants (pass\u00e9s sous forme d'arguments variables).\n   - `**kwargs` : Des arguments suppl\u00e9mentaires optionnels (par exemple, des param\u00e8tres de configuration).\n3. **Fonctionnement** : Elle appelle une autre m\u00e9thode de la classe, `correctwords`, en passant les mots existants, le nouveau mot, et les arguments suppl\u00e9mentaires.\n4. **R\u00e9sultat** : Elle retourne le r\u00e9sultat de la m\u00e9thode `correctwords`, qui semble \u00eatre responsable de la gestion ou de la correction des mots.\n\nEn r\u00e9sum\u00e9, cette fonction prend un nouveau mot et des mots existants, puis utilise une autre m\u00e9thode pour les traiter ensemble, probablement pour les corriger ou les ajuster d'une mani\u00e8re sp\u00e9cifique."
  },
  {
    "code": "def deleteword(self, word, **kwargs):\n        \"\"\"TODO: Write documentation\"\"\"\n        if isstring(word):\n            word = self.doc[u(word)]\n        return self.correctwords([word], [], **kwargs)",
    "docstring": "TODO: Write documentation",
    "summary": "Cette fonction, `deleteword`, semble \u00eatre une m\u00e9thode d'une classe (car elle utilise `self` comme premier param\u00e8tre). Voici ce qu'elle fait en termes simples :\n\n1. **V\u00e9rification du type de `word`** :  \n   Elle v\u00e9rifie d'abord si `word` est une cha\u00eene de caract\u00e8res (un mot). Si c'est le cas, elle utilise une propri\u00e9t\u00e9 `doc` de l'objet pour r\u00e9cup\u00e9rer une valeur associ\u00e9e \u00e0 ce mot (via `self.doc[u(word)]`).\n\n2. **Appel \u00e0 une autre fonction** :  \n   Ensuite, elle appelle une autre fonction `correctwords` en passant le mot (ou la valeur r\u00e9cup\u00e9r\u00e9e) comme argument, ainsi qu'une liste vide et des arguments suppl\u00e9mentaires (`**kwargs`).\n\n3. **Retour du r\u00e9sultat** :  \n   La fonction retourne ce que `correctwords` renvoie.\n\nEn r\u00e9sum\u00e9, cette fonction semble supprimer ou corriger un mot en utilisant une logique d\u00e9finie dans `correctwords`, apr\u00e8s avoir \u00e9ventuellement r\u00e9cup\u00e9r\u00e9 des informations suppl\u00e9mentaires sur ce mot. Cependant, sans plus de contexte sur `correctwords` et `doc`, il est difficile d'\u00eatre plus pr\u00e9cis."
  },
  {
    "code": "def insertwordleft(self, newword, nextword, **kwargs):\n        \"\"\"Inserts a word **as a correction** before an existing word.\n\n        Reverse of :meth:`Sentence.insertword`.\n        \"\"\"\n        if nextword:\n            if isstring(nextword):\n                nextword = self.doc[u(nextword)]\n            if not nextword in self or not isinstance(nextword, Word):\n                raise Exception(\"Next word not found or not instance of Word!\")\n            if isinstance(newword, list) or isinstance(newword, tuple):\n                if not all([ isinstance(x, Word) for x in newword ]):\n                    raise Exception(\"New word (iterable) constains non-Word instances!\")\n            elif not isinstance(newword, Word):\n                raise Exception(\"New word no instance of Word!\")\n\n            kwargs['insertindex'] = self.getindex(nextword)\n        else:\n            kwargs['insertindex'] = 0\n        kwargs['nooriginal'] = True\n        if isinstance(newword, list) or isinstance(newword, tuple):\n            return self.correctwords([], newword, **kwargs)\n        else:\n            return self.correctwords([], [newword], **kwargs)",
    "docstring": "Inserts a word **as a correction** before an existing word.\n\n        Reverse of :meth:`Sentence.insertword`.",
    "summary": "Cette fonction, `insertwordleft`, permet d'ins\u00e9rer un mot **comme correction** avant un mot existant dans une phrase. Voici une explication \u00e9tape par \u00e9tape :\n\n1. **Objectif** : Elle ajoute un nouveau mot (`newword`) juste avant un mot d\u00e9j\u00e0 pr\u00e9sent (`nextword`) dans une phrase. C'est l'oppos\u00e9 de la fonction `insertword`, qui ins\u00e8re un mot apr\u00e8s un autre.\n\n2. **V\u00e9rifications** :\n   - Elle v\u00e9rifie si `nextword` existe bien dans la phrase et s'il s'agit d'une instance de la classe `Word`. Si ce n'est pas le cas, une erreur est lev\u00e9e.\n   - Elle v\u00e9rifie \u00e9galement que `newword` est soit une instance de `Word`, soit une liste ou un tuple contenant uniquement des instances de `Word`. Sinon, une erreur est lev\u00e9e.\n\n3. **Position d'insertion** :\n   - Si `nextword` est fourni, le nouveau mot est ins\u00e9r\u00e9 juste avant lui.\n   - Si `nextword` n'est pas fourni, le nouveau mot est ins\u00e9r\u00e9 au d\u00e9but de la phrase.\n\n4. **Correction** :\n   - La fonction utilise `correctwords` pour ins\u00e9rer le nouveau mot, en sp\u00e9cifiant que c'est une correction (`kwargs['nooriginal'] = True`).\n\n5. **R\u00e9sultat** :\n   - Si `newword` est une liste ou un tuple, tous les mots de cette liste sont ins\u00e9r\u00e9s.\n   - Sinon, seul le mot `newword` est ins\u00e9r\u00e9.\n\nEn r\u00e9sum\u00e9, cette fonction est utilis\u00e9e pour ajouter un mot correctif avant un mot existant dans une phrase, en s'assurant que les mots sont bien format\u00e9s et positionn\u00e9s correctement."
  },
  {
    "code": "def resolve(self,size, distribution):\n        \"\"\"Resolve a variable sized pattern to all patterns of a certain fixed size\"\"\"\n        if not self.variablesize():\n            raise Exception(\"Can only resize patterns with * wildcards\")\n\n        nrofwildcards = 0\n        for x in self.sequence:\n            if x == '*':\n                nrofwildcards += 1\n\n        assert (len(distribution) == nrofwildcards)\n\n        wildcardnr = 0\n        newsequence = []\n        for x in self.sequence:\n            if x == '*':\n                newsequence += [True] * distribution[wildcardnr]\n                wildcardnr += 1\n            else:\n                newsequence.append(x)\n        d = { 'matchannotation':self.matchannotation, 'matchannotationset':self.matchannotationset, 'casesensitive':self.casesensitive }\n        yield Pattern(*newsequence, **d )",
    "docstring": "Resolve a variable sized pattern to all patterns of a certain fixed size",
    "summary": "Voici une explication en fran\u00e7ais de ce que fait cette fonction :\n\nLa fonction `resolve` prend en entr\u00e9e un objet `self` (qui repr\u00e9sente probablement un motif ou un mod\u00e8le), une taille `size` et une distribution `distribution`. Son objectif est de transformer un motif de taille variable (contenant des caract\u00e8res g\u00e9n\u00e9riques `*`) en un ou plusieurs motifs de taille fixe.\n\nVoici les \u00e9tapes principales :\n\n1. **V\u00e9rification** : La fonction v\u00e9rifie d'abord si le motif (`self`) est de taille variable (c'est-\u00e0-dire s'il contient des `*`). Si ce n'est pas le cas, elle l\u00e8ve une exception, car elle ne peut traiter que des motifs avec des caract\u00e8res g\u00e9n\u00e9riques.\n\n2. **Comptage des caract\u00e8res g\u00e9n\u00e9riques** : Elle compte ensuite le nombre de caract\u00e8res g\u00e9n\u00e9riques (`*`) pr\u00e9sents dans le motif.\n\n3. **Validation de la distribution** : Elle s'assure que la longueur de la liste `distribution` correspond exactement au nombre de caract\u00e8res g\u00e9n\u00e9riques. Cette liste `distribution` indique comment chaque caract\u00e8re g\u00e9n\u00e9rique doit \u00eatre remplac\u00e9.\n\n4. **Construction du nouveau motif** : La fonction parcourt le motif original. Lorsqu'elle rencontre un `*`, elle le remplace par une s\u00e9quence de `True` dont la longueur est sp\u00e9cifi\u00e9e dans `distribution`. Les autres caract\u00e8res sont simplement copi\u00e9s tels quels.\n\n5. **Cr\u00e9ation du nouveau motif** : Une fois la nouvelle s\u00e9quence construite, la fonction cr\u00e9e un nouvel objet `Pattern` avec cette s\u00e9quence et conserve les attributs originaux (`matchannotation`, `matchannotationset`, `casesensitive`).\n\n6. **Retour du r\u00e9sultat** : La fonction utilise `yield` pour retourner le nouveau motif, ce qui sugg\u00e8re qu'elle peut g\u00e9n\u00e9rer plusieurs motifs si n\u00e9cessaire.\n\nEn r\u00e9sum\u00e9, cette fonction transforme un motif contenant des caract\u00e8res g\u00e9n\u00e9riques en un ou plusieurs motifs de taille fixe, en suivant les instructions fournies dans la liste `distribution`."
  },
  {
    "code": "def load(self, filename):\n        \"\"\"Load a FoLiA XML file.\n\n        Argument:\n            filename (str): The file to load\n        \"\"\"\n        #if LXE and self.mode != Mode.XPATH:\n        #    #workaround for xml:id problem (disabled)\n        #    #f = open(filename)\n        #    #s = f.read().replace(' xml:id=', ' id=')\n        #    #f.close()\n        #    self.tree = ElementTree.parse(filename)\n        #else:\n        self.tree = xmltreefromfile(filename)\n        self.parsexml(self.tree.getroot())\n        if self.mode != Mode.XPATH:\n            #XML Tree is now obsolete (only needed when partially loaded for xpath queries)\n            self.tree = None",
    "docstring": "Load a FoLiA XML file.\n\n        Argument:\n            filename (str): The file to load",
    "summary": "Cette fonction, nomm\u00e9e `load`, permet de charger un fichier XML au format FoLiA (Format for Linguistic Annotation) dans un objet Python. Voici une explication \u00e9tape par \u00e9tape en fran\u00e7ais :\n\n1. **Objectif** : La fonction charge un fichier XML sp\u00e9cifi\u00e9 par son nom (`filename`) et le pr\u00e9pare pour \u00eatre utilis\u00e9 dans le programme.\n\n2. **Param\u00e8tre** :\n   - `filename` (str) : Le nom du fichier XML \u00e0 charger.\n\n3. **Processus** :\n   - La fonction utilise une autre fonction appel\u00e9e `xmltreefromfile` pour lire le fichier XML et le transformer en un arbre XML (`self.tree`).\n   - Ensuite, elle appelle la m\u00e9thode `parsexml` pour analyser l'arbre XML \u00e0 partir de sa racine (`getroot`).\n   - Si le mode de l'objet n'est pas `Mode.XPATH`, l'arbre XML (`self.tree`) est supprim\u00e9 car il n'est plus n\u00e9cessaire apr\u00e8s le chargement complet. Cela lib\u00e8re de la m\u00e9moire.\n\n4. **R\u00e9sultat** : Apr\u00e8s l'ex\u00e9cution de cette fonction, le contenu du fichier XML est charg\u00e9 et pr\u00eat \u00e0 \u00eatre utilis\u00e9 dans l'objet Python, selon les besoins du programme.\n\nEn r\u00e9sum\u00e9, cette fonction charge et pr\u00e9pare un fichier XML FoLiA pour une utilisation ult\u00e9rieure dans le programme."
  },
  {
    "code": "def items(self):\n        \"\"\"Returns a depth-first flat list of all items in the document\"\"\"\n        l = []\n        for e in self.data:\n            l += e.items()\n        return l",
    "docstring": "Returns a depth-first flat list of all items in the document",
    "summary": "Cette fonction, nomm\u00e9e `items`, est une m\u00e9thode qui fait partie d'une classe (indiqu\u00e9e par `self`). Son r\u00f4le est de parcourir tous les \u00e9l\u00e9ments d'un document et de les retourner dans une liste plate, en suivant un ordre de parcours en profondeur (depth-first).\n\nVoici une explication \u00e9tape par \u00e9tape :\n\n1. **`l = []`** : Une liste vide `l` est cr\u00e9\u00e9e pour stocker les \u00e9l\u00e9ments.\n2. **`for e in self.data:`** : La fonction parcourt chaque \u00e9l\u00e9ment `e` contenu dans `self.data`, qui repr\u00e9sente probablement les donn\u00e9es du document.\n3. **`l += e.items()`** : Pour chaque \u00e9l\u00e9ment `e`, la fonction appelle la m\u00e9thode `items()` sur `e` (supposant que `e` a une m\u00e9thode `items()`). Les r\u00e9sultats sont ajout\u00e9s \u00e0 la liste `l`.\n4. **`return l`** : Enfin, la fonction retourne la liste `l` contenant tous les \u00e9l\u00e9ments du document, organis\u00e9s de mani\u00e8re plate apr\u00e8s un parcours en profondeur.\n\nEn r\u00e9sum\u00e9, cette fonction collecte tous les \u00e9l\u00e9ments d'un document de mani\u00e8re r\u00e9cursive et les retourne dans une liste unique."
  },
  {
    "code": "def xpath(self, query):\n        \"\"\"Run Xpath expression and parse the resulting elements. Don't forget to use the FoLiA namesapace in your expressions, using folia: or the short form f: \"\"\"\n        for result in self.tree.xpath(query,namespaces={'f': 'http://ilk.uvt.nl/folia','folia': 'http://ilk.uvt.nl/folia' }):\n            yield self.parsexml(result)",
    "docstring": "Run Xpath expression and parse the resulting elements. Don't forget to use the FoLiA namesapace in your expressions, using folia: or the short form f:",
    "summary": "Cette fonction, nomm\u00e9e `xpath`, permet d'ex\u00e9cuter une requ\u00eate XPath sur un document XML et de traiter les \u00e9l\u00e9ments r\u00e9sultants. Voici une explication \u00e9tape par \u00e9tape en fran\u00e7ais :\n\n1. **Objectif** : La fonction est con\u00e7ue pour rechercher des \u00e9l\u00e9ments sp\u00e9cifiques dans un document XML en utilisant une expression XPath. XPath est un langage de requ\u00eate utilis\u00e9 pour naviguer dans les arbres XML.\n\n2. **Param\u00e8tre `query`** : La fonction prend en entr\u00e9e une requ\u00eate XPath (`query`), qui est une expression permettant de s\u00e9lectionner des \u00e9l\u00e9ments particuliers dans le document XML.\n\n3. **Utilisation du namespace FoLiA** : La fonction rappelle qu'il faut utiliser le namespace FoLiA (un standard pour l'annotation de donn\u00e9es linguistiques) dans les expressions XPath. Cela se fait en utilisant le pr\u00e9fixe `folia:` ou sa forme courte `f:`.\n\n4. **Ex\u00e9cution de la requ\u00eate** : La fonction utilise la m\u00e9thode `xpath` de l'objet `self.tree` (qui repr\u00e9sente probablement l'arbre XML) pour ex\u00e9cuter la requ\u00eate XPath. Elle sp\u00e9cifie \u00e9galement les namespaces associ\u00e9s aux pr\u00e9fixes `f` et `folia`.\n\n5. **Traitement des r\u00e9sultats** : Pour chaque \u00e9l\u00e9ment trouv\u00e9 (`result`) par la requ\u00eate XPath, la fonction applique une autre m\u00e9thode appel\u00e9e `self.parsexml` pour traiter cet \u00e9l\u00e9ment. Le mot-cl\u00e9 `yield` indique que la fonction est un g\u00e9n\u00e9rateur, ce qui signifie qu'elle retourne les r\u00e9sultats un par un au fur et \u00e0 mesure qu'ils sont trait\u00e9s.\n\n6. **R\u00e9sultat** : La fonction g\u00e9n\u00e8re une s\u00e9quence d'\u00e9l\u00e9ments XML trait\u00e9s, correspondant aux r\u00e9sultats de la requ\u00eate XPath.\n\nEn r\u00e9sum\u00e9, cette fonction permet de rechercher des \u00e9l\u00e9ments dans un document XML en utilisant XPath, en tenant compte du namespace FoLiA, et de les traiter un par un gr\u00e2ce \u00e0 une autre m\u00e9thode."
  }
]