[
  {
    "code": "def addidsuffix(self, idsuffix, recursive = True):\n        \"\"\"Appends a suffix to this element's ID, and optionally to all child IDs as well. There is sually no need to call this directly, invoked implicitly by :meth:`copy`\"\"\"\n        if self.id: self.id += idsuffix\n        if recursive:\n            for e in self:\n                try:\n                    e.addidsuffix(idsuffix, recursive)\n                except Exception:\n                    pass",
    "docstring": "Appends a suffix to this element's ID, and optionally to all child IDs as well. There is sually no need to call this directly, invoked implicitly by :meth:`copy`",
    "summary": "Diese Funktion f\u00fcgt ein Suffix (eine Erg\u00e4nzung) an die ID eines Elements hinzu und kann optional auch die IDs aller untergeordneten Elemente (Kinder) aktualisieren. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Suffix an die eigene ID anh\u00e4ngen**: Wenn das Element eine ID hat, wird das \u00fcbergebene `idsuffix` an diese ID angeh\u00e4ngt.\n   \n2. **Rekursives Aktualisieren der Kinder-IDs**: Wenn der Parameter `recursive` auf `True` gesetzt ist (was standardm\u00e4\u00dfig der Fall ist), durchl\u00e4uft die Funktion alle untergeordneten Elemente und f\u00fchrt die gleiche Aktion (Suffix anh\u00e4ngen) rekursiv f\u00fcr jedes Kind aus.\n\n3. **Fehlerbehandlung**: Falls beim Aktualisieren der Kinder-IDs ein Fehler auftritt, wird dieser ignoriert (durch `pass`).\n\nDiese Funktion wird normalerweise nicht direkt aufgerufen, sondern wird automatisch von der `:meth:`copy``-Methode verwendet, um sicherzustellen, dass kopierte Elemente eindeutige IDs haben."
  },
  {
    "code": "def setparents(self):\n        \"\"\"Correct all parent relations for elements within the scop. There is sually no need to call this directly, invoked implicitly by :meth:`copy`\"\"\"\n        for c in self:\n            if isinstance(c, AbstractElement):\n                c.parent = self\n                c.setparents()",
    "docstring": "Correct all parent relations for elements within the scop. There is sually no need to call this directly, invoked implicitly by :meth:`copy`",
    "summary": "Sicher! Diese Funktion `setparents` korrigiert die Eltern-Kind-Beziehungen zwischen Elementen innerhalb eines bestimmten Bereichs (Scopes). Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Zweck**: Die Funktion stellt sicher, dass jedes Element (`AbstractElement`) innerhalb des aktuellen Bereichs (`self`) den richtigen Eltern (`parent`) zugewiesen bekommt. Dies ist besonders wichtig, wenn Elemente kopiert oder verschoben werden.\n\n2. **Funktionsweise**:\n   - Die Funktion durchl\u00e4uft alle Elemente (`c`) innerhalb von `self`.\n   - Wenn ein Element vom Typ `AbstractElement` ist, wird sein Eltern-Attribut (`c.parent`) auf `self` gesetzt, also auf das aktuelle Objekt.\n   - Anschlie\u00dfend wird die `setparents`-Methode rekursiv f\u00fcr das aktuelle Element (`c`) aufgerufen, um sicherzustellen, dass auch alle seine untergeordneten Elemente korrekt konfiguriert werden.\n\n3. **Anwendung**: Normalerweise muss diese Funktion nicht manuell aufgerufen werden, da sie automatisch durch die `copy`-Methode ausgel\u00f6st wird. Sie dient also als Hilfsfunktion, um die Konsistenz der Hierarchie zu gew\u00e4hrleisten.\n\nZusammengefasst: Die Funktion stellt sicher, dass die Eltern-Kind-Beziehungen in einer Hierarchie von Elementen korrekt sind, insbesondere nach Operationen wie Kopieren."
  },
  {
    "code": "def setdoc(self,newdoc):\n        \"\"\"Set a different document. Usually no need to call this directly, invoked implicitly by :meth:`copy`\"\"\"\n        self.doc = newdoc\n        if self.doc and self.id:\n            self.doc.index[self.id] = self\n        for c in self:\n            if isinstance(c, AbstractElement):\n                c.setdoc(newdoc)",
    "docstring": "Set a different document. Usually no need to call this directly, invoked implicitly by :meth:`copy`",
    "summary": "Sicher! Hier ist eine einfache Erkl\u00e4rung des `setdoc`-Funktion in Deutsch:\n\nDiese Funktion \u00e4ndert das Dokument, mit dem ein Objekt arbeitet. Normalerweise muss man diese Funktion nicht direkt aufrufen, da sie automatisch von der `copy`-Methode verwendet wird.\n\nIm Detail macht die Funktion folgendes:\n\n1. **Dokument aktualisieren**: Sie setzt das aktuelle Dokument (`self.doc`) auf ein neues Dokument (`newdoc`).\n2. **Index aktualisieren**: Wenn das Objekt eine ID hat und das neue Dokument nicht leer ist, wird das Objekt im Index des neuen Dokuments unter seiner ID gespeichert.\n3. **Kind-Elemente aktualisieren**: Die Funktion durchl\u00e4uft alle Kind-Elemente des Objekts. Wenn ein Kind-Element vom Typ `AbstractElement` ist, wird dessen `setdoc`-Methode ebenfalls aufgerufen, um sicherzustellen, dass auch diese Elemente das neue Dokument verwenden.\n\nZusammengefasst sorgt diese Funktion daf\u00fcr, dass das Objekt und alle seine Kind-Elemente mit einem neuen Dokument verkn\u00fcpft werden."
  },
  {
    "code": "def hastext(self,cls='current',strict=True, correctionhandling=CorrectionHandling.CURRENT): #pylint: disable=too-many-return-statements\n        \"\"\"Does this element have text (of the specified class)\n\n        By default, and unlike :meth:`text`, this checks strictly, i.e. the element itself must have the text and it is not inherited from its children.\n\n        Parameters:\n            cls (str): The class of the text content to obtain, defaults to ``current``.\n            strict (bool):  Set this if you are strictly interested in the text explicitly associated with the element, without recursing into children. Defaults to ``True``.\n            correctionhandling: Specifies what text to check for when corrections are encountered. The default is ``CorrectionHandling.CURRENT``, which will retrieve the corrected/current text. You can set this to ``CorrectionHandling.ORIGINAL`` if you want the text prior to correction, and ``CorrectionHandling.EITHER`` if you don't care.\n\n        Returns:\n            bool\n        \"\"\"\n        if not self.PRINTABLE: #only printable elements can hold text\n            return False\n        elif self.TEXTCONTAINER:\n            return True\n        else:\n            try:\n                if strict:\n                    self.textcontent(cls, correctionhandling) #will raise NoSuchTextException when not found\n                    return True\n                else:\n                    #Check children\n                    for e in self:\n                        if e.PRINTABLE and not isinstance(e, TextContent):\n                            if e.hastext(cls, strict, correctionhandling):\n                                return True\n\n                    self.textcontent(cls, correctionhandling)  #will raise NoSuchTextException when not found\n                    return True\n            except NoSuchText:\n                return False",
    "docstring": "Does this element have text (of the specified class)\n\n        By default, and unlike :meth:`text`, this checks strictly, i.e. the element itself must have the text and it is not inherited from its children.\n\n        Parameters:\n            cls (str): The class of the text content to obtain, defaults to ``current``.\n            strict (bool):  Set this if you are strictly interested in the text explicitly associated with the element, without recursing into children. Defaults to ``True``.\n            correctionhandling: Specifies what text to check for when corrections are encountered. The default is ``CorrectionHandling.CURRENT``, which will retrieve the corrected/current text. You can set this to ``CorrectionHandling.ORIGINAL`` if you want the text prior to correction, and ``CorrectionHandling.EITHER`` if you don't care.\n\n        Returns:\n            bool",
    "summary": "Dies ist eine Erkl\u00e4rung der Funktion `hastext` auf Deutsch:\n\nDie Funktion `hastext` \u00fcberpr\u00fcft, ob ein bestimmtes Element (z.B. ein Teil eines Dokuments oder einer Webseite) einen bestimmten Text enth\u00e4lt. Hier sind die wichtigsten Punkte:\n\n1. **Standardverhalten**: Standardm\u00e4\u00dfig \u00fcberpr\u00fcft die Funktion streng, ob das Element selbst den Text enth\u00e4lt, und nicht, ob der Text von seinen untergeordneten Elementen (Kindern) geerbt wird.\n\n2. **Parameter**:\n   - `cls`: Der Typ oder die Klasse des Textes, nach dem gesucht werden soll. Standardm\u00e4\u00dfig ist dies `'current'`.\n   - `strict`: Ein Schalter, der angibt, ob die \u00dcberpr\u00fcfung streng sein soll (nur der Text des Elements selbst) oder ob auch die untergeordneten Elemente durchsucht werden sollen. Standardm\u00e4\u00dfig ist dies `True` (streng).\n   - `correctionhandling`: Gibt an, wie mit Korrekturen umgegangen werden soll. Es gibt drei Optionen:\n     - `CorrectionHandling.CURRENT`: \u00dcberpr\u00fcft den korrigierten/aktuellen Text.\n     - `CorrectionHandling.ORIGINAL`: \u00dcberpr\u00fcft den Text vor der Korrektur.\n     - `CorrectionHandling.EITHER`: Ist egal, ob der Text korrigiert wurde oder nicht.\n\n3. **R\u00fcckgabewert**: Die Funktion gibt `True` zur\u00fcck, wenn das Element den gesuchten Text enth\u00e4lt, und `False`, wenn nicht.\n\n4. **Logik**:\n   - Wenn das Element nicht druckbar ist (d.h. es kann keinen Text enthalten), gibt die Funktion sofort `False` zur\u00fcck.\n   - Wenn das Element ein Textcontainer ist, gibt die Funktion sofort `True` zur\u00fcck.\n   - Andernfalls wird versucht, den Text zu finden:\n     - Wenn `strict` aktiviert ist, wird nur der Text des Elements selbst \u00fcberpr\u00fcft.\n     - Wenn `strict` deaktiviert ist, werden auch die untergeordneten Elemente durchsucht.\n   - Wenn der Text nicht gefunden wird, gibt die Funktion `False` zur\u00fcck.\n\nZusammenfassend \u00fcberpr\u00fcft die Funktion `hastext`, ob ein Element einen bestimmten Text enth\u00e4lt, wobei sie verschiedene Optionen bietet, um die Suche anzupassen."
  },
  {
    "code": "def hasphon(self,cls='current',strict=True,correctionhandling=CorrectionHandling.CURRENT): #pylint: disable=too-many-return-statements\n        \"\"\"Does this element have phonetic content (of the specified class)\n\n        By default, and unlike :meth:`phon`, this checks strictly, i.e. the element itself must have the phonetic content and it is not inherited from its children.\n\n        Parameters:\n            cls (str): The class of the phonetic content to obtain, defaults to ``current``.\n            strict (bool):  Set this if you are strictly interested in the phonetic content explicitly associated with the element, without recursing into children. Defaults to ``True``.\n            correctionhandling: Specifies what phonetic content to check for when corrections are encountered. The default is ``CorrectionHandling.CURRENT``, which will retrieve the corrected/current phonetic content. You can set this to ``CorrectionHandling.ORIGINAL`` if you want the phonetic content prior to correction, and ``CorrectionHandling.EITHER`` if you don't care.\n\n        Returns:\n            bool\n        \"\"\"\n        if not self.SPEAKABLE: #only printable elements can hold text\n            return False\n        elif self.PHONCONTAINER:\n            return True\n        else:\n            try:\n                if strict:\n                    self.phoncontent(cls, correctionhandling)\n                    return True\n                else:\n                    #Check children\n                    for e in self:\n                        if e.SPEAKABLE and not isinstance(e, PhonContent):\n                            if e.hasphon(cls, strict, correctionhandling):\n                                return True\n\n                    self.phoncontent(cls)  #will raise NoSuchTextException when not found\n                    return True\n            except NoSuchPhon:\n                return False",
    "docstring": "Does this element have phonetic content (of the specified class)\n\n        By default, and unlike :meth:`phon`, this checks strictly, i.e. the element itself must have the phonetic content and it is not inherited from its children.\n\n        Parameters:\n            cls (str): The class of the phonetic content to obtain, defaults to ``current``.\n            strict (bool):  Set this if you are strictly interested in the phonetic content explicitly associated with the element, without recursing into children. Defaults to ``True``.\n            correctionhandling: Specifies what phonetic content to check for when corrections are encountered. The default is ``CorrectionHandling.CURRENT``, which will retrieve the corrected/current phonetic content. You can set this to ``CorrectionHandling.ORIGINAL`` if you want the phonetic content prior to correction, and ``CorrectionHandling.EITHER`` if you don't care.\n\n        Returns:\n            bool",
    "summary": "Dies ist eine Funktion in Python, die \u00fcberpr\u00fcft, ob ein bestimmtes Element phonetischen Inhalt (also gesprochenen Text) einer bestimmten Klasse enth\u00e4lt. Hier ist eine einfache Erkl\u00e4rung in Deutsch:\n\n**Funktion: `hasphon`**\n\n**Zweck:**  \nDie Funktion pr\u00fcft, ob ein Element phonetischen Inhalt (gesprochenen Text) hat, und zwar optional in einer bestimmten Kategorie (Klasse).\n\n**Parameter:**\n- `cls` (Standard: `'current'`): Die Kategorie des phonetischen Inhalts, die \u00fcberpr\u00fcft werden soll.\n- `strict` (Standard: `True`): Wenn `True`, wird nur der phonetische Inhalt des Elements selbst \u00fcberpr\u00fcft, nicht der seiner untergeordneten Elemente.\n- `correctionhandling` (Standard: `CorrectionHandling.CURRENT`): Legt fest, ob der urspr\u00fcngliche oder der korrigierte phonetische Inhalt \u00fcberpr\u00fcft werden soll.\n\n**Funktionsweise:**\n1. **Nicht-sprechbare Elemente:** Wenn das Element nicht sprechbar ist (z. B. ein unsichtbares Element), gibt die Funktion sofort `False` zur\u00fcck.\n2. **PhonContainer:** Wenn das Element ein PhonContainer ist (ein Element, das phonetischen Inhalt direkt speichern kann), gibt die Funktion `True` zur\u00fcck.\n3. **Strenge \u00dcberpr\u00fcfung:** Wenn `strict` aktiviert ist, wird versucht, den phonetischen Inhalt des Elements direkt abzurufen. Wenn dieser vorhanden ist, gibt die Funktion `True` zur\u00fcck, sonst `False`.\n4. **Nicht-strenge \u00dcberpr\u00fcfung:** Wenn `strict` deaktiviert ist, wird auch in den untergeordneten Elementen nach phonetischem Inhalt gesucht. Wenn ein untergeordnetes Element phonetischen Inhalt hat, gibt die Funktion `True` zur\u00fcck.\n\n**R\u00fcckgabewert:**  \nDie Funktion gibt `True` zur\u00fcck, wenn das Element (oder seine untergeordneten Elemente) phonetischen Inhalt der angegebenen Klasse hat, sonst `False`.\n\n**Zusammenfassung:**  \nDie Funktion pr\u00fcft, ob ein Element oder seine untergeordneten Elemente gesprochenen Text (phonetischen Inhalt) in einer bestimmten Kategorie enthalten, und zwar entweder streng (nur das Element selbst) oder nicht-streng (auch untergeordnete Elemente)."
  },
  {
    "code": "def settext(self, text, cls='current'):\n        \"\"\"Set the text for this element.\n\n        Arguments:\n            text (str): The text\n            cls (str): The class of the text, defaults to ``current`` (leave this unless you know what you are doing). There may be only one text content element of each class associated with the element.\n        \"\"\"\n        self.replace(TextContent, value=text, cls=cls)",
    "docstring": "Set the text for this element.\n\n        Arguments:\n            text (str): The text\n            cls (str): The class of the text, defaults to ``current`` (leave this unless you know what you are doing). There may be only one text content element of each class associated with the element.",
    "summary": "Sicher! Diese Funktion `settext` aktualisiert den Text eines bestimmten Elements. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Text festlegen**: Der Parameter `text` ist der neue Text, den du f\u00fcr das Element festlegen m\u00f6chtest.  \n2. **Klasse (cls)**: Der Parameter `cls` gibt an, zu welcher Kategorie oder Klasse der Text geh\u00f6rt. Standardm\u00e4\u00dfig ist dies `'current'`, aber du kannst es \u00e4ndern, wenn du eine spezifische Klasse verwenden m\u00f6chtest. Beachte jedoch, dass es pro Element nur einen Textinhalt pro Klasse geben darf.  \n\nDie Funktion ersetzt den bestehenden Textinhalt (`TextContent`) des Elements durch den neuen Text und die angegebene Klasse.  \n\nZusammengefasst: Sie aktualisiert den Text eines Elements und optional die zugeh\u00f6rige Klasse."
  },
  {
    "code": "def setdocument(self, doc):\n        \"\"\"Associate a document with this element.\n\n        Arguments:\n            doc (:class:`Document`): A document\n\n        Each element must be associated with a FoLiA document.\n        \"\"\"\n        assert isinstance(doc, Document)\n\n        if not self.doc:\n            self.doc = doc\n            if self.id:\n                if self.id in doc:\n                    raise DuplicateIDError(self.id)\n                else:\n                    self.doc.index[id] = self\n\n        for e in self: #recursive for all children\n            if isinstance(e,AbstractElement): e.setdocument(doc)",
    "docstring": "Associate a document with this element.\n\n        Arguments:\n            doc (:class:`Document`): A document\n\n        Each element must be associated with a FoLiA document.",
    "summary": "Sicher! Diese Funktion `setdocument` dient dazu, ein Dokument mit einem bestimmten Element zu verkn\u00fcpfen. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Zweck**: Die Funktion stellt sicher, dass jedes Element mit einem FoLiA-Dokument verkn\u00fcpft ist. FoLiA (Format for Linguistic Annotation) ist ein Standard f\u00fcr die Annotation von linguistischen Daten.\n\n2. **Eingabe**: Die Funktion erwartet ein Argument `doc`, das ein Objekt vom Typ `Document` ist. Dieses Dokument wird mit dem aktuellen Element verkn\u00fcpft.\n\n3. **\u00dcberpr\u00fcfung**: Es wird \u00fcberpr\u00fcft, ob `doc` tats\u00e4chlich ein `Document`-Objekt ist. Wenn nicht, wird ein Fehler ausgel\u00f6st.\n\n4. **Verkn\u00fcpfung**: Wenn das Element noch nicht mit einem Dokument verkn\u00fcpft ist, wird das \u00fcbergebene Dokument (`doc`) mit dem Element verkn\u00fcpft.\n\n5. **ID-\u00dcberpr\u00fcfung**: Wenn das Element eine ID hat, wird \u00fcberpr\u00fcft, ob diese ID bereits im Dokument existiert. Wenn ja, wird ein `DuplicateIDError` ausgel\u00f6st, da eine doppelte ID nicht erlaubt ist.\n\n6. **Indexierung**: Wenn die ID noch nicht im Dokument existiert, wird das Element im Index des Dokuments unter seiner ID gespeichert.\n\n7. **Rekursion**: Die Funktion wird rekursiv f\u00fcr alle untergeordneten Elemente (Kinder) des aktuellen Elements aufgerufen, um sicherzustellen, dass auch diese mit dem Dokument verkn\u00fcpft werden.\n\nZusammengefasst stellt die Funktion sicher, dass ein Element und alle seine untergeordneten Elemente korrekt mit einem FoLiA-Dokument verkn\u00fcpft sind und dass dabei keine doppelten IDs auftreten."
  },
  {
    "code": "def addable(Class, parent, set=None, raiseexceptions=True):\n        \"\"\"Tests whether a new element of this class can be added to the parent.\n\n        This method is mostly for internal use.\n        This will use the ``OCCURRENCES`` property, but may be overidden by subclasses for more customised behaviour.\n\n        Parameters:\n            parent (:class:`AbstractElement`): The element that is being added to\n            set (str or None): The set\n            raiseexceptions (bool): Raise an exception if the element can't be added?\n\n        Returns:\n            bool\n\n        Raises:\n            ValueError\n         \"\"\"\n\n\n        if not parent.__class__.accepts(Class, raiseexceptions, parent):\n            return False\n\n        if Class.OCCURRENCES > 0:\n            #check if the parent doesn't have too many already\n            count = parent.count(Class,None,True,[True, AbstractStructureElement]) #never descend into embedded structure annotatioton\n            if count >= Class.OCCURRENCES:\n                if raiseexceptions:\n                    if parent.id:\n                        extra = ' (id=' + parent.id + ')'\n                    else:\n                        extra = ''\n                    raise DuplicateAnnotationError(\"Unable to add another object of type \" + Class.__name__ + \" to \" + parent.__class__.__name__ + \" \" + extra + \". There are already \" + str(count) + \" instances of this class, which is the maximum.\")\n                else:\n                    return False\n\n        if Class.OCCURRENCES_PER_SET > 0 and set and Class.REQUIRED_ATTRIBS and Attrib.CLASS in Class.REQUIRED_ATTRIBS:\n            count = parent.count(Class,set,True, [True, AbstractStructureElement])\n            if count >= Class.OCCURRENCES_PER_SET:\n                if raiseexceptions:\n                    if parent.id:\n                        extra = ' (id=' + parent.id + ')'\n                    else:\n                        extra = ''\n                    raise DuplicateAnnotationError(\"Unable to add another object of set \" + set + \" and type \" + Class.__name__ + \" to \" + parent.__class__.__name__ + \" \" + extra + \". There are already \" + str(count) + \" instances of this class, which is the maximum for the set.\")\n                else:\n                    return False\n\n\n\n        return True",
    "docstring": "Tests whether a new element of this class can be added to the parent.\n\n        This method is mostly for internal use.\n        This will use the ``OCCURRENCES`` property, but may be overidden by subclasses for more customised behaviour.\n\n        Parameters:\n            parent (:class:`AbstractElement`): The element that is being added to\n            set (str or None): The set\n            raiseexceptions (bool): Raise an exception if the element can't be added?\n\n        Returns:\n            bool\n\n        Raises:\n            ValueError",
    "summary": "Diese Funktion, `addable`, \u00fcberpr\u00fcft, ob ein neues Element einer bestimmten Klasse (`Class`) zu einem \u00fcbergeordneten Element (`parent`) hinzugef\u00fcgt werden kann. Sie wird haupts\u00e4chlich intern verwendet und basiert auf der `OCCURRENCES`-Eigenschaft der Klasse, kann aber von Unterklassen \u00fcberschrieben werden, um ein benutzerdefinierteres Verhalten zu erm\u00f6glichen.\n\nHier ist eine Schritt-f\u00fcr-Schritt-Erkl\u00e4rung:\n\n1. **\u00dcberpr\u00fcfung der Akzeptanz**: Zuerst wird gepr\u00fcft, ob die Klasse des \u00fcbergeordneten Elements (`parent.__class__`) die angegebene Klasse (`Class`) akzeptiert. Wenn nicht, gibt die Funktion `False` zur\u00fcck.\n\n2. **\u00dcberpr\u00fcfung der maximalen Anzahl von Instanzen**: Wenn die Klasse eine maximale Anzahl von Instanzen (`OCCURRENCES`) hat, wird \u00fcberpr\u00fcft, ob das \u00fcbergeordnete Element bereits die maximale Anzahl dieser Instanzen enth\u00e4lt. Wenn ja, wird entweder eine Ausnahme ausgel\u00f6st (wenn `raiseexceptions=True`) oder `False` zur\u00fcckgegeben.\n\n3. **\u00dcberpr\u00fcfung der maximalen Anzahl von Instanzen pro Set**: Wenn die Klasse eine maximale Anzahl von Instanzen pro Set (`OCCURRENCES_PER_SET`) hat und ein Set angegeben ist, wird \u00fcberpr\u00fcft, ob das \u00fcbergeordnete Element bereits die maximale Anzahl dieser Instanzen f\u00fcr das angegebene Set enth\u00e4lt. Auch hier wird entweder eine Ausnahme ausgel\u00f6st oder `False` zur\u00fcckgegeben, wenn die Grenze \u00fcberschritten ist.\n\n4. **R\u00fcckgabe von True**: Wenn alle \u00dcberpr\u00fcfungen bestanden sind, gibt die Funktion `True` zur\u00fcck, was bedeutet, dass das neue Element hinzugef\u00fcgt werden kann.\n\nZusammenfassend \u00fcberpr\u00fcft diese Funktion, ob ein neues Element einer bestimmten Klasse zu einem \u00fcbergeordneten Element hinzugef\u00fcgt werden kann, ohne die definierten Einschr\u00e4nkungen (wie maximale Anzahl von Instanzen) zu verletzen. Wenn alles in Ordnung ist, gibt sie `True` zur\u00fcck; andernfalls wird entweder eine Ausnahme ausgel\u00f6st oder `False` zur\u00fcckgegeben."
  },
  {
    "code": "def postappend(self):\n        \"\"\"This method will be called after an element is added to another and does some checks.\n\n        It can do extra checks and if necessary raise exceptions to prevent addition. By default makes sure the right document is associated.\n\n        This method is mostly for internal use.\n        \"\"\"\n\n        #If the element was not associated with a document yet, do so now (and for all unassociated children:\n        if not self.doc and self.parent.doc:\n            self.setdocument(self.parent.doc)\n\n        if self.doc and self.doc.deepvalidation:\n            self.deepvalidation()",
    "docstring": "This method will be called after an element is added to another and does some checks.\n\n        It can do extra checks and if necessary raise exceptions to prevent addition. By default makes sure the right document is associated.\n\n        This method is mostly for internal use.",
    "summary": "Sicher! Hier ist eine einfache Erkl\u00e4rung der Funktion `postappend` auf Deutsch:\n\nDie Funktion `postappend` wird aufgerufen, **nachdem** ein Element zu einem anderen hinzugef\u00fcgt wurde. Sie f\u00fchrt einige \u00dcberpr\u00fcfungen durch, um sicherzustellen, dass alles korrekt ist. \n\nIm Detail macht sie Folgendes:\n\n1. **Dokumentzuordnung**: Wenn das hinzugef\u00fcgte Element noch keinem Dokument zugeordnet ist, aber sein \u00fcbergeordnetes Element (der \"Elternteil\") einem Dokument zugeordnet ist, wird das Element automatisch diesem Dokument zugeordnet. Das Gleiche gilt f\u00fcr alle untergeordneten Elemente, die ebenfalls noch keinem Dokument zugeordnet sind.\n\n2. **Tiefenpr\u00fcfung**: Wenn das Dokument, zu dem das Element geh\u00f6rt, eine sogenannte \"Tiefenpr\u00fcfung\" (`deepvalidation`) aktiviert hat, wird diese Pr\u00fcfung durchgef\u00fchrt. Dabei wird sichergestellt, dass alles im Dokument korrekt und konsistent ist.\n\nDiese Funktion ist haupts\u00e4chlich f\u00fcr interne Zwecke gedacht und hilft dabei, die Konsistenz und Korrektheit der Datenstruktur zu gew\u00e4hrleisten."
  },
  {
    "code": "def deepvalidation(self):\n        \"\"\"Perform deep validation of this element.\n\n        Raises:\n            :class:`DeepValidationError`\n        \"\"\"\n        if self.doc and self.doc.deepvalidation and self.set and self.set[0] != '_':\n            try:\n                self.doc.setdefinitions[self.set].testclass(self.cls)\n            except KeyError:\n                if self.cls and not self.doc.allowadhocsets:\n                    raise DeepValidationError(\"Set definition \" + self.set + \" for \" + self.XMLTAG + \" not loaded!\")\n            except DeepValidationError as e:\n                errormsg =  str(e) + \" (in set \" + self.set+\" for \" + self.XMLTAG\n                if self.id:\n                    errormsg += \" with ID \" + self.id\n                errormsg += \")\"\n                raise DeepValidationError(errormsg)",
    "docstring": "Perform deep validation of this element.\n\n        Raises:\n            :class:`DeepValidationError`",
    "summary": "Sicher! Hier ist eine einfache Erkl\u00e4rung der Funktion `deepvalidation` auf Deutsch:\n\nDiese Funktion \u00fcberpr\u00fcft ein Element gr\u00fcndlich (oder \"tiefgehend\") auf seine G\u00fcltigkeit. Sie stellt sicher, dass das Element korrekt eingerichtet ist und den erwarteten Regeln entspricht. Wenn etwas nicht stimmt, wirft sie einen Fehler (`DeepValidationError`), der detailliert beschreibt, was schiefgelaufen ist.\n\nGenauer gesagt:\n1. **Bedingungen pr\u00fcfen**: Die Funktion pr\u00fcft, ob bestimmte Bedingungen erf\u00fcllt sind, wie z. B. ob ein Dokument (`self.doc`) vorhanden ist, ob eine tiefe Validierung aktiviert ist (`self.doc.deepvalidation`), und ob ein bestimmter Satz (`self.set`) definiert ist und nicht mit einem Unterstrich (`_`) beginnt.\n2. **Test durchf\u00fchren**: Sie versucht, eine Testklasse (`testclass`) auszuf\u00fchren, die mit dem Satz (`self.set`) verkn\u00fcpft ist, um sicherzustellen, dass das Element (`self.cls`) den Anforderungen entspricht.\n3. **Fehlerbehandlung**: Wenn etwas schiefgeht (z. B. der Satz ist nicht definiert oder der Test schl\u00e4gt fehl), wird ein detaillierter Fehler geworfen, der den Kontext (z. B. Satzname, Element-ID) enth\u00e4lt.\n\nZusammenfassend sorgt diese Funktion daf\u00fcr, dass ein Element alle notwendigen Regeln erf\u00fcllt, und meldet klar, wenn etwas nicht in Ordnung ist."
  },
  {
    "code": "def findreplaceables(Class, parent, set=None,**kwargs):\n        \"\"\"Internal method to find replaceable elements. Auxiliary function used by :meth:`AbstractElement.replace`. Can be overriden for more fine-grained control.\"\"\"\n        return list(parent.select(Class,set,False))",
    "docstring": "Internal method to find replaceable elements. Auxiliary function used by :meth:`AbstractElement.replace`. Can be overriden for more fine-grained control.",
    "summary": "Sicher! Diese Funktion, `findreplaceables`, ist eine interne Methode, die dazu dient, austauschbare Elemente in einer bestimmten Struktur zu finden. Hier ist eine einfache Erkl\u00e4rung auf Deutsch:\n\nDiese Funktion sucht nach Elementen einer bestimmten Klasse (`Class`) innerhalb eines \u00fcbergeordneten Elements (`parent`). Sie kann optional einen Satz von Kriterien (`set`) verwenden, um die Suche weiter einzugrenzen. Das Ergebnis ist eine Liste von Elementen, die durch andere ersetzt werden k\u00f6nnen.\n\nGenauer gesagt:\n\n- **`Class`**: Die Art von Elementen, nach denen gesucht wird (z. B. ein bestimmter Typ von Objekt oder Element).\n- **`parent`**: Das \u00fcbergeordnete Element, in dem die Suche durchgef\u00fchrt wird.\n- **`set`**: Ein optionaler Parameter, der zus\u00e4tzliche Kriterien f\u00fcr die Suche festlegen kann.\n- **`**kwargs`**: Zus\u00e4tzliche optionale Parameter, die bei Bedarf \u00fcbergeben werden k\u00f6nnen.\n\nDie Funktion gibt eine Liste von Elementen zur\u00fcck, die den angegebenen Kriterien entsprechen und potenziell durch andere Elemente ersetzt werden k\u00f6nnen. Sie wird als Hilfsfunktion von einer anderen Methode (`AbstractElement.replace`) verwendet, kann aber auch angepasst werden, um eine feinere Kontrolle \u00fcber den Suchprozess zu erm\u00f6glichen.\n\nZusammenfassend: Diese Funktion hilft dabei, bestimmte Elemente in einer Struktur zu finden, die durch andere ersetzt werden k\u00f6nnen."
  },
  {
    "code": "def updatetext(self):\n        \"\"\"Recompute textual value based on the text content of the children. Only supported on elements that are a ``TEXTCONTAINER``\"\"\"\n        if self.TEXTCONTAINER:\n            s = \"\"\n            for child in self:\n                if isinstance(child, AbstractElement):\n                    child.updatetext()\n                    s += child.text()\n                elif isstring(child):\n                    s += child\n            self.data = [s]",
    "docstring": "Recompute textual value based on the text content of the children. Only supported on elements that are a ``TEXTCONTAINER``",
    "summary": "Sicher! Diese Funktion `updatetext` aktualisiert den Textinhalt eines Elements, das als `TEXTCONTAINER` markiert ist. Hier ist eine einfache Erkl\u00e4rung in Deutsch:\n\n1. **\u00dcberpr\u00fcfung des `TEXTCONTAINER`**: Die Funktion pr\u00fcft zuerst, ob das aktuelle Element ein `TEXTCONTAINER` ist. Wenn nicht, passiert nichts.\n\n2. **Initialisierung eines leeren Strings**: Ein leerer String `s` wird erstellt, um den neuen Textinhalt zu speichern.\n\n3. **Durchlaufen der Kind-Elemente**: Die Funktion durchl\u00e4uft alle Kind-Elemente des aktuellen Elements.\n   \n   - **Wenn das Kind-Element ein `AbstractElement` ist**:  \n     - Es wird die `updatetext`-Methode des Kind-Elements aufgerufen, um dessen Textinhalt zu aktualisieren.  \n     - Der Text des Kind-Elements wird zum String `s` hinzugef\u00fcgt.  \n   - **Wenn das Kind-Element ein einfacher String ist**:  \n     - Der String wird direkt zum String `s` hinzugef\u00fcgt.\n\n4. **Speichern des neuen Textinhalts**: Nachdem alle Kind-Elemente verarbeitet wurden, wird der zusammengesetzte String `s` als neuer Textinhalt (`self.data`) des aktuellen Elements gespeichert.\n\nZusammengefasst aktualisiert diese Funktion den Textinhalt eines `TEXTCONTAINER`-Elements, indem sie die Textinhalte seiner Kind-Elemente sammelt und zusammenf\u00fcgt."
  },
  {
    "code": "def replace(self, child, *args, **kwargs):\n        \"\"\"Appends a child element like ``append()``, but replaces any existing child element of the same type and set. If no such child element exists, this will act the same as append()\n\n        Keyword arguments:\n            alternative (bool): If set to True, the *replaced* element will be made into an alternative. Simply use :meth:`AbstractElement.append` if you want the added element\n            to be an alternative.\n\n        See :meth:`AbstractElement.append` for more information and all parameters.\n        \"\"\"\n\n        if 'set' in kwargs:\n            set = kwargs['set']\n            del kwargs['set']\n        else:\n            try:\n                set = child.set\n            except AttributeError:\n                set = None\n\n        if inspect.isclass(child):\n            Class = child\n            replace = Class.findreplaceables(self, set, **kwargs)\n        elif (self.TEXTCONTAINER or self.PHONCONTAINER) and isstring(child):\n            #replace will replace ALL text content, removing text markup along the way!\n            self.data = []\n            return self.append(child, *args,**kwargs)\n        else:\n            Class = child.__class__\n            kwargs['instance'] = child\n            replace = Class.findreplaceables(self,set,**kwargs)\n            del kwargs['instance']\n\n        kwargs['set'] = set #was deleted temporarily for findreplaceables\n\n        if len(replace) == 0:\n            #nothing to replace, simply call append\n            if 'alternative' in kwargs:\n                del kwargs['alternative'] #has other meaning in append()\n            return self.append(child, *args, **kwargs)\n        elif len(replace) > 1:\n            raise Exception(\"Unable to replace. Multiple candidates found, unable to choose.\")\n        elif len(replace) == 1:\n            if 'alternative' in kwargs and kwargs['alternative']:\n                #old version becomes alternative\n                if replace[0] in self.data:\n                    self.data.remove(replace[0])\n                alt = self.append(Alternative)\n                alt.append(replace[0])\n                del kwargs['alternative'] #has other meaning in append()\n            else:\n                #remove old version competely\n                self.remove(replace[0])\n            e = self.append(child, *args, **kwargs)\n            self.updatetext()\n            return e",
    "docstring": "Appends a child element like ``append()``, but replaces any existing child element of the same type and set. If no such child element exists, this will act the same as append()\n\n        Keyword arguments:\n            alternative (bool): If set to True, the *replaced* element will be made into an alternative. Simply use :meth:`AbstractElement.append` if you want the added element\n            to be an alternative.\n\n        See :meth:`AbstractElement.append` for more information and all parameters.",
    "summary": "Dieser Code ist eine Funktion namens `replace`, die Teil einer Klasse (wahrscheinlich `AbstractElement`) ist. Sie dient dazu, ein Kind-Element in einer Struktur zu ersetzen, \u00e4hnlich wie die `append()`-Funktion, aber mit einigen zus\u00e4tzlichen Funktionen.\n\n**Hier ist eine einfache Erkl\u00e4rung, was die Funktion tut:**\n\n1. **\u00dcberpr\u00fcfen des Kind-Elements und seiner Eigenschaften**: Die Funktion pr\u00fcft, ob das Kind-Element eine Klasse ist oder ein Objekt, und ermittelt seine Eigenschaften wie den `set`-Wert.\n\n2. **Suchen nach ersetzbaren Elementen**: Sie sucht nach Elementen in der Struktur, die durch das neue Kind-Element ersetzt werden k\u00f6nnen. Diese Elemente m\u00fcssen den gleichen Typ und `set`-Wert haben.\n\n3. **Ersetzen oder Hinzuf\u00fcgen**:\n   - Wenn keine ersetzbaren Elemente gefunden werden, verh\u00e4lt sich die Funktion wie `append()` und f\u00fcgt das neue Element einfach hinzu.\n   - Wenn genau ein ersetzbares Element gefunden wird, wird es durch das neue Element ersetzt. Wenn das Keyword-Argument `alternative` auf `True` gesetzt ist, wird das alte Element in eine Alternative umgewandelt, anstatt vollst\u00e4ndig entfernt zu werden.\n   - Wenn mehrere ersetzbare Elemente gefunden werden, wird eine Ausnahme ausgel\u00f6st, da die Funktion nicht entscheiden kann, welches Element ersetzt werden soll.\n\n4. **Aktualisieren der Struktur**: Nach dem Ersetzen oder Hinzuf\u00fcgen wird die Struktur aktualisiert, insbesondere der Textinhalt (`updatetext()`).\n\n**Zusammenfassend**: Die `replace`-Funktion erm\u00f6glicht es, ein Kind-Element in einer Struktur zu ersetzen, wobei sie intelligente Entscheidungen trifft, ob und wie das Element ersetzt werden soll. Sie bietet auch die M\u00f6glichkeit, das ersetzte Element in eine Alternative umzuwandeln, anstatt es vollst\u00e4ndig zu entfernen."
  },
  {
    "code": "def ancestors(self, Class=None):\n        \"\"\"Generator yielding all ancestors of this element, effectively back-tracing its path to the root element. A tuple of multiple classes may be specified.\n\n        Arguments:\n            *Class: The class or classes (:class:`AbstractElement` or subclasses). Not instances!\n\n        Yields:\n            elements (instances derived from :class:`AbstractElement`)\n        \"\"\"\n        e = self\n        while e:\n            if e.parent:\n                e = e.parent\n                if not Class or isinstance(e,Class):\n                    yield e\n                elif isinstance(Class, tuple):\n                    for C in Class:\n                        if isinstance(e,C):\n                            yield e\n            else:\n                break",
    "docstring": "Generator yielding all ancestors of this element, effectively back-tracing its path to the root element. A tuple of multiple classes may be specified.\n\n        Arguments:\n            *Class: The class or classes (:class:`AbstractElement` or subclasses). Not instances!\n\n        Yields:\n            elements (instances derived from :class:`AbstractElement`)",
    "summary": "Sicher! Diese Funktion `ancestors` durchl\u00e4uft alle Vorfahren (Elternelemente) eines bestimmten Elements in einer Baumstruktur, bis sie das Wurzelelement erreicht. Hier ist eine einfache Erkl\u00e4rung auf Deutsch:\n\n**Was die Funktion tut:**\n1. **Eingabe:** Die Funktion nimmt optional eine Klasse oder ein Tupel von Klassen entgegen (z. B. `AbstractElement` oder abgeleitete Klassen).  \n2. **Durchlauf:** Sie beginnt beim aktuellen Element (`self`) und bewegt sich schrittweise zu dessen Eltern (`e.parent`), bis sie das Wurzelelement (ein Element ohne Eltern) erreicht.  \n3. **Filterung:** Wenn eine Klasse angegeben wurde, gibt die Funktion nur die Elemente zur\u00fcck, die von dieser Klasse oder einer der angegebenen Klassen abgeleitet sind.  \n4. **Ausgabe:** Die Funktion gibt jedes gefundene Vorfahrenelement nacheinander zur\u00fcck (als Generator).  \n\n**Zusammenfassung:**  \nDie Funktion durchsucht den Pfad vom aktuellen Element zum Wurzelelement und liefert alle Vorfahren, die den angegebenen Klassen entsprechen (falls welche angegeben wurden). Wenn keine Klasse angegeben ist, werden alle Vorfahren zur\u00fcckgegeben.  \n\n**Beispiel:**  \nAngenommen, du hast eine Baumstruktur wie `A \u2192 B \u2192 C \u2192 D`, und `D` ruft `ancestors(Class=B)` auf, dann gibt die Funktion `B` und `A` zur\u00fcck (da `B` und `A` Vorfahren von `D` sind und `B` der angegebenen Klasse entspricht)."
  },
  {
    "code": "def ancestor(self, *Classes):\n        \"\"\"Find the most immediate ancestor of the specified type, multiple classes may be specified.\n\n        Arguments:\n            *Classes: The possible classes (:class:`AbstractElement` or subclasses) to select from. Not instances!\n\n        Example::\n\n            paragraph = word.ancestor(folia.Paragraph)\n        \"\"\"\n        for e in self.ancestors(tuple(Classes)):\n            return e\n        raise NoSuchAnnotation",
    "docstring": "Find the most immediate ancestor of the specified type, multiple classes may be specified.\n\n        Arguments:\n            *Classes: The possible classes (:class:`AbstractElement` or subclasses) to select from. Not instances!\n\n        Example::\n\n            paragraph = word.ancestor(folia.Paragraph)",
    "summary": "Diese Funktion `ancestor` sucht den n\u00e4chsten Vorfahren (Elternelement) eines bestimmten Typs in einer Hierarchie von Elementen. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Eingabe**: Die Funktion nimmt eine oder mehrere Klassen (`*Classes`) als Argumente entgegen. Diese Klassen m\u00fcssen von `AbstractElement` abgeleitet sein oder Unterklassen davon sein. Es geht also nicht um Instanzen, sondern um die Klassen selbst.\n\n2. **Funktionsweise**: Die Funktion durchl\u00e4uft die Vorfahren (Elternelemente) des aktuellen Elements (`self`) und pr\u00fcft, ob einer von ihnen eine Instanz einer der angegebenen Klassen ist. Sobald ein passender Vorfahre gefunden wird, wird dieser zur\u00fcckgegeben.\n\n3. **Ausgabe**: Wenn ein passender Vorfahre gefunden wird, wird dieser zur\u00fcckgegeben. Wenn kein passender Vorfahre gefunden wird, wird eine `NoSuchAnnotation`-Ausnahme ausgel\u00f6st.\n\n4. **Beispiel**: Im Beispiel wird der n\u00e4chste Vorfahre des Elements `word` gesucht, der vom Typ `folia.Paragraph` ist. Wenn ein solcher Vorfahre gefunden wird, wird er in der Variablen `paragraph` gespeichert.\n\nZusammengefasst: Die Funktion sucht den n\u00e4chsten Vorfahren eines Elements, der einer bestimmten Klasse entspricht, und gibt ihn zur\u00fcck. Wenn kein solcher Vorfahre gefunden wird, wird ein Fehler ausgel\u00f6st."
  },
  {
    "code": "def xml(self, attribs = None,elements = None, skipchildren = False):\n        \"\"\"Serialises the FoLiA element and all its contents to XML.\n\n        Arguments are mostly for internal use.\n\n        Returns:\n            an lxml.etree.Element\n\n        See also:\n            :meth:`AbstractElement.xmlstring` - for direct string output\n        \"\"\"\n        E = ElementMaker(namespace=NSFOLIA,nsmap={None: NSFOLIA, 'xml' : \"http://www.w3.org/XML/1998/namespace\"})\n\n        if not attribs: attribs = {}\n        if not elements: elements = []\n\n        if self.id:\n            attribs['{http://www.w3.org/XML/1998/namespace}id'] = self.id\n\n        #Some attributes only need to be added if they are not the same as what's already set in the declaration\n        if not isinstance(self, AbstractAnnotationLayer):\n            if '{' + NSFOLIA + '}set' not in attribs: #do not override if overloaded function already set it\n                try:\n                    if self.set:\n                        if not self.ANNOTATIONTYPE in self.doc.annotationdefaults or len(self.doc.annotationdefaults[self.ANNOTATIONTYPE]) != 1 or list(self.doc.annotationdefaults[self.ANNOTATIONTYPE].keys())[0] != self.set:\n                            if self.set != None:\n                                if self.ANNOTATIONTYPE in self.doc.set_alias and self.set in self.doc.set_alias[self.ANNOTATIONTYPE]:\n                                    attribs['{' + NSFOLIA + '}set'] = self.doc.set_alias[self.ANNOTATIONTYPE][self.set] #use alias instead\n                                else:\n                                    attribs['{' + NSFOLIA + '}set'] = self.set\n                except AttributeError:\n                    pass\n\n        if '{' + NSFOLIA + '}class' not in attribs: #do not override if caller already set it\n            try:\n                if self.cls:\n                    attribs['{' + NSFOLIA + '}class'] = self.cls\n            except AttributeError:\n                pass\n\n        if '{' + NSFOLIA + '}annotator' not in attribs: #do not override if caller already set it\n            try:\n                if self.annotator and ((not (self.ANNOTATIONTYPE in self.doc.annotationdefaults)) or (not ( 'annotator' in self.doc.annotationdefaults[self.ANNOTATIONTYPE][self.set])) or (self.annotator != self.doc.annotationdefaults[self.ANNOTATIONTYPE][self.set]['annotator'])):\n                    attribs['{' + NSFOLIA + '}annotator'] = self.annotator\n                if self.annotatortype and ((not (self.ANNOTATIONTYPE in self.doc.annotationdefaults)) or (not ('annotatortype' in self.doc.annotationdefaults[self.ANNOTATIONTYPE][self.set])) or (self.annotatortype != self.doc.annotationdefaults[self.ANNOTATIONTYPE][self.set]['annotatortype'])):\n                    if self.annotatortype == AnnotatorType.AUTO:\n                        attribs['{' + NSFOLIA + '}annotatortype'] = 'auto'\n                    elif self.annotatortype == AnnotatorType.MANUAL:\n                        attribs['{' + NSFOLIA + '}annotatortype'] = 'manual'\n            except AttributeError:\n                pass\n\n        if '{' + NSFOLIA + '}confidence' not in attribs: #do not override if caller already set it\n            if self.confidence:\n                attribs['{' + NSFOLIA + '}confidence'] = str(self.confidence)\n\n        if '{' + NSFOLIA + '}n' not in attribs: #do not override if caller already set it\n            if self.n:\n                attribs['{' + NSFOLIA + '}n'] = str(self.n)\n\n        if '{' + NSFOLIA + '}auth' not in attribs: #do not override if caller already set it\n            try:\n                if not self.AUTH or not self.auth: #(former is static, latter isn't)\n                    attribs['{' + NSFOLIA + '}auth'] = 'no'\n            except AttributeError:\n                pass\n\n        if '{' + NSFOLIA + '}datetime' not in attribs: #do not override if caller already set it\n            if self.datetime and ((not (self.ANNOTATIONTYPE in self.doc.annotationdefaults)) or (not ( 'datetime' in self.doc.annotationdefaults[self.ANNOTATIONTYPE][self.set])) or (self.datetime != self.doc.annotationdefaults[self.ANNOTATIONTYPE][self.set]['datetime'])):\n                attribs['{' + NSFOLIA + '}datetime'] = self.datetime.strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n        if '{' + NSFOLIA + '}src' not in attribs: #do not override if caller already set it\n            if self.src:\n                attribs['{' + NSFOLIA + '}src'] = self.src\n\n        if '{' + NSFOLIA + '}speaker' not in attribs: #do not override if caller already set it\n            if self.speaker:\n                attribs['{' + NSFOLIA + '}speaker'] = self.speaker\n\n        if '{' + NSFOLIA + '}begintime' not in attribs: #do not override if caller already set it\n            if self.begintime:\n                attribs['{' + NSFOLIA + '}begintime'] = \"%02d:%02d:%02d.%03d\" % self.begintime\n\n        if '{' + NSFOLIA + '}endtime' not in attribs: #do not override if caller already set it\n            if self.endtime:\n                attribs['{' + NSFOLIA + '}endtime'] = \"%02d:%02d:%02d.%03d\" % self.endtime\n\n        if '{' + NSFOLIA + '}textclass' not in attribs: #do not override if caller already set it\n            if self.textclass and self.textclass != \"current\":\n                attribs['{' + NSFOLIA + '}textclass'] = self.textclass\n\n        if '{' + NSFOLIA + '}metadata' not in attribs: #do not override if caller already set it\n            if self.metadata:\n                attribs['{' + NSFOLIA + '}metadata'] = self.metadata\n\n        if self.XLINK:\n            if self.href:\n                attribs['{http://www.w3.org/1999/xlink}href'] = self.href\n                if not self.xlinktype:\n                    attribs['{http://www.w3.org/1999/xlink}type'] = \"simple\"\n            if self.xlinktype:\n                attribs['{http://www.w3.org/1999/xlink}type'] = self.xlinktype\n            if self.xlinklabel:\n                attribs['{http://www.w3.org/1999/xlink}label'] = self.xlinklabel\n            if self.xlinkrole:\n                attribs['{http://www.w3.org/1999/xlink}role'] = self.xlinkrole\n            if self.xlinkshow:\n                attribs['{http://www.w3.org/1999/xlink}show'] = self.xlinkshow\n            if self.xlinktitle:\n                attribs['{http://www.w3.org/1999/xlink}title'] = self.xlinktitle\n\n        omitchildren =  []\n\n        #Are there predetermined Features in ACCEPTED_DATA?\n        for c in self.ACCEPTED_DATA:\n            if issubclass(c, Feature) and c.SUBSET:\n                #Do we have any of those?\n                for c2 in self.data:\n                    if c2.__class__ is c and c.SUBSET == c2.SUBSET and c2.cls:\n                        #Yes, serialize them as attributes\n                        attribs[c2.SUBSET] = c2.cls\n                        omitchildren.append(c2) #and skip them as elements\n                        break #only one\n\n        e  = makeelement(E, '{' + NSFOLIA + '}' + self.XMLTAG, **attribs)\n\n\n\n        if not skipchildren and self.data:\n            #append children,\n            # we want make sure that text elements are in the right order, 'current' class first\n            # so we first put them in  a list\n            textelements = []\n            otherelements = []\n            for child in self:\n                if isinstance(child, TextContent):\n                    if child.cls == 'current':\n                        textelements.insert(0, child)\n                    else:\n                        textelements.append(child)\n                elif not child in omitchildren:\n                    otherelements.append(child)\n            for child in textelements+otherelements:\n                if (self.TEXTCONTAINER or self.PHONCONTAINER) and isstring(child):\n                    if len(e) == 0:\n                        if e.text:\n                            e.text += child\n                        else:\n                            e.text = child\n                    else:\n                        #add to tail of last child\n                        if e[-1].tail:\n                            e[-1].tail += child\n                        else:\n                            e[-1].tail = child\n\n                else:\n                    xml = child.xml() #may return None in rare occassions, meaning we wan to skip\n                    if not xml is None:\n                        e.append(xml)\n\n        if elements: #extra elements\n            for e2 in elements:\n                if isinstance(e2, str) or (sys.version < '3' and isinstance(e2, unicode)):\n                    if e.text is None:\n                        e.text = e2\n                    else:\n                        e.text += e2\n                else:\n                    e.append(e2)\n        return e",
    "docstring": "Serialises the FoLiA element and all its contents to XML.\n\n        Arguments are mostly for internal use.\n\n        Returns:\n            an lxml.etree.Element\n\n        See also:\n            :meth:`AbstractElement.xmlstring` - for direct string output",
    "summary": "Diese Funktion, `xml`, serialisiert ein FoLiA-Element (ein Element in einem spezifischen XML-Format f\u00fcr linguistische Annotationen) und all seine Inhalte in ein XML-Format. Hier ist eine einfache Erkl\u00e4rung in Deutsch:\n\n1. **Zweck**: Die Funktion wandelt ein FoLiA-Element in ein XML-Element um, das von `lxml.etree.Element` dargestellt wird. Dies ist n\u00fctzlich, um linguistische Daten in einem standardisierten Format zu speichern oder zu exportieren.\n\n2. **Parameter**:\n   - `attribs`: Ein optionales W\u00f6rterbuch mit Attributen, die dem XML-Element hinzugef\u00fcgt werden sollen.\n   - `elements`: Eine optionale Liste von zus\u00e4tzlichen Elementen, die dem XML-Element hinzugef\u00fcgt werden sollen.\n   - `skipchildren`: Ein boolescher Wert, der angibt, ob die untergeordneten Elemente (Kinder) des FoLiA-Elements \u00fcbersprungen werden sollen.\n\n3. **Funktionsweise**:\n   - Die Funktion erstellt ein XML-Element mit dem entsprechenden Namespace f\u00fcr FoLiA.\n   - Sie f\u00fcgt Attribute hinzu, die auf dem FoLiA-Element basieren, wie z.B. `id`, `class`, `annotator`, `confidence`, usw. Diese Attribute werden nur hinzugef\u00fcgt, wenn sie nicht bereits im `attribs`-W\u00f6rterbuch vorhanden sind.\n   - Sie verarbeitet spezielle Attribute wie `set`, `annotatortype`, `datetime`, und andere, die f\u00fcr linguistische Annotationen relevant sind.\n   - Wenn `skipchildren` nicht gesetzt ist, werden die untergeordneten Elemente des FoLiA-Elements ebenfalls serialisiert und dem XML-Element hinzugef\u00fcgt. Dabei wird sichergestellt, dass Textinhalte in der richtigen Reihenfolge eingef\u00fcgt werden.\n   - Zus\u00e4tzliche Elemente aus der `elements`-Liste werden ebenfalls hinzugef\u00fcgt.\n\n4. **R\u00fcckgabewert**: Die Funktion gibt das erstellte `lxml.etree.Element` zur\u00fcck, das das FoLiA-Element und seine Inhalte im XML-Format darstellt.\n\nZusammenfassend konvertiert diese Funktion ein FoLiA-Element in ein XML-Element, wobei sie alle relevanten Attribute und untergeordneten Elemente ber\u00fccksichtigt, um eine korrekte Darstellung im XML-Format zu gew\u00e4hrleisten."
  },
  {
    "code": "def json(self, attribs=None, recurse=True, ignorelist=False):\n        \"\"\"Serialises the FoLiA element and all its contents to a Python dictionary suitable for serialisation to JSON.\n\n        Example::\n\n            import json\n            json.dumps(word.json())\n\n        Returns:\n            dict\n        \"\"\"\n        jsonnode = {}\n\n        jsonnode['type'] = self.XMLTAG\n        if self.id:\n            jsonnode['id'] = self.id\n        if self.set:\n            jsonnode['set'] = self.set\n        if self.cls:\n            jsonnode['class'] = self.cls\n        if self.annotator:\n            jsonnode['annotator'] = self.annotator\n        if self.annotatortype:\n            if self.annotatortype == AnnotatorType.AUTO:\n                jsonnode['annotatortype'] = \"auto\"\n            elif self.annotatortype == AnnotatorType.MANUAL:\n                jsonnode['annotatortype'] = \"manual\"\n        if self.confidence is not None:\n            jsonnode['confidence'] = self.confidence\n        if self.n:\n            jsonnode['n'] = self.n\n        if self.auth:\n            jsonnode['auth'] = self.auth\n        if self.datetime:\n            jsonnode['datetime'] = self.datetime.strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n        if recurse: #pylint: disable=too-many-nested-blocks\n            jsonnode['children'] = []\n            if self.TEXTCONTAINER:\n                jsonnode['text'] = self.text()\n            if self.PHONCONTAINER:\n                jsonnode['phon'] = self.phon()\n            for child in self:\n                if self.TEXTCONTAINER and isstring(child):\n                    jsonnode['children'].append(child)\n                elif not self.PHONCONTAINER:\n                    #check ignore list\n                    ignore = False\n                    if ignorelist:\n                        for e in ignorelist:\n                            if isinstance(child,e):\n                                ignore = True\n                                break\n                    if not ignore:\n                        jsonnode['children'].append(child.json(attribs,recurse,ignorelist))\n\n        if attribs:\n            for attrib in attribs:\n                jsonnode[attrib] = attribs\n\n        return jsonnode",
    "docstring": "Serialises the FoLiA element and all its contents to a Python dictionary suitable for serialisation to JSON.\n\n        Example::\n\n            import json\n            json.dumps(word.json())\n\n        Returns:\n            dict",
    "summary": "Diese Funktion wandelt ein FoLiA-Element (ein XML-basiertes Format f\u00fcr linguistische Annotationen) und seine Inhalte in ein Python-Dictionary um, das sich leicht in JSON (JavaScript Object Notation) serialisieren l\u00e4sst. JSON ist ein g\u00e4ngiges Format, um Daten strukturiert zu speichern und auszutauschen.\n\nHier ist eine einfache Erkl\u00e4rung, was die Funktion macht:\n\n1. **Erstellt ein leeres Dictionary (`jsonnode`)**: Dies wird sp\u00e4ter mit den Daten des FoLiA-Elements gef\u00fcllt.\n2. **F\u00fcgt grundlegende Informationen hinzu**: Wie z.B. den Typ des Elements (`type`), seine ID (`id`), Klasse (`class`), Annotator (`annotator`) usw., falls diese vorhanden sind.\n3. **Behandelt spezielle Attribute**: Wie z.B. das Datum (`datetime`) oder den Annotatortyp (`annotatortype`), die in einem bestimmten Format gespeichert werden.\n4. **Rekursive Verarbeitung von Kind-Elementen (falls gew\u00fcnscht)**: Wenn `recurse=True`, werden auch die untergeordneten Elemente des FoLiA-Elements verarbeitet und in das Dictionary aufgenommen. Dabei wird gepr\u00fcft, ob bestimmte Elemente ignoriert werden sollen (`ignorelist`).\n5. **F\u00fcgt zus\u00e4tzliche Attribute hinzu**: Wenn `attribs` angegeben wird, werden diese zus\u00e4tzlichen Attribute ebenfalls in das Dictionary aufgenommen.\n6. **Gibt das fertige Dictionary zur\u00fcck**: Dieses kann dann mit `json.dumps()` in eine JSON-Zeichenkette umgewandelt werden.\n\nZusammengefasst: Die Funktion nimmt ein FoLiA-Element und verwandelt es in ein strukturiertes Dictionary, das sich leicht in JSON umwandeln l\u00e4sst, um es z.B. zu speichern oder zu \u00fcbertragen."
  },
  {
    "code": "def xmlstring(self, pretty_print=False):\n        \"\"\"Serialises this FoLiA element and all its contents to XML.\n\n        Returns:\n            str: a string with XML representation for this element and all its children\"\"\"\n        s = ElementTree.tostring(self.xml(), xml_declaration=False, pretty_print=pretty_print, encoding='utf-8')\n        if sys.version < '3':\n            if isinstance(s, str):\n                s = unicode(s,'utf-8') #pylint: disable=undefined-variable\n        else:\n            if isinstance(s,bytes):\n                s = str(s,'utf-8')\n\n        s = s.replace('ns0:','') #ugly patch to get rid of namespace prefix\n        s = s.replace(':ns0','')\n        return s",
    "docstring": "Serialises this FoLiA element and all its contents to XML.\n\n        Returns:\n            str: a string with XML representation for this element and all its children",
    "summary": "Diese Funktion `xmlstring` wandelt ein FoLiA-Element (ein spezielles XML-Format) und alle seine Inhalte in eine XML-Zeichenkette um. Hier ist eine einfache Erkl\u00e4rung, was sie macht:\n\n1. **Serialisierung**: Die Funktion nimmt das FoLiA-Element und wandelt es zusammen mit allen untergeordneten Elementen (Kindern) in eine XML-Zeichenkette um.\n\n2. **Option f\u00fcr sch\u00f6ne Formatierung**: Wenn `pretty_print=True` angegeben wird, wird die XML-Ausgabe gut lesbar formatiert (z. B. mit Einr\u00fcckungen). Standardm\u00e4\u00dfig ist dies jedoch ausgeschaltet (`pretty_print=False`).\n\n3. **Kodierung**: Die Ausgabe wird in UTF-8 kodiert, um Sonderzeichen korrekt darzustellen.\n\n4. **Namespace-Bereinigung**: Die Funktion entfernt unerw\u00fcnschte Namespace-Pr\u00e4fixe (`ns0:`) aus der XML-Zeichenkette, um eine saubere Ausgabe zu gew\u00e4hrleisten.\n\n5. **R\u00fcckgabe**: Am Ende gibt die Funktion die XML-Zeichenkette zur\u00fcck, die das FoLiA-Element und seine Inhalte repr\u00e4sentiert.\n\nZusammengefasst: Die Funktion erzeugt eine XML-Darstellung eines FoLiA-Elements, optional sch\u00f6n formatiert, und bereinigt die Ausgabe von unn\u00f6tigen Namespace-Pr\u00e4fixen."
  },
  {
    "code": "def select(self, Class, set=None, recursive=True,  ignore=True, node=None): #pylint: disable=bad-classmethod-argument,redefined-builtin\n        \"\"\"Select child elements of the specified class.\n\n        A further restriction can be made based on set.\n\n        Arguments:\n            Class (class): The class to select; any python class (not instance) subclassed off :class:`AbstractElement`\n            Set (str): The set to match against, only elements pertaining to this set will be returned. If set to None (default), all elements regardless of set will be returned.\n            recursive (bool): Select recursively? Descending into child elements? Defaults to ``True``.\n            ignore: A list of Classes to ignore, if set to ``True`` instead of a list, all non-authoritative elements will be skipped (this is the default behaviour and corresponds to the following elements: :class:`Alternative`, :class:`AlternativeLayer`, :class:`Suggestion`, and :class:`folia.Original`. These elements and those contained within are never *authorative*. You may also include the boolean True as a member of a list, if you want to skip additional tags along the predefined non-authoritative ones.\n            * ``node``: Reserved for internal usage, used in recursion.\n\n        Yields:\n            Elements (instances derived from :class:`AbstractElement`)\n\n        Example::\n\n            for sense in text.select(folia.Sense, 'cornetto', True, [folia.Original, folia.Suggestion, folia.Alternative] ):\n                ..\n\n        \"\"\"\n\n        #if ignorelist is True:\n        #    ignorelist = default_ignore\n\n        if not node:\n            node = self\n        for e in self.data: #pylint: disable=too-many-nested-blocks\n            if (not self.TEXTCONTAINER and not self.PHONCONTAINER) or isinstance(e, AbstractElement):\n                if ignore is True:\n                    try:\n                        if not e.auth:\n                            continue\n                    except AttributeError:\n                        #not all elements have auth attribute..\n                        pass\n                elif ignore: #list\n                    doignore = False\n                    for c in ignore:\n                        if c is True:\n                            try:\n                                if not e.auth:\n                                    doignore =True\n                                    break\n                            except AttributeError:\n                                #not all elements have auth attribute..\n                                pass\n                        elif c == e.__class__ or issubclass(e.__class__,c):\n                            doignore = True\n                            break\n                    if doignore:\n                        continue\n\n                if isinstance(e, Class):\n                    if not set is None:\n                        try:\n                            if e.set != set:\n                                continue\n                        except AttributeError:\n                            continue\n                    yield e\n                if recursive:\n                    for e2 in e.select(Class, set, recursive, ignore, e):\n                        if not set is None:\n                            try:\n                                if e2.set != set:\n                                    continue\n                            except AttributeError:\n                                continue\n                        yield e2",
    "docstring": "Select child elements of the specified class.\n\n        A further restriction can be made based on set.\n\n        Arguments:\n            Class (class): The class to select; any python class (not instance) subclassed off :class:`AbstractElement`\n            Set (str): The set to match against, only elements pertaining to this set will be returned. If set to None (default), all elements regardless of set will be returned.\n            recursive (bool): Select recursively? Descending into child elements? Defaults to ``True``.\n            ignore: A list of Classes to ignore, if set to ``True`` instead of a list, all non-authoritative elements will be skipped (this is the default behaviour and corresponds to the following elements: :class:`Alternative`, :class:`AlternativeLayer`, :class:`Suggestion`, and :class:`folia.Original`. These elements and those contained within are never *authorative*. You may also include the boolean True as a member of a list, if you want to skip additional tags along the predefined non-authoritative ones.\n            * ``node``: Reserved for internal usage, used in recursion.\n\n        Yields:\n            Elements (instances derived from :class:`AbstractElement`)\n\n        Example::\n\n            for sense in text.select(folia.Sense, 'cornetto', True, [folia.Original, folia.Suggestion, folia.Alternative] ):\n                ..",
    "summary": "Dieser Python-Code definiert eine Funktion namens `select`, die verwendet wird, um bestimmte Kindelemente eines Objekts auszuw\u00e4hlen, basierend auf bestimmten Kriterien. Hier ist eine einfache Erkl\u00e4rung, was die Funktion tut:\n\n1. **Zweck**: Die Funktion `select` durchsucht die Kindelemente eines Objekts (z.B. eines XML- oder Baumstrukturelements) und gibt diejenigen zur\u00fcck, die bestimmten Bedingungen entsprechen.\n\n2. **Parameter**:\n   - **Class**: Die Klasse der Elemente, die ausgew\u00e4hlt werden sollen. Es muss eine Unterklasse von `AbstractElement` sein.\n   - **set**: Ein optionaler Parameter, der angibt, dass nur Elemente zur\u00fcckgegeben werden sollen, die zu einem bestimmten Set geh\u00f6ren. Wenn `None`, werden alle Elemente unabh\u00e4ngig vom Set zur\u00fcckgegeben.\n   - **recursive**: Ein boolescher Wert, der angibt, ob die Suche rekursiv in den Kindelementen fortgesetzt werden soll. Standardm\u00e4\u00dfig ist dies `True`.\n   - **ignore**: Eine Liste von Klassen, die ignoriert werden sollen, oder `True`, um standardm\u00e4\u00dfig nicht-autoritative Elemente zu \u00fcberspringen.\n   - **node**: Ein intern verwendeter Parameter f\u00fcr die Rekursion.\n\n3. **Funktionsweise**:\n   - Die Funktion durchl\u00e4uft alle Kindelemente des aktuellen Objekts.\n   - Sie \u00fcberpr\u00fcft, ob ein Element ignoriert werden soll (basierend auf dem `ignore`-Parameter).\n   - Wenn das Element der angegebenen `Class` entspricht und (falls angegeben) zum richtigen `set` geh\u00f6rt, wird es zur\u00fcckgegeben.\n   - Wenn `recursive` auf `True` gesetzt ist, wird die Suche in den Kindelementen des aktuellen Elements fortgesetzt.\n\n4. **Ergebnis**: Die Funktion gibt ein Generator-Objekt zur\u00fcck, das die ausgew\u00e4hlten Elemente (Instanzen von `AbstractElement`) liefert.\n\n**Beispiel**:\nAngenommen, du hast ein Objekt `text`, das eine Baumstruktur von Elementen enth\u00e4lt. Mit dem folgenden Code kannst du alle Elemente der Klasse `folia.Sense` ausw\u00e4hlen, die zum Set `'cornetto'` geh\u00f6ren und dabei bestimmte Klassen ignorieren:\n\n```python\nfor sense in text.select(folia.Sense, 'cornetto', True, [folia.Original, folia.Suggestion, folia.Alternative]):\n    # Hier kannst du mit dem ausgew\u00e4hlten Element 'sense' arbeiten\n```\n\nZusammenfassend hilft diese Funktion dabei, spezifische Elemente in einer komplexen Struktur zu finden und zu filtern, basierend auf ihren Klassen, Sets und anderen Kriterien."
  },
  {
    "code": "def count(self, Class, set=None, recursive=True,  ignore=True, node=None):\n        \"\"\"Like :meth:`AbstractElement.select`, but instead of returning the elements, it merely counts them.\n\n        Returns:\n            int\n        \"\"\"\n        return sum(1 for i in self.select(Class,set,recursive,ignore,node) )",
    "docstring": "Like :meth:`AbstractElement.select`, but instead of returning the elements, it merely counts them.\n\n        Returns:\n            int",
    "summary": "Sicher! Diese Funktion `count` z\u00e4hlt die Anzahl der Elemente, die bestimmten Kriterien entsprechen, ohne die Elemente selbst zur\u00fcckzugeben. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Eingabeparameter**:\n   - `Class`: Die Klasse oder das Kriterium, nach dem gesucht werden soll.\n   - `set`: Ein optionaler Satz von Elementen, in dem gesucht werden soll.\n   - `recursive`: Ein boolescher Wert, der angibt, ob die Suche rekursiv (also in untergeordneten Elementen) durchgef\u00fchrt werden soll.\n   - `ignore`: Ein boolescher Wert, der angibt, ob bestimmte Elemente ignoriert werden sollen.\n   - `node`: Ein optionaler Startknoten, von dem aus die Suche beginnt.\n\n2. **Funktionsweise**:\n   - Die Funktion verwendet die Methode `self.select`, um Elemente basierend auf den angegebenen Kriterien auszuw\u00e4hlen.\n   - Anstatt die ausgew\u00e4hlten Elemente zur\u00fcckzugeben, z\u00e4hlt sie einfach, wie viele Elemente gefunden wurden.\n   - Dies geschieht mit einem Generator-Ausdruck (`1 for i in self.select(...)`), der f\u00fcr jedes gefundene Element eine `1` erzeugt, und `sum`, um diese `1`-Werte zu summieren.\n\n3. **R\u00fcckgabewert**:\n   - Die Funktion gibt die Gesamtzahl der gefundenen Elemente als Ganzzahl (`int`) zur\u00fcck.\n\n**Zusammenfassend**: Die Funktion `count` z\u00e4hlt effizient die Anzahl der Elemente, die den angegebenen Kriterien entsprechen, ohne die Elemente selbst zu speichern oder zur\u00fcckzugeben."
  },
  {
    "code": "def items(self, founditems=[]): #pylint: disable=dangerous-default-value\n        \"\"\"Returns a depth-first flat list of *all* items below this element (not limited to AbstractElement)\"\"\"\n        l = []\n        for e in self.data:\n            if  e not in founditems: #prevent going in recursive loops\n                l.append(e)\n                if isinstance(e, AbstractElement):\n                    l += e.items(l)\n        return l",
    "docstring": "Returns a depth-first flat list of *all* items below this element (not limited to AbstractElement)",
    "summary": "Sicher! Hier ist eine einfache Erkl\u00e4rung des Functions auf Deutsch:\n\nDiese Funktion, `items`, durchsucht alle Elemente, die unter einem bestimmten Element liegen (nicht nur `AbstractElement`-Elemente), und gibt eine flache Liste aller gefundenen Elemente zur\u00fcck. \n\nDie Funktion verwendet eine rekursive Methode, um alle Elemente zu finden. Sie beginnt mit dem aktuellen Element (`self`) und durchsucht dann alle seine untergeordneten Elemente (`self.data`). Wenn ein Element gefunden wird, das noch nicht in der Liste der gefundenen Elemente (`founditems`) enthalten ist, wird es der Liste der gefundenen Elemente hinzugef\u00fcgt (`l.append(e)`).\n\nWenn das gefundene Element ein `AbstractElement` ist, wird die Funktion rekursiv aufgerufen, um auch alle seine untergeordneten Elemente zu finden und zur Liste hinzuzuf\u00fcgen (`l += e.items(l)`).\n\nDie Funktion gibt schlie\u00dflich die Liste aller gefundenen Elemente zur\u00fcck (`return l`).\n\nZusammenfassend: Die Funktion durchsucht rekursiv alle Elemente unter einem bestimmten Element und gibt eine flache Liste aller gefundenen Elemente zur\u00fcck, wobei sichergestellt wird, dass keine Elemente doppelt gez\u00e4hlt werden (durch die \u00dcberpr\u00fcfung `e not in founditems`)."
  },
  {
    "code": "def getmetadata(self, key=None):\n        \"\"\"Get the metadata that applies to this element, automatically inherited from parent elements\"\"\"\n        if self.metadata:\n            d =  self.doc.submetadata[self.metadata]\n        elif self.parent:\n            d =  self.parent.getmetadata()\n        elif self.doc:\n            d =  self.doc.metadata\n        else:\n            return None\n        if key:\n            return d[key]\n        else:\n            return d",
    "docstring": "Get the metadata that applies to this element, automatically inherited from parent elements",
    "summary": "Diese Funktion, `getmetadata`, holt sich die Metadaten, die f\u00fcr ein bestimmtes Element gelten. Metadaten sind zus\u00e4tzliche Informationen, die einem Element zugeordnet sind, wie z.B. Autor, Datum oder andere Beschreibungen.\n\nHier ist eine Schritt-f\u00fcr-Schritt-Erkl\u00e4rung:\n\n1. **\u00dcberpr\u00fcfen der eigenen Metadaten**: Zuerst schaut die Funktion, ob das aktuelle Element (`self`) eigene Metadaten hat (`self.metadata`). Wenn ja, werden diese Metadaten aus dem Dokument (`self.doc.submetadata`) abgerufen.\n\n2. **Vererben von Metadaten vom Eltern-Element**: Wenn das aktuelle Element keine eigenen Metadaten hat, aber ein Eltern-Element (`self.parent`) existiert, wird die Funktion rekursiv auf dem Eltern-Element aufgerufen, um dessen Metadaten zu holen.\n\n3. **Verwenden der Dokument-Metadaten**: Wenn weder das aktuelle Element noch das Eltern-Element Metadaten haben, aber ein Dokument (`self.doc`) existiert, werden die Metadaten des Dokuments verwendet.\n\n4. **R\u00fcckgabe von `None`**: Wenn keine Metadaten gefunden werden, gibt die Funktion `None` zur\u00fcck.\n\n5. **R\u00fcckgabe eines spezifischen Werts oder aller Metadaten**: Wenn ein Schl\u00fcssel (`key`) angegeben wird, gibt die Funktion den Wert zu diesem Schl\u00fcssel zur\u00fcck. Wenn kein Schl\u00fcssel angegeben wird, werden alle Metadaten als Dictionary zur\u00fcckgegeben.\n\n**Zusammenfassung**: Die Funktion sucht nach Metadaten, die f\u00fcr ein Element gelten, und zwar in der Reihenfolge: eigene Metadaten, Metadaten des Eltern-Elements, Metadaten des Dokuments. Wenn ein Schl\u00fcssel angegeben wird, wird nur der entsprechende Wert zur\u00fcckgegeben, ansonsten alle Metadaten."
  },
  {
    "code": "def getindex(self, child, recursive=True, ignore=True):\n        \"\"\"Get the index at which an element occurs, recursive by default!\n\n        Returns:\n            int\n        \"\"\"\n\n        #breadth first search\n        for i, c in enumerate(self.data):\n            if c is child:\n                return i\n        if recursive:  #pylint: disable=too-many-nested-blocks\n            for i, c in enumerate(self.data):\n                if ignore is True:\n                    try:\n                        if not c.auth:\n                            continue\n                    except AttributeError:\n                        #not all elements have auth attribute..\n                        pass\n                elif ignore: #list\n                    doignore = False\n                    for e in ignore:\n                        if e is True:\n                            try:\n                                if not c.auth:\n                                    doignore =True\n                                    break\n                            except AttributeError:\n                                #not all elements have auth attribute..\n                                pass\n                        elif e == c.__class__ or issubclass(c.__class__,e):\n                            doignore = True\n                            break\n                    if doignore:\n                        continue\n                if isinstance(c, AbstractElement):\n                    j = c.getindex(child, recursive)\n                    if j != -1:\n                        return i #yes, i ... not j!\n        return -1",
    "docstring": "Get the index at which an element occurs, recursive by default!\n\n        Returns:\n            int",
    "summary": "Dies ist eine Python-Funktion namens `getindex`, die in einer Klasse definiert ist (da sie `self` als erstes Argument verwendet). Hier ist eine einfache Erkl\u00e4rung, was die Funktion tut:\n\n**Zweck:**  \nDie Funktion sucht nach einem bestimmten Element (`child`) innerhalb einer Datenstruktur (`self.data`) und gibt den Index zur\u00fcck, an dem dieses Element gefunden wird. Standardm\u00e4\u00dfig sucht sie rekursiv, also auch in verschachtelten Strukturen.\n\n**Funktionsweise:**\n1. **Direkte Suche:** Zuerst durchl\u00e4uft die Funktion die Daten (`self.data`) und pr\u00fcft, ob das gesuchte Element (`child`) direkt darin enthalten ist. Wenn ja, gibt sie den Index zur\u00fcck.\n2. **Rekursive Suche (falls aktiviert):** Wenn das Element nicht direkt gefunden wird und der Parameter `recursive` auf `True` gesetzt ist, sucht die Funktion weiter in verschachtelten Strukturen. Dabei werden bestimmte Elemente ignoriert, je nach Einstellung des Parameters `ignore`.\n3. **Ignorieren von Elementen:** Der Parameter `ignore` kann entweder ein boolescher Wert oder eine Liste sein. Wenn `ignore` aktiviert ist, werden bestimmte Elemente (z. B. solche ohne `auth`-Attribut) \u00fcbersprungen.\n4. **R\u00fcckgabewert:** Wenn das Element gefunden wird, gibt die Funktion den Index zur\u00fcck. Wenn es nicht gefunden wird, gibt sie `-1` zur\u00fcck.\n\n**Zusammenfassung:**  \nDie Funktion sucht nach einem Element in einer Datenstruktur, entweder direkt oder rekursiv, und gibt dessen Index zur\u00fcck. Sie bietet Optionen, bestimmte Elemente zu ignorieren, um die Suche zu verfeinern."
  },
  {
    "code": "def precedes(self, other):\n        \"\"\"Returns a boolean indicating whether this element precedes the other element\"\"\"\n        try:\n            ancestor = next(commonancestors(AbstractElement, self, other))\n        except StopIteration:\n            raise Exception(\"Elements share no common ancestor\")\n        #now we just do a depth first search and see who comes first\n        def callback(e):\n            if e is self:\n                return True\n            elif e is other:\n                return False\n            return None\n        result = ancestor.depthfirstsearch(callback)\n        if result is None:\n            raise Exception(\"Unable to find relation between elements! (shouldn't happen)\")\n        return result",
    "docstring": "Returns a boolean indicating whether this element precedes the other element",
    "summary": "Dieser Code ist eine Funktion namens `precedes`, die \u00fcberpr\u00fcft, ob ein Element (`self`) in einer Baumstruktur vor einem anderen Element (`other`) kommt. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Ziel der Funktion**: Die Funktion gibt `True` zur\u00fcck, wenn `self` vor `other` in der Baumstruktur kommt, und `False`, wenn es umgekehrt ist.\n\n2. **Gemeinsamer Vorfahre**: Zuerst sucht die Funktion nach einem gemeinsamen Vorfahren der beiden Elemente (`self` und `other`). Wenn es keinen gemeinsamen Vorfahren gibt, wird eine Fehlermeldung ausgel\u00f6st.\n\n3. **Tiefensuche**: Sobald der gemeinsame Vorfahre gefunden ist, wird eine Tiefensuche (Depth-First Search) in der Baumstruktur durchgef\u00fchrt. Dabei wird \u00fcberpr\u00fcft, welches der beiden Elemente (`self` oder `other`) als erstes gefunden wird.\n\n4. **Ergebnis**: Wenn `self` als erstes gefunden wird, gibt die Funktion `True` zur\u00fcck. Wenn `other` als erstes gefunden wird, gibt sie `False` zur\u00fcck. Falls etwas schiefgeht und die Beziehung zwischen den Elementen nicht bestimmt werden kann, wird eine weitere Fehlermeldung ausgel\u00f6st.\n\n**Zusammenfassung**: Die Funktion `precedes` bestimmt, ob ein Element in einer Baumstruktur vor einem anderen Element kommt, indem sie einen gemeinsamen Vorfahren findet und dann eine Tiefensuche durchf\u00fchrt."
  },
  {
    "code": "def depthfirstsearch(self, function):\n        \"\"\"Generic depth first search algorithm using a callback function, continues as long as the callback function returns None\"\"\"\n        result = function(self)\n        if result is not None:\n            return result\n        for e in self:\n            result = e.depthfirstsearch(function)\n            if result is not None:\n                return result\n        return None",
    "docstring": "Generic depth first search algorithm using a callback function, continues as long as the callback function returns None",
    "summary": "Sicher! Diese Funktion f\u00fchrt eine **Tiefensuche (Depth-First Search, DFS)** in einer Datenstruktur (z. B. einem Baum oder Graphen) durch. Hier ist eine einfache Erkl\u00e4rung auf Deutsch:\n\n1. **Zweck**: Die Funktion durchl\u00e4uft die Datenstruktur rekursiv in der Tiefe, bis sie ein bestimmtes Ergebnis findet oder alle Elemente besucht hat.\n\n2. **Funktionsweise**:\n   - Sie nimmt eine **Callback-Funktion** (`function`) entgegen, die auf jedes Element der Datenstruktur angewendet wird.\n   - Die Callback-Funktion wird auf das aktuelle Element (`self`) angewendet. Wenn die Callback-Funktion ein Ergebnis (`result`) zur\u00fcckgibt, das **nicht `None`** ist, wird dieses Ergebnis sofort zur\u00fcckgegeben und die Suche beendet.\n   - Wenn die Callback-Funktion `None` zur\u00fcckgibt, wird die Suche rekursiv auf alle untergeordneten Elemente (`e`) fortgesetzt.\n   - Falls keines der Elemente ein Ergebnis liefert, gibt die Funktion am Ende `None` zur\u00fcck.\n\n3. **Zusammenfassung**: Die Funktion sucht rekursiv in der Tiefe der Datenstruktur nach einem Element, das von der Callback-Funktion als relevant erkannt wird (d. h., die Callback-Funktion gibt etwas anderes als `None` zur\u00fcck). Sobald ein solches Element gefunden wird, wird die Suche abgebrochen und das Ergebnis zur\u00fcckgegeben.\n\nKurz gesagt: Sie sucht tiefenpriorisiert nach einem bestimmten Kriterium, das von der Callback-Funktion definiert wird."
  },
  {
    "code": "def next(self, Class=True, scope=True, reverse=False):\n        \"\"\"Returns the next element, if it is of the specified type and if it does not cross the boundary of the defined scope. Returns None if no next element is found. Non-authoritative elements are never returned.\n\n        Arguments:\n            * ``Class``: The class to select; any python class subclassed off `'AbstractElement``, may also be a tuple of multiple classes. Set to ``True`` to constrain to the same class as that of the current instance, set to ``None`` to not constrain at all\n            * ``scope``: A list of classes which are never crossed looking for a next element. Set to ``True`` to constrain to a default list of structure elements (Sentence,Paragraph,Division,Event, ListItem,Caption), set to ``None`` to not constrain at all.\n\n        \"\"\"\n        if Class is True: Class = self.__class__\n        if scope is True: scope = STRUCTURESCOPE\n\n        structural = Class is not None and issubclass(Class,AbstractStructureElement)\n\n        if reverse:\n            order = reversed\n            descendindex = -1\n        else:\n            order = lambda x: x #pylint: disable=redefined-variable-type\n            descendindex = 0\n\n        child = self\n        parent = self.parent\n        while parent: #pylint: disable=too-many-nested-blocks\n            if len(parent) > 1:\n                returnnext = False\n                for e in order(parent):\n                    if e is child:\n                        #we found the current item, next item will be the one to return\n                        returnnext = True\n                    elif returnnext and e.auth and not isinstance(e,AbstractAnnotationLayer) and (not structural or (structural and (not isinstance(e,(AbstractTokenAnnotation,TextContent)) ) )):\n                        if structural and isinstance(e,Correction):\n                            if not list(e.select(AbstractStructureElement)): #skip-over non-structural correction\n                                continue\n\n                        if Class is None or (isinstance(Class,tuple) and (any(isinstance(e,C) for C in Class))) or isinstance(e,Class):\n                            return e\n                        else:\n                            #this is not yet the element of the type we are looking for, we are going to descend again in the very leftmost (rightmost if reversed) branch only\n                            while e.data:\n                                e = e.data[descendindex]\n                                if not isinstance(e, AbstractElement):\n                                    return None #we've gone too far\n                                if e.auth and not isinstance(e,AbstractAnnotationLayer):\n                                    if Class is None or (isinstance(Class,tuple) and (any(isinstance(e,C) for C in Class))) or isinstance(e,Class):\n                                        return e\n                                    else:\n                                        #descend deeper\n                                        continue\n                        return None\n\n            #generational iteration\n            child = parent\n            if scope is not None and child.__class__ in scope:\n                #you shall not pass!\n                break\n            parent = parent.parent\n\n        return None",
    "docstring": "Returns the next element, if it is of the specified type and if it does not cross the boundary of the defined scope. Returns None if no next element is found. Non-authoritative elements are never returned.\n\n        Arguments:\n            * ``Class``: The class to select; any python class subclassed off `'AbstractElement``, may also be a tuple of multiple classes. Set to ``True`` to constrain to the same class as that of the current instance, set to ``None`` to not constrain at all\n            * ``scope``: A list of classes which are never crossed looking for a next element. Set to ``True`` to constrain to a default list of structure elements (Sentence,Paragraph,Division,Event, ListItem,Caption), set to ``None`` to not constrain at all.",
    "summary": "Dieser Code ist eine Funktion namens `next`, die in einer Klasse definiert ist und verwendet wird, um das n\u00e4chste Element in einer Struktur zu finden, das bestimmten Kriterien entspricht. Hier ist eine einfache Erkl\u00e4rung, was die Funktion tut:\n\n1. **Zweck**: Die Funktion sucht das n\u00e4chste Element in einer Hierarchie (z. B. in einem Dokument mit strukturierten Elementen wie S\u00e4tzen, Abs\u00e4tzen, etc.), das bestimmte Bedingungen erf\u00fcllt. Wenn kein solches Element gefunden wird, gibt sie `None` zur\u00fcck.\n\n2. **Parameter**:\n   - **`Class`**: Bestimmt die Art des Elements, das gesucht wird. Es kann eine bestimmte Klasse (oder ein Tupel von Klassen) sein, die von `AbstractElement` abgeleitet ist. Wenn `True`, wird die gleiche Klasse wie das aktuelle Element verwendet. Wenn `None`, wird keine Einschr\u00e4nkung vorgenommen.\n   - **`scope`**: Definiert eine Liste von Klassen, die nicht \u00fcberschritten werden d\u00fcrfen, w\u00e4hrend nach dem n\u00e4chsten Element gesucht wird. Wenn `True`, wird eine Standardliste von Strukturklassen verwendet. Wenn `None`, gibt es keine Einschr\u00e4nkung.\n   - **`reverse`**: Bestimmt, ob die Suche in umgekehrter Reihenfolge (von hinten nach vorne) erfolgen soll.\n\n3. **Funktionsweise**:\n   - Die Funktion beginnt beim aktuellen Element (`self`) und bewegt sich durch die Hierarchie (Eltern-Kind-Beziehungen) der Elemente.\n   - Sie \u00fcberpr\u00fcft, ob das n\u00e4chste Element autoritativ ist (d. h., es ist kein Annotationselement) und ob es den angegebenen Klassen- und Bereichsbedingungen entspricht.\n   - Wenn ein passendes Element gefunden wird, wird es zur\u00fcckgegeben. Andernfalls wird die Suche fortgesetzt, bis keine weiteren Elemente mehr vorhanden sind oder eine Bereichsgrenze erreicht wird.\n\n4. **Besonderheiten**:\n   - **Strukturelle Elemente**: Die Funktion ber\u00fccksichtigt speziell strukturelle Elemente (z. B. S\u00e4tze, Abs\u00e4tze) und \u00fcberspringt bestimmte Annotationselemente.\n   - **Korrekturen**: Wenn ein Korrektur-Element (`Correction`) gefunden wird, wird \u00fcberpr\u00fcft, ob es strukturelle Elemente enth\u00e4lt. Wenn nicht, wird es \u00fcbersprungen.\n\nZusammenfassend sucht die Funktion das n\u00e4chste Element, das den angegebenen Kriterien entspricht, ohne bestimmte Grenzen in der Struktur zu \u00fcberschreiten, und gibt es zur\u00fcck, falls gefunden."
  },
  {
    "code": "def previous(self, Class=True, scope=True):\n        \"\"\"Returns the previous element, if it is of the specified type and if it does not cross the boundary of the defined scope. Returns None if no next element is found. Non-authoritative elements are never returned.\n\n        Arguments:\n            * ``Class``: The class to select; any python class subclassed off `'AbstractElement``. Set to ``True`` to constrain to the same class as that of the current instance, set to ``None`` to not constrain at all\n            * ``scope``: A list of classes which are never crossed looking for a next element. Set to ``True`` to constrain to a default list of structure elements (Sentence,Paragraph,Division,Event, ListItem,Caption), set to ``None`` to not constrain at all.\n\n        \"\"\"\n        return self.next(Class,scope, True)",
    "docstring": "Returns the previous element, if it is of the specified type and if it does not cross the boundary of the defined scope. Returns None if no next element is found. Non-authoritative elements are never returned.\n\n        Arguments:\n            * ``Class``: The class to select; any python class subclassed off `'AbstractElement``. Set to ``True`` to constrain to the same class as that of the current instance, set to ``None`` to not constrain at all\n            * ``scope``: A list of classes which are never crossed looking for a next element. Set to ``True`` to constrain to a default list of structure elements (Sentence,Paragraph,Division,Event, ListItem,Caption), set to ``None`` to not constrain at all.",
    "summary": "Diese Funktion, `previous`, sucht nach dem vorherigen Element in einer Struktur, aber nur unter bestimmten Bedingungen. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Zweck**: Die Funktion gibt das vorherige Element zur\u00fcck, aber nur, wenn es bestimmten Kriterien entspricht. Wenn kein passendes Element gefunden wird, gibt sie `None` zur\u00fcck.\n\n2. **Argumente**:\n   - **`Class`**: Hier kannst du angeben, welche Art von Element du suchst. Wenn du `True` eingibst, sucht die Funktion nach einem Element des gleichen Typs wie das aktuelle Element. Wenn du `None` eingibst, wird keine Einschr\u00e4nkung vorgenommen.\n   - **`scope`**: Dies definiert, in welchem Bereich die Suche stattfinden soll. Wenn du `True` eingibst, wird die Suche auf bestimmte Standard-Strukturelemente (wie S\u00e4tze, Abs\u00e4tze, Abschnitte, Ereignisse, Listenelemente, Beschriftungen) beschr\u00e4nkt. Wenn du `None` eingibst, wird die Suche nicht eingeschr\u00e4nkt.\n\n3. **Funktionsweise**: Die Funktion nutzt intern die `next`-Funktion, aber mit einem Parameter, der die Suche in die entgegengesetzte Richtung (also zum vorherigen Element) lenkt. Dabei werden nicht-autoritative Elemente (d. h. Elemente, die nicht den Kriterien entsprechen) nie zur\u00fcckgegeben.\n\nZusammengefasst: Die Funktion sucht das vorherige Element, das den angegebenen Typ hat und innerhalb des definierten Bereichs liegt. Wenn kein solches Element gefunden wird, gibt sie `None` zur\u00fcck."
  },
  {
    "code": "def leftcontext(self, size, placeholder=None, scope=None):\n        \"\"\"Returns the left context for an element, as a list. This method crosses sentence/paragraph boundaries by default, which can be restricted by setting scope\"\"\"\n\n        if size == 0: return [] #for efficiency\n\n        context = []\n        e = self\n        while len(context) < size:\n            e = e.previous(True,scope)\n            if not e: break\n            context.append(e)\n\n        if placeholder:\n            while len(context) < size:\n                context.append(placeholder)\n\n        context.reverse()\n        return context",
    "docstring": "Returns the left context for an element, as a list. This method crosses sentence/paragraph boundaries by default, which can be restricted by setting scope",
    "summary": "Sicher! Diese Funktion, `leftcontext`, gibt den linken Kontext eines Elements als Liste zur\u00fcck. Hier ist eine einfache Erkl\u00e4rung, was sie macht:\n\n1. **Eingabeparameter**:\n   - `size`: Die Anzahl der Elemente, die im linken Kontext enthalten sein sollen.\n   - `placeholder`: Ein optionaler Platzhalter, der verwendet wird, wenn nicht gen\u00fcgend Elemente im linken Kontext vorhanden sind.\n   - `scope`: Ein optionaler Bereich, der festlegt, wie weit die Funktion zur\u00fcckgehen darf (z.B. innerhalb eines Satzes oder Absatzes).\n\n2. **Funktionsweise**:\n   - Wenn `size` 0 ist, gibt die Funktion eine leere Liste zur\u00fcck, um Rechenleistung zu sparen.\n   - Die Funktion beginnt mit dem aktuellen Element (`self`) und bewegt sich r\u00fcckw\u00e4rts, um die vorherigen Elemente zu sammeln.\n   - Sie sammelt so viele Elemente, bis die gew\u00fcnschte `size` erreicht ist oder bis es keine weiteren Elemente mehr gibt.\n   - Wenn ein `placeholder` angegeben ist und nicht gen\u00fcgend Elemente gefunden wurden, f\u00fcllt die Funktion die Liste mit diesem Platzhalter auf.\n   - Am Ende wird die Liste umgekehrt, sodass das \u00e4lteste Element zuerst steht, und die Liste wird zur\u00fcckgegeben.\n\n3. **Zusammenfassung**:\n   Die Funktion gibt also eine Liste der Elemente links vom aktuellen Element zur\u00fcck, wobei sie optional einen Platzhalter verwendet, um die Liste auf die gew\u00fcnschte L\u00e4nge zu bringen, und ber\u00fccksichtigt dabei einen m\u00f6glichen Bereichsbeschr\u00e4nkung (`scope`).\n\nAuf Deutsch: Diese Funktion liefert den linken Kontext eines Elements als Liste, wobei sie optional einen Platzhalter verwendet und einen Bereich ber\u00fccksichtigt, in dem sie suchen soll."
  },
  {
    "code": "def rightcontext(self, size, placeholder=None, scope=None):\n        \"\"\"Returns the right context for an element, as a list. This method crosses sentence/paragraph boundaries by default, which can be restricted by setting scope\"\"\"\n\n        if size == 0: return [] #for efficiency\n\n        context = []\n        e = self\n        while len(context) < size:\n            e = e.next(True,scope)\n            if not e: break\n            context.append(e)\n\n        if placeholder:\n            while len(context) < size:\n                context.append(placeholder)\n\n        return context",
    "docstring": "Returns the right context for an element, as a list. This method crosses sentence/paragraph boundaries by default, which can be restricted by setting scope",
    "summary": "Diese Funktion, `rightcontext`, gibt den rechten Kontext eines Elements als Liste zur\u00fcck. Hier ist eine einfache Erkl\u00e4rung, was sie macht:\n\n1. **Eingabeparameter**:\n   - `size`: Die Anzahl der Elemente, die im rechten Kontext enthalten sein sollen.\n   - `placeholder`: Ein optionaler Platzhalter, der verwendet wird, wenn nicht gen\u00fcgend Elemente im rechten Kontext vorhanden sind.\n   - `scope`: Ein optionaler Bereich, der festlegt, wie weit der Kontext \u00fcber Satz- oder Absatzgrenzen hinausgehen darf.\n\n2. **Funktionsweise**:\n   - Wenn `size` 0 ist, gibt die Funktion eine leere Liste zur\u00fcck, um Rechenleistung zu sparen.\n   - Die Funktion beginnt mit dem aktuellen Element (`self`) und sammelt die n\u00e4chsten Elemente in einer Liste (`context`), bis die gew\u00fcnschte Gr\u00f6\u00dfe (`size`) erreicht ist.\n   - Wenn nicht gen\u00fcgend Elemente vorhanden sind, wird der `placeholder` verwendet, um die Liste auf die gew\u00fcnschte Gr\u00f6\u00dfe zu bringen.\n   - Die Funktion gibt die Liste der gesammelten Elemente (oder Platzhalter) zur\u00fcck.\n\n3. **Zusammenfassung**:\n   Die Funktion sammelt die Elemente rechts vom aktuellen Element und gibt sie als Liste zur\u00fcck. Wenn nicht gen\u00fcgend Elemente vorhanden sind, f\u00fcllt sie die Liste mit einem Platzhalter auf. Der Umfang der Suche kann durch den `scope`-Parameter eingeschr\u00e4nkt werden.\n\n**Beispiel**:\nWenn du ein Element in einem Text hast und den rechten Kontext der n\u00e4chsten 3 W\u00f6rter m\u00f6chtest, w\u00fcrde die Funktion diese 3 W\u00f6rter (oder Platzhalter, falls weniger vorhanden sind) als Liste zur\u00fcckgeben."
  },
  {
    "code": "def context(self, size, placeholder=None, scope=None):\n        \"\"\"Returns this word in context, {size} words to the left, the current word, and {size} words to the right\"\"\"\n        return self.leftcontext(size, placeholder,scope) + [self] + self.rightcontext(size, placeholder,scope)",
    "docstring": "Returns this word in context, {size} words to the left, the current word, and {size} words to the right",
    "summary": "Sicher! Diese Funktion, `context`, gibt das aktige Wort in seinem Kontext zur\u00fcck, indem sie eine bestimmte Anzahl von W\u00f6rtern (definiert durch den Parameter `size`) vor und nach dem aktuellen Wort anzeigt.\n\nHier ist eine einfache Erkl\u00e4rung:\n\n1. **`size`**: Dies ist die Anzahl der W\u00f6rter, die links und rechts vom aktuellen Wort angezeigt werden sollen.\n2. **`placeholder`**: Dies ist ein optionaler Parameter, der verwendet werden kann, um fehlende W\u00f6rter zu ersetzen (z.B. wenn nicht gen\u00fcgend W\u00f6rter vorhanden sind).\n3. **`scope`**: Dies ist ebenfalls ein optionaler Parameter, der den Bereich definiert, in dem die W\u00f6rter gesucht werden sollen.\n\nDie Funktion kombiniert drei Teile:\n- **`self.leftcontext(size, placeholder, scope)`**: Gibt die `size` W\u00f6rter links vom aktuellen Wort zur\u00fcck.\n- **`[self]`**: Das aktuelle Wort selbst.\n- **`self.rightcontext(size, placeholder, scope)`**: Gibt die `size` W\u00f6rter rechts vom aktuellen Wort zur\u00fcck.\n\nZusammengefasst gibt die Funktion also einen Liste von W\u00f6rtern zur\u00fcck, die aus den linken Kontextw\u00f6rtern, dem aktuellen Wort und den rechten Kontextw\u00f6rtern besteht.\n\n**Beispiel:**\nWenn `size = 2` und das aktuelle Wort \"Hund\" ist, und der Satz lautet: \"Der schwarze Hund bellt laut.\", dann w\u00fcrde die Funktion zur\u00fcckgeben: `['schwarze', 'Der', 'Hund', 'bellt', 'laut']`.\n\nIch hoffe, das hilft! Wenn du weitere Fragen hast, lass es mich wissen."
  },
  {
    "code": "def relaxng(cls, includechildren=True,extraattribs = None, extraelements=None, origclass = None):\n        \"\"\"Returns a RelaxNG definition for this element (as an XML element (lxml.etree) rather than a string)\"\"\"\n\n        E = ElementMaker(namespace=\"http://relaxng.org/ns/structure/1.0\",nsmap={None:'http://relaxng.org/ns/structure/1.0' , 'folia': \"http://ilk.uvt.nl/folia\", 'xml' : \"http://www.w3.org/XML/1998/namespace\",'a':\"http://relaxng.org/ns/annotation/0.9\" })\n\n        if origclass: cls = origclass\n\n        preamble = []\n        try:\n            if cls.__doc__:\n                E2 = ElementMaker(namespace=\"http://relaxng.org/ns/annotation/0.9\", nsmap={'a':'http://relaxng.org/ns/annotation/0.9'} )\n                preamble.append(E2.documentation(cls.__doc__))\n        except AttributeError:\n            pass\n\n        if cls.REQUIRED_ATTRIBS is None: cls.REQUIRED_ATTRIBS = () #bit hacky\n        if cls.OPTIONAL_ATTRIBS is None: cls.OPTIONAL_ATTRIBS = () #bit hacky\n\n\n        attribs = [ ]\n        if cls.REQUIRED_ATTRIBS and Attrib.ID in cls.REQUIRED_ATTRIBS:\n            attribs.append( E.attribute(E.data(type='ID',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'),name='id', ns=\"http://www.w3.org/XML/1998/namespace\") )\n        elif Attrib.ID in cls.OPTIONAL_ATTRIBS:\n            attribs.append( E.optional( E.attribute(E.data(type='ID',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'), name='id', ns=\"http://www.w3.org/XML/1998/namespace\") ) )\n        if Attrib.CLASS in cls.REQUIRED_ATTRIBS:\n            #Set is a tough one, we can't require it as it may be defined in the declaration: we make it optional and need schematron to resolve this later\n            attribs.append( E.attribute(E.data(type='string',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'),name='class') )\n            attribs.append( E.optional( E.attribute( E.data(type='string',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'),name='set' ) ) )\n        elif Attrib.CLASS in cls.OPTIONAL_ATTRIBS:\n            attribs.append( E.optional( E.attribute(E.data(type='string',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'),name='class') ) )\n            attribs.append( E.optional( E.attribute(E.data(type='string',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'), name='set' ) ) )\n        if Attrib.ANNOTATOR in cls.REQUIRED_ATTRIBS or Attrib.ANNOTATOR in cls.OPTIONAL_ATTRIBS:\n            #Similarly tough\n            attribs.append( E.optional( E.attribute(E.data(type='string',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'), name='annotator') ) )\n            attribs.append( E.optional( E.attribute(name='annotatortype') ) )\n        if Attrib.CONFIDENCE in cls.REQUIRED_ATTRIBS:\n            attribs.append(  E.attribute(E.data(type='double',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'), name='confidence') )\n        elif Attrib.CONFIDENCE in cls.OPTIONAL_ATTRIBS:\n            attribs.append(  E.optional( E.attribute(E.data(type='double',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'), name='confidence') ) )\n        if Attrib.N in cls.REQUIRED_ATTRIBS:\n            attribs.append( E.attribute( E.data(type='string',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'),name='n') )\n        elif Attrib.N in cls.OPTIONAL_ATTRIBS:\n            attribs.append( E.optional( E.attribute( E.data(type='string',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'),name='n') ) )\n        if Attrib.DATETIME in cls.REQUIRED_ATTRIBS:\n            attribs.append( E.attribute(E.data(type='dateTime',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'), name='datetime') )\n        elif Attrib.DATETIME in cls.OPTIONAL_ATTRIBS:\n            attribs.append( E.optional( E.attribute( E.data(type='dateTime',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'),  name='datetime') ) )\n        if Attrib.BEGINTIME in cls.REQUIRED_ATTRIBS:\n            attribs.append(E.attribute(name='begintime') )\n        elif Attrib.BEGINTIME in cls.OPTIONAL_ATTRIBS:\n            attribs.append( E.optional( E.attribute(name='begintime') ) )\n        if Attrib.ENDTIME in cls.REQUIRED_ATTRIBS:\n            attribs.append(E.attribute(name='endtime') )\n        elif Attrib.ENDTIME in cls.OPTIONAL_ATTRIBS:\n            attribs.append( E.optional( E.attribute(name='endtime') ) )\n        if Attrib.SRC in cls.REQUIRED_ATTRIBS:\n            attribs.append(E.attribute(E.data(type='anyURI',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'),name='src') )\n        elif Attrib.SRC in cls.OPTIONAL_ATTRIBS:\n            attribs.append( E.optional( E.attribute(E.data(type='anyURI',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'),name='src') ) )\n        if Attrib.SPEAKER in cls.REQUIRED_ATTRIBS:\n            attribs.append(E.attribute(E.data(type='string',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'), name='speaker') )\n        elif Attrib.SPEAKER in cls.OPTIONAL_ATTRIBS:\n            attribs.append( E.optional( E.attribute(E.data(type='string',datatypeLibrary='http://www.w3.org/2001/XMLSchema-datatypes'),name='speaker') ) )\n        if Attrib.TEXTCLASS in cls.REQUIRED_ATTRIBS:\n            attribs.append(E.attribute(name='textclass') )\n        elif Attrib.TEXTCLASS in cls.OPTIONAL_ATTRIBS:\n            attribs.append( E.optional( E.attribute(name='textclass') ) )\n        if Attrib.METADATA in cls.REQUIRED_ATTRIBS:\n            attribs.append(E.attribute(name='metadata') )\n        elif Attrib.METADATA in cls.OPTIONAL_ATTRIBS:\n            attribs.append( E.optional( E.attribute(name='metadata') ) )\n        if cls.XLINK:\n            attribs += [ #loose interpretation of specs, not checking whether xlink combinations are valid\n                    E.optional(E.attribute(name='href',ns=\"http://www.w3.org/1999/xlink\"),E.attribute(name='type',ns=\"http://www.w3.org/1999/xlink\") ),\n                    E.optional(E.attribute(name='role',ns=\"http://www.w3.org/1999/xlink\")),\n                    E.optional(E.attribute(name='title',ns=\"http://www.w3.org/1999/xlink\")),\n                    E.optional(E.attribute(name='label',ns=\"http://www.w3.org/1999/xlink\")),\n                    E.optional(E.attribute(name='show',ns=\"http://www.w3.org/1999/xlink\")),\n            ]\n\n        attribs.append( E.optional( E.attribute( name='auth' ) ) )\n\n\n\n        if extraattribs:\n            for e in extraattribs:\n                attribs.append(e) #s\n\n        attribs.append( E.ref(name=\"allow_foreign_attributes\") )\n\n\n        elements = [] #(including attributes)\n        if cls.TEXTCONTAINER or cls.PHONCONTAINER:\n            elements.append( E.text())\n            #We actually want to require non-empty text (E.text() is not sufficient)\n            #but this is not solved yet, see https://github.com/proycon/folia/issues/19\n            #elements.append( E.data(E.param(r\".+\",name=\"pattern\"),type='string'))\n            #elements.append( E.data(E.param(r\"(.|\\n|\\r)*\\S+(.|\\n|\\r)*\",name=\"pattern\"),type='string'))\n        done = {}\n        if includechildren and cls.ACCEPTED_DATA: #pylint: disable=too-many-nested-blocks\n            for c in cls.ACCEPTED_DATA:\n                if c.__name__[:8] == 'Abstract' and inspect.isclass(c):\n                    for c2 in globals().values():\n                        try:\n                            if inspect.isclass(c2) and issubclass(c2, c):\n                                try:\n                                    if c2.XMLTAG and c2.XMLTAG not in done:\n                                        if c2.OCCURRENCES == 1:\n                                            elements.append( E.optional( E.ref(name=c2.XMLTAG) ) )\n                                        else:\n                                            elements.append( E.zeroOrMore( E.ref(name=c2.XMLTAG) ) )\n                                            if c2.XMLTAG == 'item': #nasty hack for backward compatibility with deprecated listitem element\n                                                elements.append( E.zeroOrMore( E.ref(name='listitem') ) )\n                                        done[c2.XMLTAG] = True\n                                except AttributeError:\n                                    continue\n                        except TypeError:\n                            pass\n                elif issubclass(c, Feature) and c.SUBSET:\n                    attribs.append( E.optional( E.attribute(name=c.SUBSET)))  #features as attributes\n                else:\n                    try:\n                        if c.XMLTAG and c.XMLTAG not in done:\n                            if cls.REQUIRED_DATA and c in cls.REQUIRED_DATA:\n                                if c.OCCURRENCES == 1:\n                                    elements.append( E.ref(name=c.XMLTAG) )\n                                else:\n                                    elements.append( E.oneOrMore( E.ref(name=c.XMLTAG) ) )\n                            elif c.OCCURRENCES == 1:\n                                elements.append( E.optional( E.ref(name=c.XMLTAG) ) )\n                            else:\n                                elements.append( E.zeroOrMore( E.ref(name=c.XMLTAG) ) )\n                                if c.XMLTAG == 'item':\n                                    #nasty hack for backward compatibility with deprecated listitem element\n                                    elements.append( E.zeroOrMore( E.ref(name='listitem') )  )\n                            done[c.XMLTAG] = True\n                    except AttributeError:\n                        continue\n\n        if extraelements:\n            for e in extraelements:\n                elements.append( e )\n\n        if elements:\n            if len(elements) > 1:\n                attribs.append( E.interleave(*elements) )\n            else:\n                attribs.append( *elements )\n\n        if not attribs:\n            attribs.append( E.empty() )\n\n        if cls.XMLTAG in ('desc','comment'):\n            return E.define( E.element(E.text(), *(preamble + attribs), **{'name': cls.XMLTAG}), name=cls.XMLTAG, ns=NSFOLIA)\n        else:\n            return E.define( E.element(*(preamble + attribs), **{'name': cls.XMLTAG}), name=cls.XMLTAG, ns=NSFOLIA)",
    "docstring": "Returns a RelaxNG definition for this element (as an XML element (lxml.etree) rather than a string)",
    "summary": "Diese Funktion generiert eine **RelaxNG-Definition** (eine Art Schema f\u00fcr XML-Dokumente) f\u00fcr ein bestimmtes Element. Hier ist eine einfache Erkl\u00e4rung, was sie macht:\n\n1. **Eingabeparameter**:\n   - `cls`: Die Klasse, f\u00fcr die die RelaxNG-Definition erstellt werden soll.\n   - `includechildren`: Ein Schalter, der angibt, ob untergeordnete Elemente ber\u00fccksichtigt werden sollen.\n   - `extraattribs` und `extraelements`: Zus\u00e4tzliche Attribute oder Elemente, die in die Definition aufgenommen werden sollen.\n   - `origclass`: Eine alternative Klasse, die statt `cls` verwendet werden kann.\n\n2. **Funktionsweise**:\n   - Die Funktion erstellt ein XML-Element (mit `lxml.etree`), das die RelaxNG-Definition darstellt.\n   - Sie analysiert die Attribute und untergeordneten Elemente der Klasse (`cls`), um die Regeln f\u00fcr das XML-Element zu definieren.\n   - Sie ber\u00fccksichtigt erforderliche und optionale Attribute (z. B. `id`, `class`, `annotator`, usw.) und definiert deren Datentypen.\n   - Wenn `includechildren` aktiviert ist, werden auch untergeordnete Elemente (z. B. `item`, `listitem`) in die Definition aufgenommen.\n   - Zus\u00e4tzliche Attribute und Elemente (`extraattribs`, `extraelements`) werden ebenfalls hinzugef\u00fcgt.\n\n3. **Ausgabe**:\n   - Die Funktion gibt ein XML-Element zur\u00fcck, das die RelaxNG-Definition f\u00fcr das angegebene Element (`cls`) darstellt. Diese Definition kann verwendet werden, um die Struktur und G\u00fcltigkeit von XML-Dokumenten zu \u00fcberpr\u00fcfen.\n\nZusammengefasst: Die Funktion erstellt ein Schema (RelaxNG) f\u00fcr ein XML-Element basierend auf den Eigenschaften einer Klasse und zus\u00e4tzlichen Angaben."
  },
  {
    "code": "def parsexml(Class, node, doc, **kwargs): #pylint: disable=bad-classmethod-argument\n        \"\"\"Internal class method used for turning an XML element into an instance of the Class.\n\n        Args:\n            * ``node`` - XML Element\n            * ``doc`` - Document\n\n        Returns:\n            An instance of the current Class.\n        \"\"\"\n\n        assert issubclass(Class, AbstractElement)\n\n        if doc.preparsexmlcallback:\n            result = doc.preparsexmlcallback(node)\n            if not result:\n                return None\n            if isinstance(result, AbstractElement):\n                return result\n\n\n\n        dcoi = node.tag.startswith('{' + NSDCOI + '}')\n        args = []\n        if not kwargs: kwargs = {}\n        text = None #for dcoi support\n        if (Class.TEXTCONTAINER or Class.PHONCONTAINER) and node.text:\n            args.append(node.text)\n\n\n        for subnode in node: #pylint: disable=too-many-nested-blocks\n            #don't trip over comments\n            if isinstance(subnode, ElementTree._Comment): #pylint: disable=protected-access\n                if (Class.TEXTCONTAINER or Class.PHONCONTAINER) and subnode.tail:\n                    args.append(subnode.tail)\n            else:\n                if subnode.tag.startswith('{' + NSFOLIA + '}'):\n                    if doc.debug >= 1: print(\"[PyNLPl FoLiA DEBUG] Processing subnode \" + subnode.tag[nslen:],file=stderr)\n                    try:\n                        e = doc.parsexml(subnode, Class)\n                    except ParseError as e:\n                        raise #just re-raise deepest parseError\n                    except Exception as e:\n                        #Python 3 will preserve full original traceback, Python 2 does not, original cause is explicitly passed to ParseError anyway:\n                        raise ParseError(\"FoLiA exception in handling of <\" + subnode.tag[len(NSFOLIA)+2:] + \"> @ line \" + str(subnode.sourceline) + \": [\" + e.__class__.__name__ + \"] \" + str(e), cause=e)\n                    if e is not None:\n                        args.append(e)\n                    if (Class.TEXTCONTAINER or Class.PHONCONTAINER) and subnode.tail:\n                        args.append(subnode.tail)\n                elif subnode.tag.startswith('{' + NSDCOI + '}'):\n                    #Dcoi support\n                    if Class is Text and subnode.tag[nslendcoi:] == 'body':\n                        for subsubnode in subnode:\n                            if doc.debug >= 1: print(\"[PyNLPl FoLiA DEBUG] Processing DCOI subnode \" + subnode.tag[nslendcoi:],file=stderr)\n                            e = doc.parsexml(subsubnode, Class)\n                            if e is not None:\n                                args.append(e)\n                    else:\n                        if doc.debug >= 1: print( \"[PyNLPl FoLiA DEBUG] Processing DCOI subnode \" + subnode.tag[nslendcoi:],file=stderr)\n                        e = doc.parsexml(subnode, Class)\n                        if e is not None:\n                            args.append(e)\n                elif doc.debug >= 1:\n                    print(\"[PyNLPl FoLiA DEBUG] Ignoring subnode outside of FoLiA namespace: \" + subnode.tag,file=stderr)\n\n\n\n        if dcoi:\n            dcoipos = dcoilemma = dcoicorrection = dcoicorrectionoriginal = None\n        for key, value in node.attrib.items():\n            if key[0] == '{' or key =='XMLid':\n                if key == '{http://www.w3.org/XML/1998/namespace}id' or key == 'XMLid':\n                    key = 'id'\n                elif key.startswith( '{' + NSFOLIA + '}'):\n                    key = key[nslen:]\n                    if key == 'id':\n                        #ID in FoLiA namespace is always a reference, passed in kwargs as follows:\n                        key = 'idref'\n                elif Class.XLINK and key.startswith('{http://www.w3.org/1999/xlink}'):\n                    key = key[30:]\n                    if key != 'href':\n                        key = 'xlink' + key #xlinktype, xlinkrole, xlinklabel, xlinkshow, etc..\n                elif key.startswith('{' + NSDCOI + '}'):\n                    key = key[nslendcoi:]\n\n            #D-Coi support:\n            if dcoi:\n                if Class is Word and key == 'pos':\n                    dcoipos = value\n                    continue\n                elif Class is Word and  key == 'lemma':\n                    dcoilemma = value\n                    continue\n                elif Class is Word and  key == 'correction':\n                    dcoicorrection = value #class\n                    continue\n                elif Class is Word and  key == 'original':\n                    dcoicorrectionoriginal = value\n                    continue\n                elif Class is Gap and  key == 'reason':\n                    key = 'class'\n                elif Class is Gap and  key == 'hand':\n                    key = 'annotator'\n                elif Class is Division and  key == 'type':\n                    key = 'cls'\n\n            kwargs[key] = value\n\n        #D-Coi support:\n        if dcoi and TextContent in Class.ACCEPTED_DATA and node.text:\n            text = node.text.strip()\n\n            kwargs['text'] = text\n            if not AnnotationType.TOKEN in doc.annotationdefaults:\n                doc.declare(AnnotationType.TOKEN, set='http://ilk.uvt.nl/folia/sets/ilktok.foliaset')\n\n        if doc.debug >= 1: print(\"[PyNLPl FoLiA DEBUG] Found \" + node.tag[nslen:],file=stderr)\n        instance = Class(doc, *args, **kwargs)\n        #if id:\n        #    if doc.debug >= 1: print >>stderr, \"[PyNLPl FoLiA DEBUG] Adding to index: \" + id\n        #    doc.index[id] = instance\n        if dcoi:\n            if dcoipos:\n                if not AnnotationType.POS in doc.annotationdefaults:\n                    doc.declare(AnnotationType.POS, set='http://ilk.uvt.nl/folia/sets/cgn-legacy.foliaset')\n                instance.append( PosAnnotation(doc, cls=dcoipos) )\n            if dcoilemma:\n                if not AnnotationType.LEMMA in doc.annotationdefaults:\n                    doc.declare(AnnotationType.LEMMA, set='http://ilk.uvt.nl/folia/sets/mblem-nl.foliaset')\n                instance.append( LemmaAnnotation(doc, cls=dcoilemma) )\n            if dcoicorrection and dcoicorrectionoriginal and text:\n                if not AnnotationType.CORRECTION in doc.annotationdefaults:\n                    doc.declare(AnnotationType.CORRECTION, set='http://ilk.uvt.nl/folia/sets/dcoi-corrections.foliaset')\n                instance.correct(generate_id_in=instance, cls=dcoicorrection, original=dcoicorrectionoriginal, new=text)\n\n        if doc.parsexmlcallback:\n            result = doc.parsexmlcallback(instance)\n            if not result:\n                return None\n            if isinstance(result, AbstractElement):\n                return result\n\n        return instance",
    "docstring": "Internal class method used for turning an XML element into an instance of the Class.\n\n        Args:\n            * ``node`` - XML Element\n            * ``doc`` - Document\n\n        Returns:\n            An instance of the current Class.",
    "summary": "Diese Funktion, `parsexml`, ist eine interne Methode, die dazu dient, ein XML-Element in eine Instanz einer bestimmten Klasse umzuwandeln. Hier ist eine einfache Erkl\u00e4rung, was sie macht:\n\n1. **Eingaben**: Die Funktion erh\u00e4lt eine Klasse (`Class`), ein XML-Element (`node`) und ein Dokument (`doc`). Zus\u00e4tzlich k\u00f6nnen optionale Parameter (`**kwargs`) \u00fcbergeben werden.\n\n2. **\u00dcberpr\u00fcfung**: Sie stellt sicher, dass die \u00fcbergebene Klasse von `AbstractElement` abgeleitet ist, was bedeutet, dass sie eine bestimmte Struktur oder Schnittstelle erf\u00fcllt.\n\n3. **Vorverarbeitung**: Falls eine Vorverarbeitungsfunktion (`preparsexmlcallback`) im Dokument definiert ist, wird diese aufgerufen. Wenn diese Funktion `None` zur\u00fcckgibt, wird die Verarbeitung abgebrochen.\n\n4. **Verarbeitung von Text und Unterelementen**:\n   - Wenn die Klasse Text oder phonetische Daten enth\u00e4lt und das XML-Element Text hat, wird dieser Text als Argument hinzugef\u00fcgt.\n   - Die Funktion durchl\u00e4uft alle Unterelemente des XML-Elements. Je nach Namespace (z. B. FoLiA oder DCOI) werden diese Unterelemente rekursiv verarbeitet und als Argumente hinzugef\u00fcgt.\n\n5. **Attributverarbeitung**: Die Attribute des XML-Elements werden durchlaufen und in Schl\u00fcssel-Wert-Paare umgewandelt. Dabei werden spezielle Namespaces (wie FoLiA oder DCOI) ber\u00fccksichtigt und die Schl\u00fcssel entsprechend angepasst.\n\n6. **DCOI-Unterst\u00fctzung**: Wenn das XML-Element aus dem DCOI-Namespace stammt, werden spezielle Attribute wie `pos` (Part-of-Speech), `lemma`, `correction` und `original` verarbeitet und in die Instanz der Klasse integriert.\n\n7. **Instanzierung**: Eine neue Instanz der Klasse wird mit den gesammelten Argumenten und Schl\u00fcssel-Wert-Paaren erstellt.\n\n8. **Nachverarbeitung**: Falls eine Nachverarbeitungsfunktion (`parsexmlcallback`) im Dokument definiert ist, wird diese auf die erstellte Instanz angewendet. Wenn diese Funktion `None` zur\u00fcckgibt, wird die Verarbeitung abgebrochen.\n\n9. **R\u00fcckgabe**: Die Funktion gibt die erstellte Instanz der Klasse zur\u00fcck.\n\nZusammengefasst wandelt diese Funktion ein XML-Element in ein Python-Objekt um, wobei sie spezielle Namespaces und Attribute ber\u00fccksichtigt und rekursiv Unterelemente verarbeitet."
  },
  {
    "code": "def remove(self, child):\n        \"\"\"Removes the child element\"\"\"\n        if not isinstance(child, AbstractElement):\n            raise ValueError(\"Expected AbstractElement, got \" + str(type(child)))\n        if child.parent == self:\n            child.parent = None\n        self.data.remove(child)\n        #delete from index\n        if child.id and self.doc and child.id in self.doc.index:\n            del self.doc.index[child.id]",
    "docstring": "Removes the child element",
    "summary": "Sicher! Hier ist eine einfache Erkl\u00e4rung der Funktion auf Deutsch:\n\nDiese Funktion, `remove`, entfernt ein bestimmtes Element (genannt `child`) aus einer Struktur oder Liste. Sie \u00fcberpr\u00fcft zun\u00e4chst, ob das zu entfernende Element vom richtigen Typ (`AbstractElement`) ist. Wenn nicht, gibt sie einen Fehler aus.\n\nAnschlie\u00dfend \u00fcberpr\u00fcft die Funktion, ob das Element tats\u00e4chlich zu der aktuellen Struktur geh\u00f6rt (indem sie pr\u00fcft, ob das `parent`-Attribut des Elements auf `self` verweist). Wenn ja, wird die Verbindung zum Eltern-Element gel\u00f6scht, indem `child.parent` auf `None` gesetzt wird.\n\nDann wird das Element aus der internen Liste (`self.data`) entfernt.\n\nZuletzt wird \u00fcberpr\u00fcft, ob das Element einen eindeutigen Bezeichner (`id`) hat und ob es in einem Index (`self.doc.index`) registriert ist. Wenn ja, wird es aus diesem Index gel\u00f6scht.\n\nZusammengefasst: Die Funktion entfernt ein Element aus einer Struktur, aktualisiert die Beziehungen und stellt sicher, dass es auch aus allen relevanten Indizes entfernt wird."
  },
  {
    "code": "def incorrection(self):\n        \"\"\"Is this element part of a correction? If it is, it returns the Correction element (evaluating to True), otherwise it returns None\"\"\"\n        e = self.parent\n\n        while e:\n            if isinstance(e, Correction):\n                return e\n            if isinstance(e, AbstractStructureElement):\n                break\n            e = e.parent\n        return None",
    "docstring": "Is this element part of a correction? If it is, it returns the Correction element (evaluating to True), otherwise it returns None",
    "summary": "Sicher! Diese Funktion \u00fcberpr\u00fcft, ob ein bestimmtes Element Teil einer Korrektur ist. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Startpunkt**: Die Funktion beginnt mit dem \u00fcbergeordneten Element (`parent`) des aktuellen Elements (`self`).\n  \n2. **Schleife**: Sie durchl\u00e4uft die \u00fcbergeordneten Elemente, bis sie entweder:\n   - Ein Element vom Typ `Correction` findet (das bedeutet, das aktuelle Element ist Teil einer Korrektur), oder\n   - Ein Element vom Typ `AbstractStructureElement` findet (das bedeutet, es gibt keine weitere Hierarchieebene, die \u00fcberpr\u00fcft werden kann), oder\n   - Kein \u00fcbergeordnetes Element mehr vorhanden ist (`e` wird `None`).\n\n3. **R\u00fcckgabe**:\n   - Wenn ein `Correction`-Element gefunden wird, gibt die Funktion dieses Element zur\u00fcck (was als `True` ausgewertet wird).\n   - Wenn kein `Correction`-Element gefunden wird, gibt die Funktion `None` zur\u00fcck.\n\nZusammengefasst pr\u00fcft die Funktion, ob das aktuelle Element in einer Hierarchie von Elementen Teil einer Korrektur ist, und gibt entweder die Korrektur oder `None` zur\u00fcck."
  },
  {
    "code": "def correct(self, **kwargs):\n        \"\"\"Apply a correction (TODO: documentation to be written still)\"\"\"\n\n        if 'insertindex_offset' in kwargs:\n            del kwargs['insertindex_offset'] #dealt with in an earlier stage\n\n        if 'confidence' in kwargs and kwargs['confidence'] is None:\n            del kwargs['confidence']\n\n        if 'reuse' in kwargs:\n            #reuse an existing correction instead of making a new one\n            if isinstance(kwargs['reuse'], Correction):\n                c = kwargs['reuse']\n            else: #assume it's an index\n                try:\n                    c = self.doc.index[kwargs['reuse']]\n                    assert isinstance(c, Correction)\n                except:\n                    raise ValueError(\"reuse= must point to an existing correction (id or instance)! Got \" + str(kwargs['reuse']))\n\n            suggestionsonly = (not c.hasnew(True) and not c.hasoriginal(True) and c.hassuggestions(True))\n\n            if 'new' in kwargs and c.hascurrent():\n                #can't add new if there's current, so first set original to current, and then delete current\n\n                if 'current' in kwargs:\n                    raise Exception(\"Can't set both new= and current= !\")\n                if 'original' not in kwargs:\n                    kwargs['original'] = c.current()\n\n                c.remove(c.current())\n        else:\n            if 'id' not in kwargs and 'generate_id_in' not in kwargs:\n                kwargs['generate_id_in'] = self\n            kwargs2 = copy(kwargs)\n            for x in ['new','original','suggestion', 'suggestions','current', 'insertindex','nooriginal']:\n                if x in kwargs2:\n                    del kwargs2[x]\n            c = Correction(self.doc, **kwargs2)\n\n        addnew = False\n        if 'insertindex' in kwargs:\n            insertindex = int(kwargs['insertindex'])\n            del kwargs['insertindex']\n        else:\n            insertindex = -1 #append\n\n        if 'nooriginal' in kwargs and kwargs['nooriginal']:\n            nooriginal = True\n            del kwargs['nooriginal']\n        else:\n            nooriginal = False\n\n        if 'current' in kwargs:\n            if 'original' in kwargs or 'new' in kwargs: raise Exception(\"When setting current=, original= and new= can not be set!\")\n            if not isinstance(kwargs['current'], list) and not isinstance(kwargs['current'], tuple): kwargs['current'] = [kwargs['current']] #support both lists (for multiple elements at once), as well as single element\n            c.replace(Current(self.doc, *kwargs['current']))\n            for o in kwargs['current']: #delete current from current element\n                if o in self and isinstance(o, AbstractElement): #pylint: disable=unsupported-membership-test\n                    if insertindex == -1: insertindex = self.data.index(o)\n                    self.remove(o)\n            del kwargs['current']\n        if 'new' in kwargs:\n            if not isinstance(kwargs['new'], list) and not isinstance(kwargs['new'], tuple): kwargs['new'] = [kwargs['new']] #support both lists (for multiple elements at once), as well as single element\n            addnew = New(self.doc, *kwargs['new']) #pylint: disable=redefined-variable-type\n            c.replace(addnew)\n            for current in c.select(Current): #delete current if present\n                c.remove(current)\n            del kwargs['new']\n        if 'original' in kwargs and kwargs['original']:\n            if not isinstance(kwargs['original'], list) and not isinstance(kwargs['original'], tuple): kwargs['original'] = [kwargs['original']] #support both lists (for multiple elements at once), as well as single element\n            c.replace(Original(self.doc, *kwargs['original']))\n            for o in kwargs['original']: #delete original from current element\n                if o in self and isinstance(o, AbstractElement): #pylint: disable=unsupported-membership-test\n                    if insertindex == -1: insertindex = self.data.index(o)\n                    self.remove(o)\n            for o in kwargs['original']: #make sure IDs are still properly set after removal\n                o.addtoindex()\n            for current in c.select(Current):  #delete current if present\n                c.remove(current)\n            del kwargs['original']\n        elif addnew and not nooriginal:\n            #original not specified, find automagically:\n            original = []\n            for new in addnew:\n                kwargs2 = {}\n                if isinstance(new, TextContent):\n                    kwargs2['cls'] = new.cls\n                try:\n                    set = new.set\n                except AttributeError:\n                    set = None\n                #print(\"DEBUG: Finding replaceables within \" + str(repr(self)) + \" for \", str(repr(new)), \" set \" ,set , \" args \" ,repr(kwargs2),file=sys.stderr)\n                replaceables = new.__class__.findreplaceables(self, set, **kwargs2)\n                #print(\"DEBUG: \" , len(replaceables) , \" found\",file=sys.stderr)\n                original += replaceables\n            if not original:\n                #print(\"DEBUG: \", self.xmlstring(),file=sys.stderr)\n                raise Exception(\"No original= specified and unable to automatically infer on \" + str(repr(self)) + \" for \" + str(repr(new)) + \" with set \" + set)\n            else:\n                c.replace( Original(self.doc, *original))\n                for current in c.select(Current):  #delete current if present\n                    c.remove(current)\n\n        if addnew and not nooriginal:\n            for original in c.original():\n                if original in self: #pylint: disable=unsupported-membership-test\n                    self.remove(original)\n\n        if 'suggestion' in kwargs:\n            kwargs['suggestions'] = [kwargs['suggestion']]\n            del kwargs['suggestion']\n        if 'suggestions' in kwargs:\n            for suggestion in kwargs['suggestions']:\n                if isinstance(suggestion, Suggestion):\n                    c.append(suggestion)\n                elif isinstance(suggestion, list) or isinstance(suggestion, tuple):\n                    c.append(Suggestion(self.doc, *suggestion))\n                else:\n                    c.append(Suggestion(self.doc, suggestion))\n            del kwargs['suggestions']\n\n\n\n\n        if 'reuse' in kwargs:\n            if addnew and suggestionsonly:\n                #What was previously only a suggestion, now becomes a real correction\n                #If annotator, annotatortypes\n                #are associated with the correction as a whole, move it to the suggestions\n                #correction-wide annotator, annotatortypes might be overwritten\n                for suggestion in c.suggestions():\n                    if c.annotator and not suggestion.annotator:\n                        suggestion.annotator = c.annotator\n                    if c.annotatortype and not suggestion.annotatortype:\n                        suggestion.annotatortype = c.annotatortype\n\n            if 'annotator' in kwargs:\n                c.annotator = kwargs['annotator'] #pylint: disable=attribute-defined-outside-init\n            if 'annotatortype' in kwargs:\n                c.annotatortype = kwargs['annotatortype'] #pylint: disable=attribute-defined-outside-init\n            if 'confidence' in kwargs:\n                c.confidence = float(kwargs['confidence']) #pylint: disable=attribute-defined-outside-init\n            c.addtoindex()\n            del kwargs['reuse']\n        else:\n            c.addtoindex()\n            if insertindex == -1:\n                self.append(c)\n            else:\n                self.insert(insertindex, c)\n        return c",
    "docstring": "Apply a correction (TODO: documentation to be written still)",
    "summary": "Diese Funktion, `correct`, dient dazu, Korrekturen in einem Dokument durchzuf\u00fchren oder bestehende Korrekturen zu aktualisieren. Sie nimmt verschiedene Parameter entgegen (\u00fcber `**kwargs`), die bestimmen, wie die Korrektur durchgef\u00fchrt werden soll. Hier ist eine einfache Erkl\u00e4rung der Hauptfunktionen:\n\n1. **Entfernen unn\u00f6tiger Parameter**: Es werden bestimmte Parameter wie `insertindex_offset` oder `confidence` (wenn `None`) entfernt, da sie entweder bereits fr\u00fcher behandelt wurden oder nicht ben\u00f6tigt werden.\n\n2. **Wiederverwendung von Korrekturen**: Wenn der Parameter `reuse` angegeben ist, wird eine bestehende Korrektur wiederverwendet, anstatt eine neue zu erstellen. Dabei wird \u00fcberpr\u00fcft, ob der angegebene Wert eine g\u00fcltige Korrektur ist.\n\n3. **Handhabung von `new`, `original` und `current`**:\n   - `new`: F\u00fcgt neue Inhalte hinzu und ersetzt ggf. bestehende Inhalte.\n   - `original`: Speichert den urspr\u00fcnglichen Inhalt, bevor er durch `new` ersetzt wird.\n   - `current`: Setzt den aktuellen Inhalt, der dann durch `new` oder `original` ersetzt wird.\n\n4. **Automatische Erkennung des Originals**: Wenn kein `original` angegeben ist, versucht die Funktion, den urspr\u00fcnglichen Inhalt automatisch zu erkennen, basierend auf den neuen Inhalten.\n\n5. **Hinzuf\u00fcgen von Vorschl\u00e4gen**: Es k\u00f6nnen Vorschl\u00e4ge (`suggestions`) hinzugef\u00fcgt werden, die m\u00f6gliche Alternativen zur Korrektur darstellen.\n\n6. **Einf\u00fcgen der Korrektur**: Die Korrektur wird entweder an einer bestimmten Position (`insertindex`) eingef\u00fcgt oder am Ende des Dokuments angeh\u00e4ngt.\n\n7. **R\u00fcckgabe der Korrektur**: Die Funktion gibt die durchgef\u00fchrte oder aktualisierte Korrektur zur\u00fcck.\n\nZusammengefasst erm\u00f6glicht diese Funktion das Durchf\u00fchren, Aktualisieren und Verwalten von Korrekturen in einem Dokument, wobei sie flexibel auf verschiedene Szenarien reagiert, wie z. B. das Wiederverwenden von Korrekturen oder das automatische Erkennen von urspr\u00fcnglichen Inhalten."
  },
  {
    "code": "def annotations(self,Class,set=None):\n        \"\"\"Obtain child elements (annotations) of the specified class.\n\n        A further restriction can be made based on set.\n\n        Arguments:\n            Class (class): The class to select; any python class (not instance) subclassed off :class:`AbstractElement`\n            Set (str): The set to match against, only elements pertaining to this set will be returned. If set to None (default), all elements regardless of set will be returned.\n\n        Yields:\n            Elements (instances derived from :class:`AbstractElement`)\n\n        Example::\n\n            for sense in text.annotations(folia.Sense, 'http://some/path/cornetto'):\n                ..\n\n        See also:\n            :meth:`AbstractElement.select`\n\n        Raises:\n            :meth:`AllowTokenAnnotation.annotations`\n            :class:`NoSuchAnnotation` if no such annotation exists\n        \"\"\"\n        found = False\n        for e in self.select(Class,set,True,default_ignore_annotations):\n            found = True\n            yield e\n        if not found:\n            raise NoSuchAnnotation()",
    "docstring": "Obtain child elements (annotations) of the specified class.\n\n        A further restriction can be made based on set.\n\n        Arguments:\n            Class (class): The class to select; any python class (not instance) subclassed off :class:`AbstractElement`\n            Set (str): The set to match against, only elements pertaining to this set will be returned. If set to None (default), all elements regardless of set will be returned.\n\n        Yields:\n            Elements (instances derived from :class:`AbstractElement`)\n\n        Example::\n\n            for sense in text.annotations(folia.Sense, 'http://some/path/cornetto'):\n                ..\n\n        See also:\n            :meth:`AbstractElement.select`\n\n        Raises:\n            :meth:`AllowTokenAnnotation.annotations`\n            :class:`NoSuchAnnotation` if no such annotation exists",
    "summary": "Dies ist eine Python-Funktion, die in einem gr\u00f6\u00dferen Programm verwendet wird, um bestimmte Elemente (genannt \"Annotations\") aus einer Struktur zu extrahieren. Hier ist eine einfache Erkl\u00e4rung auf Deutsch:\n\n**Was die Funktion tut:**\n\n1. **Zweck:** Die Funktion `annotations` sucht nach bestimmten Elementen (Annotations) in einer Struktur, die einer bestimmten Klasse (`Class`) angeh\u00f6ren. Diese Elemente sind wie \"Kinder\" in einer hierarchischen Struktur.\n\n2. **Einschr\u00e4nkung:** Du kannst die Suche weiter einschr\u00e4nken, indem du einen bestimmten `set` (eine Art Kategorie oder Gruppe) angibst. Wenn du keinen `set` angibst (`None`), werden alle Elemente der angegebenen Klasse zur\u00fcckgegeben.\n\n3. **Ergebnis:** Die Funktion gibt die gefundenen Elemente nacheinander zur\u00fcck (das nennt man \"yield\"). Diese Elemente sind Instanzen einer bestimmten Klasse (`AbstractElement`).\n\n4. **Fehlerbehandlung:** Wenn keine passenden Elemente gefunden werden, wirft die Funktion einen Fehler (`NoSuchAnnotation`), um anzuzeigen, dass keine entsprechende Annotation existiert.\n\n**Beispiel:**\n\nAngenommen, du hast eine Textstruktur und m\u00f6chtest alle Bedeutungen (`Sense`) finden, die zu einem bestimmten Pfad (`http://some/path/cornetto`) geh\u00f6ren. Die Funktion w\u00fcrde dir diese Bedeutungen nacheinander liefern.\n\n**Zusammenfassung:**\n\nDie Funktion `annotations` hilft dir, spezifische Elemente in einer Struktur zu finden, die einer bestimmten Klasse angeh\u00f6ren und optional einer bestimmten Gruppe (`set`) zugeordnet sind. Sie gibt die gefundenen Elemente zur\u00fcck und meldet einen Fehler, wenn keine passenden Elemente gefunden werden."
  },
  {
    "code": "def hasannotation(self,Class,set=None):\n        \"\"\"Returns an integer indicating whether such as annotation exists, and if so, how many.\n\n        See :meth:`AllowTokenAnnotation.annotations`` for a description of the parameters.\"\"\"\n        return sum( 1 for _ in self.select(Class,set,True,default_ignore_annotations))",
    "docstring": "Returns an integer indicating whether such as annotation exists, and if so, how many.\n\n        See :meth:`AllowTokenAnnotation.annotations`` for a description of the parameters.",
    "summary": "Diese Funktion pr\u00fcft, ob eine bestimmte Anmerkung (Annotation) in einer Klasse existiert, und gibt die Anzahl dieser Anmerkungen zur\u00fcck. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Eingaben**:  \n   - `Class`: Die Klasse, in der nach der Anmerkung gesucht wird.  \n   - `set`: Ein optionaler Parameter, der die Suche weiter eingrenzen kann.  \n\n2. **Funktionsweise**:  \n   Die Funktion durchsucht die Anmerkungen in der angegebenen Klasse (und optional im angegebenen Set) und z\u00e4hlt, wie viele davon vorhanden sind.  \n\n3. **Ausgabe**:  \n   Die Funktion gibt eine Zahl zur\u00fcck, die angibt, wie viele Anmerkungen gefunden wurden. Wenn keine Anmerkungen vorhanden sind, gibt sie `0` zur\u00fcck.  \n\nKurz gesagt: Sie \u00fcberpr\u00fcft, ob bestimmte Anmerkungen existieren, und z\u00e4hlt sie."
  },
  {
    "code": "def annotation(self, type, set=None):\n        \"\"\"Obtain a single annotation element.\n\n        A further restriction can be made based on set.\n\n        Arguments:\n            Class (class): The class to select; any python class (not instance) subclassed off :class:`AbstractElement`\n            Set (str): The set to match against, only elements pertaining to this set will be returned. If set to None (default), all elements regardless of set will be returned.\n\n        Returns:\n            An element (instance derived from :class:`AbstractElement`)\n\n        Example::\n\n            sense = word.annotation(folia.Sense, 'http://some/path/cornetto').cls\n\n        See also:\n            :meth:`AllowTokenAnnotation.annotations`\n            :meth:`AbstractElement.select`\n\n        Raises:\n            :class:`NoSuchAnnotation` if no such annotation exists\n        \"\"\"\n        \"\"\"Will return a **single** annotation (even if there are multiple). Raises a ``NoSuchAnnotation`` exception if none was found\"\"\"\n        for e in self.select(type,set,True,default_ignore_annotations):\n            return e\n        raise NoSuchAnnotation()",
    "docstring": "Obtain a single annotation element.\n\n        A further restriction can be made based on set.\n\n        Arguments:\n            Class (class): The class to select; any python class (not instance) subclassed off :class:`AbstractElement`\n            Set (str): The set to match against, only elements pertaining to this set will be returned. If set to None (default), all elements regardless of set will be returned.\n\n        Returns:\n            An element (instance derived from :class:`AbstractElement`)\n\n        Example::\n\n            sense = word.annotation(folia.Sense, 'http://some/path/cornetto').cls\n\n        See also:\n            :meth:`AllowTokenAnnotation.annotations`\n            :meth:`AbstractElement.select`\n\n        Raises:\n            :class:`NoSuchAnnotation` if no such annotation exists",
    "summary": "Dies ist eine Python-Funktion namens `annotation`, die Teil einer Klasse ist (wie durch `self` angedeutet). Hier ist eine einfache Erkl\u00e4rung, was sie tut:\n\n1. **Zweck**: Die Funktion gibt ein einzelnes Annotationselement zur\u00fcck, das bestimmten Kriterien entspricht.\n   \n2. **Parameter**:\n   - `type`: Die Art der Annotation, die gesucht wird. Dies muss eine Klasse sein, die von `AbstractElement` abgeleitet ist.\n   - `set` (optional): Ein Filter, um nur Annotationselemente zur\u00fcckzugeben, die zu einem bestimmten Set geh\u00f6ren. Wenn `None` (Standard), werden alle Elemente unabh\u00e4ngig vom Set zur\u00fcckgegeben.\n\n3. **Funktionsweise**:\n   - Die Funktion durchsucht die verf\u00fcgbaren Annotationselemente mithilfe der `select`-Methode und filtert sie nach dem angegebenen `type` und `set`.\n   - Sobald ein passendes Element gefunden wird, wird es zur\u00fcckgegeben.\n   - Wenn kein passendes Element gefunden wird, wird eine `NoSuchAnnotation`-Ausnahme ausgel\u00f6st.\n\n4. **Beispiel**:\n   - `word.annotation(folia.Sense, 'http://some/path/cornetto')` sucht nach einer Annotation vom Typ `folia.Sense`, die zum Set `'http://some/path/cornetto'` geh\u00f6rt, und gibt das erste gefundene Element zur\u00fcck.\n\n5. **Wichtig**: Die Funktion gibt **nur ein einzelnes** Element zur\u00fcck, auch wenn mehrere passende Elemente existieren.\n\nZusammengefasst: Die Funktion sucht nach einer spezifischen Annotation und gibt sie zur\u00fcck, falls sie gefunden wird. Andernfalls wird ein Fehler ausgel\u00f6st."
  },
  {
    "code": "def append(self, child, *args, **kwargs):\n        \"\"\"See ``AbstractElement.append()``\"\"\"\n        e = super(AbstractStructureElement,self).append(child, *args, **kwargs)\n        self._setmaxid(e)\n        return e",
    "docstring": "See ``AbstractElement.append()``",
    "summary": "Sicher! Diese Funktion `append` f\u00fcgt ein neues Element (`child`) zu einer bestehenden Struktur hinzu. Hier ist eine einfache Erkl\u00e4rung, was die Funktion macht:\n\n1. **Element hinzuf\u00fcgen**: Die Funktion verwendet `super().append(child, *args, **kwargs)`, um das neue Element (`child`) zur Struktur hinzuzuf\u00fcgen. Dies geschieht durch Aufruf der `append`-Methode der \u00fcbergeordneten Klasse (`AbstractElement`).\n\n2. **Maximale ID aktualisieren**: Nach dem Hinzuf\u00fcgen des Elements wird die Methode `_setmaxid(e)` aufgerufen. Diese Methode aktualisiert wahrscheinlich die maximale ID in der Struktur, um sicherzustellen, dass alle IDs eindeutig und korrekt sind.\n\n3. **R\u00fcckgabe des hinzugef\u00fcgten Elements**: Die Funktion gibt das hinzugef\u00fcgte Element (`e`) zur\u00fcck, damit es bei Bedarf weiter verwendet werden kann.\n\nZusammengefasst: Die Funktion f\u00fcgt ein neues Element zur Struktur hinzu, aktualisiert die maximale ID und gibt das hinzugef\u00fcgte Element zur\u00fcck."
  },
  {
    "code": "def words(self, index = None):\n        \"\"\"Returns a generator of Word elements found (recursively) under this element.\n\n        Arguments:\n            * ``index``: If set to an integer, will retrieve and return the n'th element (starting at 0) instead of returning the list of all\n        \"\"\"\n        if index is None:\n            return self.select(Word,None,True,default_ignore_structure)\n        else:\n            if index < 0:\n                index = self.count(Word,None,True,default_ignore_structure) + index\n            for i, e in enumerate(self.select(Word,None,True,default_ignore_structure)):\n                if i == index:\n                    return e\n            raise IndexError",
    "docstring": "Returns a generator of Word elements found (recursively) under this element.\n\n        Arguments:\n            * ``index``: If set to an integer, will retrieve and return the n'th element (starting at 0) instead of returning the list of all",
    "summary": "Sicher! Hier ist eine einfache Erkl\u00e4rung der Funktion `words` auf Deutsch:\n\nDie Funktion `words` gibt entweder alle **Wort-Elemente** zur\u00fcck, die sich (rekursiv) unter dem aktuellen Element befinden, oder \u2013 wenn ein bestimmter Index angegeben wird \u2013 nur das **Wort-Element** an der angegebenen Position.\n\n**So funktioniert sie im Detail:**\n\n1. **Ohne Index (`index = None`):**  \n   Die Funktion durchsucht das aktuelle Element und alle seine Unterelemente (rekursiv) nach **Wort-Elementen** und gibt sie als Generator zur\u00fcck. Das bedeutet, du kannst alle gefundenen W\u00f6rter nacheinander durchlaufen.\n\n2. **Mit Index (`index` ist eine Zahl):**  \n   - Wenn ein Index angegeben wird, versucht die Funktion, das **Wort-Element** an der entsprechenden Position (z. B. das 3. Wort, wenn `index = 2`) zur\u00fcckzugeben.  \n   - Falls der Index negativ ist (z. B. `-1`), wird er so umgerechnet, dass er von hinten gez\u00e4hlt wird (z. B. `-1` bedeutet das letzte Wort).  \n   - Wenn der Index au\u00dferhalb des g\u00fcltigen Bereichs liegt (z. B. ein Index, der gr\u00f6\u00dfer ist als die Anzahl der W\u00f6rter), wird ein `IndexError` ausgel\u00f6st.\n\n**Zusammenfassung:**  \nDie Funktion hilft dir, entweder alle W\u00f6rter in einem Element zu finden oder ein spezifisches Wort basierend auf seiner Position auszuw\u00e4hlen."
  },
  {
    "code": "def paragraphs(self, index = None):\n        \"\"\"Returns a generator of Paragraph elements found (recursively) under this element.\n\n        Arguments:\n            index (int or None): If set to an integer, will retrieve and return the n'th element (starting at 0) instead of returning the generator of all\n        \"\"\"\n        if index is None:\n            return self.select(Paragraph,None,True,default_ignore_structure)\n        else:\n            if index < 0:\n                index = self.count(Paragraph,None,True,default_ignore_structure) + index\n            for i,e in enumerate(self.select(Paragraph,None,True,default_ignore_structure)):\n                if i == index:\n                    return e\n            raise IndexError",
    "docstring": "Returns a generator of Paragraph elements found (recursively) under this element.\n\n        Arguments:\n            index (int or None): If set to an integer, will retrieve and return the n'th element (starting at 0) instead of returning the generator of all",
    "summary": "Sicher! Diese Funktion, `paragraphs`, durchsucht ein Dokument (oder ein Element in einem Dokument) nach Abs\u00e4tzen (`Paragraph` Elementen) und gibt sie zur\u00fcck. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Ohne Index (`index = None`)**:  \n   Wenn du die Funktion ohne einen bestimmten Index aufrufst, gibt sie einen **Generator** zur\u00fcck, der alle Abs\u00e4tze enth\u00e4lt, die sich (rekursiv) unter dem aktuellen Element befinden. Das bedeutet, du kannst durch alle Abs\u00e4tze iterieren, ohne dass sie alle auf einmal im Speicher geladen werden.\n\n2. **Mit Index (`index` ist eine Zahl)**:  \n   Wenn du einen Index angibst (z. B. `index=2`), versucht die Funktion, den **dritten** Absatz (da die Z\u00e4hlung bei 0 beginnt) zur\u00fcckzugeben.  \n   - Wenn der Index negativ ist (z. B. `index=-1`), wird er so interpretiert, dass er vom Ende der Liste z\u00e4hlt (also der letzte Absatz).  \n   - Falls der angegebene Index nicht existiert (z. B. es gibt nur 2 Abs\u00e4tze, aber du fragst nach dem 5.), wird ein `IndexError` ausgel\u00f6st.\n\n**Zusammenfassung**:  \nDie Funktion hilft dir, entweder alle Abs\u00e4tze eines Dokuments zu durchlaufen oder einen bestimmten Absatz basierend auf seiner Position auszuw\u00e4hlen."
  },
  {
    "code": "def sentences(self, index = None):\n        \"\"\"Returns a generator of Sentence elements found (recursively) under this element\n\n        Arguments:\n            index (int or None): If set to an integer, will retrieve and return the n'th element (starting at 0) instead of returning a generator of all\n        \"\"\"\n        if index is None:\n            return self.select(Sentence,None,True,default_ignore_structure)\n        else:\n            if index < 0:\n                index = self.count(Sentence,None,True,default_ignore_structure) + index\n            for i,e in enumerate(self.select(Sentence,None,True,default_ignore_structure)):\n                if i == index:\n                    return e\n            raise IndexError",
    "docstring": "Returns a generator of Sentence elements found (recursively) under this element\n\n        Arguments:\n            index (int or None): If set to an integer, will retrieve and return the n'th element (starting at 0) instead of returning a generator of all",
    "summary": "Sicher! Diese Funktion, `sentences`, durchsucht ein Dokument oder einen Text rekursiv nach S\u00e4tzen (vertreten durch das `Sentence`-Element). Hier ist, was sie tut, Schritt f\u00fcr Schritt:\n\n1. **Parameter**:  \n   - `index`: Ein optionaler Parameter, der entweder eine Ganzzahl (int) oder `None` sein kann.  \n   - Wenn `index` nicht angegeben wird (`None`), gibt die Funktion einen **Generator** zur\u00fcck, der alle gefundenen S\u00e4tze enth\u00e4lt.  \n   - Wenn `index` eine Ganzzahl ist, gibt die Funktion **nur den Satz an der angegebenen Position** (beginnend bei 0) zur\u00fcck.\n\n2. **Funktionsweise**:  \n   - **Ohne `index`**:  \n     Die Funktion verwendet `self.select`, um alle `Sentence`-Elemente zu finden und gibt sie als Generator zur\u00fcck.  \n     Beispiel: Wenn es 3 S\u00e4tze gibt, kannst du sie nacheinander durchlaufen, ohne alle auf einmal im Speicher zu halten.  \n   - **Mit `index`**:  \n     - Wenn `index` negativ ist, wird es in einen positiven Index umgewandelt (z. B. `-1` bedeutet den letzten Satz).  \n     - Die Funktion durchl\u00e4uft die S\u00e4tze und gibt den Satz an der gew\u00fcnschten Position zur\u00fcck.  \n     - Wenn der Index au\u00dferhalb des g\u00fcltigen Bereichs liegt, wird ein `IndexError` ausgel\u00f6st.\n\n3. **Zusammenfassung**:  \n   Die Funktion erm\u00f6glicht es, entweder **alle S\u00e4tze** oder **einen bestimmten Satz** aus einem Text zu extrahieren, abh\u00e4ngig davon, ob ein Index angegeben wird.  \n\n**Beispiel**:  \nAngenommen, der Text hat 3 S\u00e4tze:  \n- `sentences()` gibt einen Generator mit allen 3 S\u00e4tzen zur\u00fcck.  \n- `sentences(1)` gibt den zweiten Satz zur\u00fcck (Index beginnt bei 0).  \n- `sentences(-1)` gibt den letzten Satz zur\u00fcck."
  },
  {
    "code": "def layers(self, annotationtype=None,set=None):\n        \"\"\"Returns a list of annotation layers found *directly* under this element, does not include alternative layers\"\"\"\n        if inspect.isclass(annotationtype): annotationtype = annotationtype.ANNOTATIONTYPE\n        return [ x for x in self.select(AbstractAnnotationLayer,set,False,True) if annotationtype is None or x.ANNOTATIONTYPE == annotationtype ]",
    "docstring": "Returns a list of annotation layers found *directly* under this element, does not include alternative layers",
    "summary": "Sicher! Hier ist eine einfache Erkl\u00e4rung der Funktion auf Deutsch:\n\nDiese Funktion namens `layers` gibt eine Liste von Anmerkungen (Annotationen) zur\u00fcck, die sich **direkt** unter einem bestimmten Element befinden. Sie ber\u00fccksichtigt dabei nicht alternative Ebenen (Layers). \n\nDu kannst optional zwei Parameter angeben:\n\n1. **`annotationtype`**: Hier kannst du einen bestimmten Typ von Anmerkungen angeben, den du suchen m\u00f6chtest. Wenn du nichts angibst, werden alle Anmerkungen zur\u00fcckgegeben.\n2. **`set`**: Dieser Parameter wird nicht weiter erkl\u00e4rt, aber er scheint eine M\u00f6glichkeit zu bieten, die Suche auf eine bestimmte Menge von Anmerkungen zu beschr\u00e4nken.\n\nDie Funktion durchsucht dann die Anmerkungen, die direkt unter dem Element liegen, und filtert sie basierend auf den angegebenen Kriterien. Das Ergebnis ist eine Liste der gefundenen Anmerkungen.\n\nZusammengefasst: Die Funktion hilft dir, spezifische Anmerkungen in einer hierarchischen Struktur zu finden, ohne alternative Ebenen zu ber\u00fccksichtigen."
  },
  {
    "code": "def hasannotationlayer(self, annotationtype=None,set=None):\n        \"\"\"Does the specified annotation layer exist?\"\"\"\n        l = self.layers(annotationtype, set)\n        return (len(l) > 0)",
    "docstring": "Does the specified annotation layer exist?",
    "summary": "Diese Funktion \u00fcberpr\u00fcft, ob eine bestimmte **Annotationsschicht** (oder -ebene) in einem Objekt existiert. Hier ist die Erkl\u00e4rung Schritt f\u00fcr Schritt:\n\n1. **Funktionsname**: `hasannotationlayer`  \n   Sie pr\u00fcft, ob eine Annotationsschicht vorhanden ist.\n\n2. **Parameter**:\n   - `annotationtype`: Der Typ der Annotation, nach der gesucht werden soll (z. B. eine bestimmte Art von Anmerkung oder Markierung).\n   - `set`: Ein optionaler Parameter, der angibt, in welchem Satz oder Bereich nach der Annotation gesucht werden soll.\n\n3. **Funktionsweise**:\n   - Die Funktion ruft `self.layers` auf, um alle Schichten des angegebenen Typs und Satzes abzurufen.\n   - Sie \u00fcberpr\u00fcft, ob die Anzahl der gefundenen Schichten (`len(l)`) gr\u00f6\u00dfer als 0 ist.\n   - Wenn mindestens eine Schicht gefunden wird, gibt die Funktion `True` zur\u00fcck, andernfalls `False`.\n\n4. **Zusammenfassung**:  \n   Die Funktion sagt dir, ob eine bestimmte Annotationsschicht in einem Objekt vorhanden ist oder nicht. Sie gibt `True` zur\u00fcck, wenn die Schicht existiert, und `False`, wenn nicht."
  },
  {
    "code": "def xml(self, attribs = None,elements = None, skipchildren = False):\n        \"\"\"See :meth:`AbstractElement.xml`\"\"\"\n        if not attribs: attribs = {}\n        if self.idref:\n            attribs['id'] = self.idref\n        return super(AbstractTextMarkup,self).xml(attribs,elements, skipchildren)",
    "docstring": "See :meth:`AbstractElement.xml`",
    "summary": "Sicher! Hier ist eine einfache Erkl\u00e4rung der Funktion in Deutsch:\n\nDiese Funktion namens `xml` geh\u00f6rt zu einer Klasse namens `AbstractTextMarkup` und wird verwendet, um XML-Daten zu generieren. Sie nimmt drei optionale Parameter entgegen:\n\n1. **`attribs`**: Ein W\u00f6rterbuch mit Attributen, die dem XML-Element hinzugef\u00fcgt werden sollen. Wenn kein W\u00f6rterbuch \u00fcbergeben wird, wird ein leeres W\u00f6rterbuch verwendet.\n2. **`elements`**: Eine Liste von Elementen, die als Kinder des aktuellen Elements hinzugef\u00fcgt werden sollen (nicht explizit in der Funktion verwendet, aber m\u00f6glicherweise von der \u00fcbergeordneten Methode).\n3. **`skipchildren`**: Ein boolescher Wert, der angibt, ob die Kinderelemente \u00fcbersprungen werden sollen (wird an die \u00fcbergeordnete Methode weitergegeben).\n\nDie Funktion f\u00fchrt folgende Schritte aus:\n\n*   \u00dcberpr\u00fcft, ob `attribs` vorhanden ist, und falls nicht, initialisiert es ein leeres W\u00f6rterbuch.\n*   Wenn das Objekt eine `idref` hat (vermutlich eine Referenz auf eine ID), f\u00fcgt es diese als `id`-Attribut zu `attribs` hinzu.\n*   Ruft dann die `xml`-Methode der \u00fcbergeordneten Klasse (`super`) auf, um die tats\u00e4chliche XML-Generierung durchzuf\u00fchren, wobei die modifizierten `attribs`, `elements` und `skipchildren` als Parameter \u00fcbergeben werden.\n\nZusammengefasst: Die Funktion bereitet die Attribute vor, f\u00fcgt ggf. eine ID hinzu und l\u00e4sst dann die \u00fcbergeordnete Klasse die eigentliche XML-Generierung erledigen."
  },
  {
    "code": "def json(self,attribs =None, recurse=True, ignorelist=False):\n        \"\"\"See :meth:`AbstractElement.json`\"\"\"\n        if not attribs: attribs = {}\n        if self.idref:\n            attribs['id'] = self.idref\n        return super(AbstractTextMarkup,self).json(attribs,recurse, ignorelist)",
    "docstring": "See :meth:`AbstractElement.json`",
    "summary": "Sicher! Hier ist eine einfache Erkl\u00e4rung der Funktion in Deutsch:\n\nDiese Funktion, namens `json`, geh\u00f6rt zu einer Klasse namens `AbstractTextMarkup` und wird verwendet, um ein JSON-Format (eine Art von Datenstruktur) aus einem Element zu erstellen. \n\nDie Funktion nimmt drei optionale Parameter entgegen:\n\n1. **`attribs`**: Ein W\u00f6rterbuch (oder `None`), das zus\u00e4tzliche Attribute enth\u00e4lt, die im JSON-Ergebnis ber\u00fccksichtigt werden sollen. Wenn kein `attribs` angegeben wird, wird ein leeres W\u00f6rterbuch verwendet.\n2. **`recurse`**: Ein boolescher Wert (standardm\u00e4\u00dfig `True`), der angibt, ob die Funktion rekursiv in untergeordnete Elemente eintauchen soll, um sie ebenfalls in das JSON-Ergebnis aufzunehmen.\n3. **`ignorelist`**: Ein boolescher Wert (standardm\u00e4\u00dfig `False`), der wahrscheinlich angibt, ob bestimmte Elemente ignoriert werden sollen (obwohl dies aus dem Code nicht eindeutig hervorgeht).\n\nDie Funktion f\u00fchrt folgende Schritte aus:\n\n1. **\u00dcberpr\u00fcft, ob `attribs` leer ist**: Wenn ja, wird es als leeres W\u00f6rterbuch initialisiert.\n2. **F\u00fcgt eine `id` hinzu**: Wenn das aktuelle Element eine `idref` hat (eine Art von Identifikator), wird diese als `id` in das `attribs`-W\u00f6rterbuch aufgenommen.\n3. **Ruft die `json`-Methode der Elternklasse auf**: Dies geschieht mit `super(AbstractTextMarkup, self).json(attribs, recurse, ignorelist)`. Dies bedeutet, dass die `json`-Methode der Klasse, von der `AbstractTextMarkup` erbt, aufgerufen wird, wobei die modifizierten `attribs` und die anderen Parameter \u00fcbergeben werden.\n\nZusammengefasst: Die Funktion bereitet ein JSON-Ergebnis vor, indem sie zus\u00e4tzliche Attribute hinzuf\u00fcgt (falls vorhanden) und die Verarbeitung an die Elternklasse weiterleitet."
  },
  {
    "code": "def text(self, normalize_spaces=False):\n        \"\"\"Obtain the text (unicode instance)\"\"\"\n        return super(TextContent,self).text(normalize_spaces=normalize_spaces)",
    "docstring": "Obtain the text (unicode instance)",
    "summary": "Sicher! Diese Funktion, `text`, ist eine Methode einer Klasse (wahrscheinlich namens `TextContent`), die den Textinhalt eines Objekts zur\u00fcckgibt. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Zweck**: Die Funktion dient dazu, den Text (als Unicode-Instanz) aus dem Objekt zu extrahieren.\n  \n2. **Parameter**:\n   - `normalize_spaces=False`: Dies ist ein optionaler Parameter. Wenn er auf `True` gesetzt wird, werden Leerzeichen im Text normalisiert (z. B. mehrere aufeinanderfolgende Leerzeichen werden zu einem einzigen Leerzeichen reduziert). Standardm\u00e4\u00dfig ist dieser Parameter jedoch auf `False` gesetzt, was bedeutet, dass die Leerzeichen unver\u00e4ndert bleiben.\n\n3. **R\u00fcckgabe**: Die Funktion gibt den Textinhalt des Objekts zur\u00fcck, wobei die Leerzeichen entsprechend dem Wert von `normalize_spaces` behandelt werden.\n\n4. **Verwendung von `super`**: Der Aufruf von `super(TextContent, self).text(...)` bedeutet, dass die Funktion die Implementierung der `text`-Methode aus der Elternklasse verwendet. Dies ist n\u00fctzlich, wenn die aktuelle Klasse (`TextContent`) die Funktionalit\u00e4t der Elternklasse erweitert oder modifiziert.\n\n**Zusammenfassung**: Die Funktion gibt den Textinhalt eines Objekts zur\u00fcck, wobei optional Leerzeichen normalisiert werden k\u00f6nnen."
  },
  {
    "code": "def getreference(self, validate=True):\n        \"\"\"Returns and validates the Text Content's reference. Raises UnresolvableTextContent when invalid\"\"\"\n\n        if self.offset is None: return None #nothing to test\n        if self.ref:\n            ref = self.doc[self.ref]\n        else:\n            ref = self.finddefaultreference()\n\n        if not ref:\n            raise UnresolvableTextContent(\"Default reference for textcontent not found!\")\n        elif not ref.hastext(self.cls):\n            raise UnresolvableTextContent(\"Reference (ID \" + str(ref.id) + \") has no such text (class=\" + self.cls+\")\")\n        elif validate and self.text() != ref.textcontent(self.cls).text()[self.offset:self.offset+len(self.data[0])]:\n            raise UnresolvableTextContent(\"Reference (ID \" + str(ref.id) + \", class=\" + self.cls+\") found but no text match at specified offset (\"+str(self.offset)+\")! Expected '\" + self.text() + \"', got '\" + ref.textcontent(self.cls).text()[self.offset:self.offset+len(self.data[0])] +\"'\")\n        else:\n            #finally, we made it!\n            return ref",
    "docstring": "Returns and validates the Text Content's reference. Raises UnresolvableTextContent when invalid",
    "summary": "Diese Funktion, `getreference`, \u00fcberpr\u00fcft und gibt eine Referenz auf einen Textinhalt zur\u00fcck. Sie funktioniert wie folgt:\n\n1. **\u00dcberpr\u00fcfung der Offset-Information**: Wenn es keinen Offset (`self.offset`) gibt, gibt die Funktion `None` zur\u00fcck, da es nichts zu \u00fcberpr\u00fcfen gibt.\n\n2. **Referenz finden**:  \n   - Wenn eine Referenz (`self.ref`) vorhanden ist, wird diese verwendet.  \n   - Wenn nicht, wird eine Standardreferenz mit `finddefaultreference()` gesucht.\n\n3. **Validierung der Referenz**:  \n   - **Existenz der Referenz**: Wenn keine Referenz gefunden wird, wird ein Fehler (`UnresolvableTextContent`) ausgel\u00f6st.  \n   - **Textvorhandensein**: Wenn die Referenz keinen Text der angegebenen Klasse (`self.cls`) enth\u00e4lt, wird ein Fehler ausgel\u00f6st.  \n   - **Text\u00fcbereinstimmung** (nur wenn `validate=True`): Der Text an der angegebenen Position (`self.offset`) wird mit dem erwarteten Text verglichen. Wenn sie nicht \u00fcbereinstimmen, wird ein Fehler ausgel\u00f6st.  \n\n4. **R\u00fcckgabe der Referenz**: Wenn alle \u00dcberpr\u00fcfungen erfolgreich sind, wird die Referenz zur\u00fcckgegeben.\n\nZusammengefasst stellt die Funktion sicher, dass eine g\u00fcltige Referenz auf einen Textinhalt existiert und der Text an der angegebenen Position korrekt ist. Wenn etwas nicht stimmt, wird ein Fehler gemeldet."
  },
  {
    "code": "def xml(self, attribs = None,elements = None, skipchildren = False):\n        \"\"\"See :meth:`AbstractElement.xml`\"\"\"\n        attribs = {}\n        if not self.offset is None:\n            attribs['{' + NSFOLIA + '}offset'] = str(self.offset)\n        if self.parent and self.ref:\n            attribs['{' + NSFOLIA + '}ref'] = self.ref\n\n        #if self.cls != 'current' and not (self.cls == 'original' and any( isinstance(x, Original) for x in self.ancestors() )  ):\n        #    attribs['{' + NSFOLIA + '}class'] = self.cls\n        #else:\n        #    if '{' + NSFOLIA + '}class' in attribs:\n        #        del attribs['{' + NSFOLIA + '}class']\n        #return E.t(self.value, **attribs)\n\n        e = super(TextContent,self).xml(attribs,elements,skipchildren)\n        if '{' + NSFOLIA + '}class' in e.attrib and e.attrib['{' + NSFOLIA + '}class'] == \"current\":\n            #delete 'class=current'\n            del e.attrib['{' + NSFOLIA + '}class']\n\n        return e",
    "docstring": "See :meth:`AbstractElement.xml`",
    "summary": "Diese Funktion generiert ein XML-Element basierend auf den Attributen und Elementen, die ihr \u00fcbergeben werden. Hier ist eine einfache Erkl\u00e4rung in Deutsch:\n\n1. **Initialisierung**: Die Funktion beginnt damit, ein leeres W\u00f6rterbuch (`attribs = {}`) f\u00fcr die Attribute des XML-Elements zu erstellen.\n\n2. **Offset-Attribut**: Wenn das Objekt (`self`) einen Offset-Wert hat, wird dieser als Attribut mit dem Namen `{NSFOLIA}offset` hinzugef\u00fcgt.\n\n3. **Referenz-Attribut**: Wenn das Objekt einen Elternknoten (`parent`) und eine Referenz (`ref`) hat, wird diese Referenz als Attribut mit dem Namen `{NSFOLIA}ref` hinzugef\u00fcgt.\n\n4. **Vererbung und Anpassung**: Die Funktion ruft die `xml`-Methode der Elternklasse (`super(TextContent, self).xml`) auf, um das XML-Element zu erstellen. Anschlie\u00dfend wird \u00fcberpr\u00fcft, ob das Attribut `{NSFOLIA}class` mit dem Wert `\"current\"` vorhanden ist. Wenn ja, wird dieses Attribut gel\u00f6scht.\n\n5. **R\u00fcckgabe**: Das fertige XML-Element (`e`) wird zur\u00fcckgegeben.\n\n**Zusammenfassung**: Die Funktion erstellt ein XML-Element, f\u00fcgt bestimmte Attribute hinzu (wie Offset und Referenz), und entfernt das `class=\"current\"`-Attribut, falls es vorhanden ist. Sie basiert auf der Implementierung der Elternklasse und passt das Ergebnis an."
  },
  {
    "code": "def getreference(self, validate=True):\n        \"\"\"Return and validate the Phonetic Content's reference. Raises UnresolvableTextContent when invalid\"\"\"\n\n        if self.offset is None: return None #nothing to test\n        if self.ref:\n            ref = self.doc[self.ref]\n        else:\n            ref = self.finddefaultreference()\n\n        if not ref:\n            raise UnresolvableTextContent(\"Default reference for phonetic content not found!\")\n        elif not ref.hasphon(self.cls):\n            raise UnresolvableTextContent(\"Reference has no such phonetic content (class=\" + self.cls+\")\")\n        elif validate and self.phon() != ref.textcontent(self.cls).phon()[self.offset:self.offset+len(self.data[0])]:\n            raise UnresolvableTextContent(\"Reference (class=\" + self.cls+\") found but no phonetic match at specified offset (\"+str(self.offset)+\")! Expected '\" + self.text() + \"', got '\" + ref.textcontent(self.cls).text()[self.offset:self.offset+len(self.data[0])] +\"'\")\n        else:\n            #finally, we made it!\n            return ref",
    "docstring": "Return and validate the Phonetic Content's reference. Raises UnresolvableTextContent when invalid",
    "summary": "Diese Funktion, `getreference`, \u00fcberpr\u00fcft und gibt eine Referenz f\u00fcr phonetischen Inhalt zur\u00fcck. Hier ist eine einfache Erkl\u00e4rung, was sie macht:\n\n1. **\u00dcberpr\u00fcfung der Offset-Information**: Wenn es keinen Offset gibt (`self.offset is None`), gibt die Funktion `None` zur\u00fcck, da es nichts zu \u00fcberpr\u00fcfen gibt.\n\n2. **Referenz finden**: Die Funktion versucht, eine Referenz zu finden. Wenn es bereits eine Referenz gibt (`self.ref`), wird diese verwendet. Andernfalls wird eine Standardreferenz gesucht (`self.finddefaultreference()`).\n\n3. **\u00dcberpr\u00fcfung der Referenz**:\n   - Wenn keine Referenz gefunden wird, wird ein Fehler (`UnresolvableTextContent`) ausgel\u00f6st, der besagt, dass die Standardreferenz nicht gefunden wurde.\n   - Wenn die Referenz keinen phonetischen Inhalt der angegebenen Klasse (`self.cls`) enth\u00e4lt, wird ebenfalls ein Fehler ausgel\u00f6st.\n   - Wenn die Validierung aktiviert ist (`validate=True`), wird \u00fcberpr\u00fcft, ob der phonetische Inhalt der Referenz an der angegebenen Position (`self.offset`) mit dem erwarteten Inhalt \u00fcbereinstimmt. Wenn nicht, wird ein Fehler ausgel\u00f6st, der die Diskrepanz beschreibt.\n\n4. **R\u00fcckgabe der Referenz**: Wenn alle \u00dcberpr\u00fcfungen erfolgreich sind, gibt die Funktion die gefundene Referenz zur\u00fcck.\n\nZusammengefasst: Die Funktion sucht eine Referenz f\u00fcr phonetischen Inhalt, \u00fcberpr\u00fcft deren G\u00fcltigkeit und gibt sie zur\u00fcck, falls alles korrekt ist. Andernfalls wird ein Fehler ausgel\u00f6st, der das Problem beschreibt."
  },
  {
    "code": "def finddefaultreference(self):\n        \"\"\"Find the default reference for text offsets:\n          The parent of the current textcontent's parent (counting only Structure Elements and Subtoken Annotation Elements)\n\n          Note: This returns not a TextContent element, but its parent. Whether the textcontent actually exists is checked later/elsewhere\n        \"\"\"\n\n        depth = 0\n        e = self\n        while True:\n            if e.parent:\n                e = e.parent #pylint: disable=redefined-variable-type\n            else:\n                #no parent, breaking\n                return False\n\n            if isinstance(e,AbstractStructureElement) or isinstance(e,AbstractSubtokenAnnotation):\n                depth += 1\n                if depth == 2:\n                    return e\n\n\n        return False",
    "docstring": "Find the default reference for text offsets:\n          The parent of the current textcontent's parent (counting only Structure Elements and Subtoken Annotation Elements)\n\n          Note: This returns not a TextContent element, but its parent. Whether the textcontent actually exists is checked later/elsewhere",
    "summary": "Sicher! Hier ist eine einfache Erkl\u00e4rung der Funktion `finddefaultreference` auf Deutsch:\n\nDiese Funktion sucht nach dem Standard-Referenzpunkt f\u00fcr Text-Offsets. Sie tut dies, indem sie den \u00fcbergeordneten (Eltern-)Element des \u00fcbergeordneten Elements des aktuellen Textinhalts findet, wobei nur **Struktur-Elemente** und **Subtoken-Annotations-Elemente** ber\u00fccksichtigt werden.\n\nGenauer gesagt:\n\n1. **Startpunkt**: Die Funktion beginnt beim aktuellen Element (`self`).\n2. **Aufstieg in der Hierarchie**: Sie bewegt sich dann Stufe f\u00fcr Stufe nach oben in der Hierarchie der Elemente, indem sie jeweils das \u00fcbergeordnete Element (`parent`) des aktuellen Elements ausw\u00e4hlt.\n3. **Z\u00e4hlen der relevanten Ebenen**: Sie z\u00e4hlt dabei, wie oft sie auf ein **Struktur-Element** oder ein **Subtoken-Annotations-Element** st\u00f6\u00dft.\n4. **Ziel erreicht**: Sobald sie zwei solcher relevanten Ebenen durchlaufen hat (d.h., sie ist zwei Mal auf ein solches Element gesto\u00dfen), gibt sie das aktuelle \u00fcbergeordnete Element als Ergebnis zur\u00fcck.\n5. **Fehlerfall**: Wenn sie kein \u00fcbergeordnetes Element mehr findet (d.h., sie hat das oberste Element erreicht), gibt sie `False` zur\u00fcck, um anzuzeigen, dass kein Standard-Referenzpunkt gefunden wurde.\n\nZusammengefasst sucht die Funktion also zwei Ebenen \u00fcber dem aktuellen Textinhalt nach einem bestimmten Element und gibt dieses zur\u00fcck, falls es gefunden wird."
  },
  {
    "code": "def findreplaceables(Class, parent, set, **kwargs):#pylint: disable=bad-classmethod-argument\n        \"\"\"(Method for internal usage, see AbstractElement)\"\"\"\n        #some extra behaviour for text content elements, replace also based on the 'corrected' attribute:\n        if 'cls' not in kwargs:\n            kwargs['cls'] = 'current'\n        replace = super(PhonContent, Class).findreplaceables(parent, set, **kwargs)\n        replace = [ x for x in replace if x.cls == kwargs['cls']]\n        del kwargs['cls'] #always delete what we processed\n        return replace",
    "docstring": "(Method for internal usage, see AbstractElement)",
    "summary": "Dies ist eine Python-Funktion namens `findreplaceables`, die in einer Klasse namens `PhonContent` verwendet wird. Hier ist eine einfache Erkl\u00e4rung, was die Funktion tut:\n\n1. **Zweck**: Die Funktion sucht nach bestimmten Elementen (genannt \"ersetzbaren\" Elementen) innerhalb einer Struktur, die durch die Parameter `parent` und `set` definiert wird.\n\n2. **Zus\u00e4tzliche Logik f\u00fcr Textinhalte**: Wenn die Funktion f\u00fcr Textinhalte verwendet wird, ber\u00fccksichtigt sie ein zus\u00e4tzliches Attribut namens `'corrected'`.\n\n3. **Standardwert setzen**: Wenn das Schl\u00fcsselwortargument `'cls'` nicht angegeben wird, wird es standardm\u00e4\u00dfig auf `'current'` gesetzt.\n\n4. **Aufruf der Elternklasse**: Die Funktion ruft die gleiche Methode (`findreplaceables`) aus der Elternklasse (`super(PhonContent, Class)`) auf, um die ersetzbaren Elemente zu finden.\n\n5. **Filterung der Ergebnisse**: Die Ergebnisse werden gefiltert, sodass nur die Elemente zur\u00fcckgegeben werden, deren `'cls'`-Attribut mit dem Wert \u00fcbereinstimmt, der in `kwargs['cls']` angegeben wurde.\n\n6. **Aufr\u00e4umen**: Das `'cls'`-Argument wird aus `kwargs` entfernt, da es bereits verarbeitet wurde.\n\n7. **R\u00fcckgabe**: Die gefilterte Liste der ersetzbaren Elemente wird zur\u00fcckgegeben.\n\n**Zusammenfassung auf Deutsch**:  \nDie Funktion `findreplaceables` sucht nach bestimmten Elementen in einer Struktur, filtert sie basierend auf einem bestimmten Attribut (`'cls'`) und gibt die gefilterte Liste zur\u00fcck. Sie wird haupts\u00e4chlich intern verwendet und ber\u00fccksichtigt spezielle Logik f\u00fcr Textinhalte."
  },
  {
    "code": "def parsexml(Class, node, doc, **kwargs):#pylint: disable=bad-classmethod-argument\n        \"\"\"(Method for internal usage, see AbstractElement)\"\"\"\n        if not kwargs: kwargs = {}\n        if 'offset' in node.attrib:\n            kwargs['offset'] = int(node.attrib['offset'])\n        if 'ref' in node.attrib:\n            kwargs['ref'] = node.attrib['ref']\n        return super(PhonContent,Class).parsexml(node,doc, **kwargs)",
    "docstring": "(Method for internal usage, see AbstractElement)",
    "summary": "Sicher! Diese Funktion, `parsexml`, ist eine Methode, die in Python geschrieben ist und wahrscheinlich Teil einer gr\u00f6\u00dferen Klasse oder eines Moduls ist, das mit XML-Daten arbeitet. Hier ist eine einfache Erkl\u00e4rung auf Deutsch:\n\nDiese Funktion nimmt vier Parameter entgegen: `Class`, `node`, `doc` und `kwargs` (zus\u00e4tzliche Schl\u00fcsselwortargumente). Sie wird verwendet, um XML-Daten zu verarbeiten und in ein bestimmtes Format oder eine bestimmte Struktur umzuwandeln.\n\n1. **\u00dcberpr\u00fcfung von `kwargs`**: Zuerst wird \u00fcberpr\u00fcft, ob `kwargs` leer ist. Wenn ja, wird es als leeres W\u00f6rterbuch initialisiert.\n\n2. **Verarbeitung von Attributen**: Die Funktion pr\u00fcft, ob das `node`-Objekt bestimmte Attribute wie `offset` und `ref` enth\u00e4lt. Wenn diese Attribute vorhanden sind, werden ihre Werte in das `kwargs`-W\u00f6rterbuch aufgenommen. Dabei wird der Wert von `offset` in eine Ganzzahl umgewandelt.\n\n3. **Aufruf der Elternklasse**: Schlie\u00dflich wird die `parsexml`-Methode der Elternklasse (`super(PhonContent, Class)`) aufgerufen, wobei `node`, `doc` und die aktualisierten `kwargs` als Argumente \u00fcbergeben werden. Dies erm\u00f6glicht es, die XML-Verarbeitung in der Elternklasse fortzusetzen, w\u00e4hrend die spezifischen Attribute des aktuellen Knotens ber\u00fccksichtigt werden.\n\nZusammengefasst hilft diese Funktion dabei, XML-Daten zu parsen und spezifische Attribute zu extrahieren, bevor die Verarbeitung an die Elternklasse weitergegeben wird. Sie ist likely ein Teil einer gr\u00f6\u00dferen Bibliothek oder eines Frameworks, das mit XML-Daten arbeitet."
  },
  {
    "code": "def morphemes(self,set=None):\n        \"\"\"Generator yielding all morphemes (in a particular set if specified). For retrieving one specific morpheme by index, use morpheme() instead\"\"\"\n        for layer in self.select(MorphologyLayer):\n            for m in layer.select(Morpheme, set):\n                yield m",
    "docstring": "Generator yielding all morphemes (in a particular set if specified). For retrieving one specific morpheme by index, use morpheme() instead",
    "summary": "Sicher! Diese Funktion, `morphemes`, ist ein Generator, der alle **Morpheme** (kleinste bedeutungstragende Einheiten in einer Sprache) ausgibt. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Eingabeparameter**:  \n   - `set=None`: Du kannst optional einen bestimmten Satz (Set) von Morphemen angeben, aus dem die Funktion die Morpheme ausw\u00e4hlen soll. Wenn nichts angegeben wird (`None`), werden alle Morpheme ber\u00fccksichtigt.\n\n2. **Funktionsweise**:  \n   - Die Funktion durchl\u00e4uft alle **Morphologie-Ebenen** (`MorphologyLayer`) eines Objekts (wahrscheinlich eines Textes oder einer linguistischen Struktur).  \n   - F\u00fcr jede Morphologie-Ebene durchl\u00e4uft sie dann alle **Morpheme** (`Morpheme`), die entweder in dem angegebenen Set sind oder, falls kein Set angegeben wurde, alle Morpheme der Ebene.  \n   - Jedes Morphem wird nacheinander zur\u00fcckgegeben (`yield`), sodass du sie einzeln verarbeiten kannst.\n\n3. **Hinweis**:  \n   - Wenn du ein **spezifisches Morphem** nach seinem Index suchen m\u00f6chtest, solltest du stattdessen die Funktion `morpheme()` verwenden.\n\nZusammengefasst: Diese Funktion gibt dir alle Morpheme (oder eine bestimmte Gruppe davon) nacheinander aus, damit du sie weiterverarbeiten kannst."
  },
  {
    "code": "def phonemes(self,set=None):\n        \"\"\"Generator yielding all phonemes (in a particular set if specified). For retrieving one specific morpheme by index, use morpheme() instead\"\"\"\n        for layer in self.select(PhonologyLayer):\n            for p in layer.select(Phoneme, set):\n                yield p",
    "docstring": "Generator yielding all phonemes (in a particular set if specified). For retrieving one specific morpheme by index, use morpheme() instead",
    "summary": "Sicher! Diese Funktion, `phonemes`, ist ein Generator, der alle Phoneme (die kleinsten unterscheidbaren Einheiten in der Sprache) ausgibt. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Eingabeparameter**:  \n   - `set=None`: Du kannst optional einen bestimmten Satz von Phonemen angeben, den du ausgeben m\u00f6chtest. Wenn du nichts angibst (`None`), werden alle Phoneme ausgegeben.\n\n2. **Funktionsweise**:  \n   - Die Funktion durchl\u00e4uft alle `PhonologyLayer` (Schichten der Phonologie) des Objekts.  \n   - Innerhalb jeder Schicht durchl\u00e4uft sie alle `Phoneme`, die entweder zu dem angegebenen Satz geh\u00f6ren oder, falls kein Satz angegeben wurde, alle Phoneme.  \n   - Jedes Phonem wird dann nacheinander zur\u00fcckgegeben (mit `yield`), sodass du sie einzeln verarbeiten kannst.\n\n3. **Hinweis**:  \n   - Wenn du ein spezifisches Phonem anhand seines Index abrufen m\u00f6chtest, solltest du stattdessen die Funktion `morpheme()` verwenden.\n\nZusammengefasst: Diese Funktion gibt dir alle Phoneme (oder eine bestimmte Menge davon) nacheinander zur\u00fcck, damit du sie weiterverarbeiten kannst."
  },
  {
    "code": "def morpheme(self,index, set=None):\n        \"\"\"Returns a specific morpheme, the n'th morpheme (given the particular set if specified).\"\"\"\n        for layer in self.select(MorphologyLayer):\n            for i, m in enumerate(layer.select(Morpheme, set)):\n                if index == i:\n                    return m\n        raise NoSuchAnnotation",
    "docstring": "Returns a specific morpheme, the n'th morpheme (given the particular set if specified).",
    "summary": "Diese Funktion, `morpheme`, sucht in einem bestimmten Objekt (das `self` genannt wird) nach einem spezifischen Morphem. Ein Morphem ist die kleinste bedeutungstragende Einheit in einer Sprache, wie zum Beispiel ein Wortstamm oder eine Endung.\n\nHier ist, was die Funktion tut:\n\n1. **Eingaben**:\n   - `index`: Die Position (Nummer) des Morphems, das du finden m\u00f6chtest.\n   - `set` (optional): Eine spezifische Gruppe oder Kategorie von Morphemen, in der gesucht werden soll.\n\n2. **Funktionsweise**:\n   - Die Funktion durchsucht verschiedene Ebenen (`layers`) von morphologischen Annotationen (das sind Markierungen, die die Struktur von W\u00f6rtern beschreiben).\n   - In jeder Ebene durchl\u00e4uft sie die Liste der Morpheme.\n   - Wenn sie das Morphem an der angegebenen Position (`index`) findet, gibt sie dieses Morphem zur\u00fcck.\n   - Wenn das Morphem nicht gefunden wird, wird eine Fehlermeldung (`NoSuchAnnotation`) ausgel\u00f6st.\n\n3. **Zusammenfassung**:\n   Die Funktion hilft dir, ein bestimmtes Morphem an einer bestimmten Position (und optional in einer bestimmten Gruppe) zu finden und zur\u00fcckzugeben. Wenn es nicht gefunden wird, gibt es einen Fehler an.\n\n**Beispiel**:\nAngenommen, du hast ein Wort wie \"H\u00e4user\" und m\u00f6chtest das zweite Morphem (die Endung \"-er\") finden. Die Funktion w\u00fcrde dir dieses Morphem zur\u00fcckgeben, wenn es an der zweiten Position in der Liste der Morpheme steht."
  },
  {
    "code": "def phoneme(self,index, set=None):\n        \"\"\"Returns a specific phoneme, the n'th morpheme (given the particular set if specified).\"\"\"\n        for layer in self.select(PhonologyLayer):\n            for i, p in enumerate(layer.select(Phoneme, set)):\n                if index == i:\n                    return p\n        raise NoSuchAnnotation",
    "docstring": "Returns a specific phoneme, the n'th morpheme (given the particular set if specified).",
    "summary": "Diese Funktion, `phoneme`, sucht in einem bestimmten linguistischen Datenmodell (vermutlich einem Text oder einer Annotation) nach einem spezifischen Phonem (einem einzelnen Laut) an einer bestimmten Position (Index). \n\nHier ist eine Schritt-f\u00fcr-Schritt Erkl\u00e4rung:\n\n1. **Eingabeparameter**:\n   - `index`: Die Position (Nummer) des gew\u00fcnschten Phonems.\n   - `set` (optional): Eine spezifische Menge oder Kategorie von Phonemen, in der gesucht werden soll.\n\n2. **Funktionsweise**:\n   - Die Funktion durchsucht alle **Phonologie-Ebenen** (`PhonologyLayer`) des Datenmodells.\n   - Innerhalb jeder Ebene durchl\u00e4uft sie alle **Phonome** (`Phoneme`), entweder in der angegebenen Menge (`set`) oder in allen, falls keine Menge angegeben wurde.\n   - Sie z\u00e4hlt die Phoneme (mit `enumerate`) und vergleicht den Z\u00e4hler (`i`) mit dem angegebenen `index`.\n   - Wenn der Z\u00e4hler mit dem `index` \u00fcbereinstimmt, gibt die Funktion das entsprechende Phonem (`p`) zur\u00fcck.\n\n3. **Fehlerbehandlung**:\n   - Wenn kein Phonem an der angegebenen Position gefunden wird, wird eine Ausnahme (`NoSuchAnnotation`) ausgel\u00f6st, die anzeigt, dass das gew\u00fcnschte Phonem nicht existiert.\n\n**Zusammenfassung auf Deutsch**:\nDie Funktion `phoneme` gibt ein bestimmtes Phonem an einer bestimmten Position zur\u00fcck, wobei optional eine spezifische Menge von Phonemen durchsucht werden kann. Wenn das Phonem nicht gefunden wird, wird ein Fehler gemeldet."
  },
  {
    "code": "def findspans(self, type,set=None):\n        \"\"\"Yields span annotation elements of the specified type that include this word.\n\n        Arguments:\n            type: The annotation type, can be passed as using any of the :class:`AnnotationType` member, or by passing the relevant :class:`AbstractSpanAnnotation` or :class:`AbstractAnnotationLayer` class.\n            set (str or None): Constrain by set\n\n        Example::\n\n            for chunk in word.findspans(folia.Chunk):\n                print(\" Chunk class=\", chunk.cls, \" words=\")\n                for word2 in chunk.wrefs(): #print all words in the chunk (of which the word is a part)\n                    print(word2, end=\"\")\n                print()\n\n        Yields:\n            Matching span annotation instances (derived from :class:`AbstractSpanAnnotation`)\n        \"\"\"\n\n        if issubclass(type, AbstractAnnotationLayer):\n            layerclass = type\n        else:\n            layerclass = ANNOTATIONTYPE2LAYERCLASS[type.ANNOTATIONTYPE]\n        e = self\n        while True:\n            if not e.parent: break\n            e = e.parent\n            for layer in e.select(layerclass,set,False):\n                if type is layerclass:\n                    for e2 in layer.select(AbstractSpanAnnotation,set,True, (True, Word, Morpheme)):\n                        if not isinstance(e2, AbstractSpanRole) and self in e2.wrefs():\n                            yield e2\n                else:\n                    for e2 in layer.select(type,set,True, (True, Word, Morpheme)):\n                        if not isinstance(e2, AbstractSpanRole) and self in e2.wrefs():\n                            yield e2",
    "docstring": "Yields span annotation elements of the specified type that include this word.\n\n        Arguments:\n            type: The annotation type, can be passed as using any of the :class:`AnnotationType` member, or by passing the relevant :class:`AbstractSpanAnnotation` or :class:`AbstractAnnotationLayer` class.\n            set (str or None): Constrain by set\n\n        Example::\n\n            for chunk in word.findspans(folia.Chunk):\n                print(\" Chunk class=\", chunk.cls, \" words=\")\n                for word2 in chunk.wrefs(): #print all words in the chunk (of which the word is a part)\n                    print(word2, end=\"\")\n                print()\n\n        Yields:\n            Matching span annotation instances (derived from :class:`AbstractSpanAnnotation`)",
    "summary": "Dies ist eine Python-Funktion namens `findspans`, die in einem gr\u00f6\u00dferen Kontext (wahrscheinlich einer Klasse, die mit Text- oder Sprachannotationen arbeitet) verwendet wird. Hier ist eine einfache Erkl\u00e4rung auf Deutsch:\n\nDie Funktion `findspans` sucht nach bestimmten **Annotationen** (Markierungen oder Beschriftungen) in einem Text, die ein bestimmtes **Wort** (das durch `self` dargestellt wird) enthalten. Sie gibt diese Annotationselemente zur\u00fcck, die dem angegebenen **Typ** entsprechen und optional zu einem bestimmten **Set** geh\u00f6ren.\n\n**Was die Funktion tut:**\n\n1. **Eingaben:**\n   - `type`: Der Typ der Annotation, nach der gesucht werden soll (z. B. ein bestimmter Typ von Textspanne wie ein \"Chunk\").\n   - `set` (optional): Ein Set, das die Suche auf bestimmte Annotationselemente beschr\u00e4nkt.\n\n2. **Funktionsweise:**\n   - Die Funktion durchl\u00e4uft die \u00fcbergeordneten Elemente (Eltern) des aktuellen Worts, um Annotationsebenen zu finden, die den angegebenen Typ enthalten.\n   - Sie pr\u00fcft, ob das Wort in den gefundenen Annotationselementen enthalten ist.\n   - Wenn ja, gibt sie diese Annotationselemente zur\u00fcck (als Generator, d. h. eines nach dem anderen).\n\n3. **Ausgabe:**\n   - Die Funktion gibt passende Annotationselemente zur\u00fcck, die vom Typ `AbstractSpanAnnotation` abgeleitet sind.\n\n**Beispiel:**\nAngenommen, du suchst nach allen \"Chunks\" (Textbl\u00f6cken), die ein bestimmtes Wort enthalten. Die Funktion w\u00fcrde dir alle diese Chunks zur\u00fcckgeben, sodass du z. B. die W\u00f6rter in diesen Chunks ausgeben oder weiterverarbeiten kannst.\n\nZusammengefasst: Die Funktion hilft dabei, Annotationselemente in einem Text zu finden, die ein bestimmtes Wort enthalten, und gibt diese Elemente zur\u00fcck, damit du mit ihnen weiterarbeiten kannst."
  },
  {
    "code": "def deepvalidation(self):\n        \"\"\"Perform deep validation of this element.\n\n        Raises:\n            :class:`DeepValidationError`\n        \"\"\"\n        if self.doc and self.doc.deepvalidation and self.parent.set and self.parent.set[0] != '_':\n            try:\n                self.doc.setdefinitions[self.parent.set].testsubclass(self.parent.cls, self.subset, self.cls)\n            except KeyError as e:\n                if self.parent.cls and not self.doc.allowadhocsets:\n                    raise DeepValidationError(\"Set definition \" + self.parent.set + \" for \" + self.parent.XMLTAG + \" not loaded (feature validation failed)!\")\n            except DeepValidationError as e:\n                errormsg =  str(e) + \" (in set \" + self.parent.set+\" for \" + self.parent.XMLTAG\n                if self.parent.id:\n                    errormsg += \" with ID \" + self.parent.id\n                errormsg +=  \")\"\n                raise DeepValidationError(errormsg)",
    "docstring": "Perform deep validation of this element.\n\n        Raises:\n            :class:`DeepValidationError`",
    "summary": "Diese Funktion, `deepvalidation`, f\u00fchrt eine tiefe Validierung eines Elements durch. Hier ist eine einfache Erkl\u00e4rung, was sie macht:\n\n1. **\u00dcberpr\u00fcfung von Bedingungen**: Die Funktion pr\u00fcft zun\u00e4chst, ob bestimmte Bedingungen erf\u00fcllt sind, wie z.B. ob ein Dokument (`self.doc`) existiert, ob eine tiefe Validierung aktiviert ist (`self.doc.deepvalidation`), und ob das \u00fcbergeordnete Element (`self.parent`) einen bestimmten Satz (`set`) hat, der nicht mit einem Unterstrich (`_`) beginnt.\n\n2. **Test der Unterklasse**: Wenn diese Bedingungen erf\u00fcllt sind, versucht die Funktion, eine Unterklasse zu testen, indem sie eine Methode namens `testsubclass` aufruft. Diese Methode \u00fcberpr\u00fcft, ob das aktuelle Element (`self.parent.cls`) mit einer bestimmten Definition in einem Satz (`self.doc.setdefinitions[self.parent.set]`) \u00fcbereinstimmt.\n\n3. **Fehlerbehandlung**:\n   - **KeyError**: Wenn die Satzdefinition nicht gefunden wird und das \u00fcbergeordnete Element eine Klasse hat (`self.parent.cls`), aber adhoc-S\u00e4tze nicht erlaubt sind (`self.doc.allowadhocsets`), wird ein `DeepValidationError` ausgel\u00f6st, der angibt, dass die Satzdefinition nicht geladen wurde.\n   - **DeepValidationError**: Wenn w\u00e4hrend der Validierung ein Fehler auftritt, wird eine detaillierte Fehlermeldung erstellt, die den Kontext (z.B. den Satz, das XML-Tag und optional die ID des \u00fcbergeordneten Elements) enth\u00e4lt, und ein neuer `DeepValidationError` wird ausgel\u00f6st.\n\nZusammengefasst stellt diese Funktion sicher, dass ein Element tiefgehend validiert wird und gibt detaillierte Fehlermeldungen aus, wenn etwas nicht den Erwartungen entspricht."
  },
  {
    "code": "def xml(self, attribs = None,elements = None, skipchildren = False):\n        \"\"\"See :meth:`AbstractElement.xml`\"\"\"\n        if not attribs: attribs = {}\n        E = ElementMaker(namespace=\"http://ilk.uvt.nl/folia\",nsmap={None: \"http://ilk.uvt.nl/folia\", 'xml' : \"http://www.w3.org/XML/1998/namespace\"})\n        e = super(AbstractSpanAnnotation,self).xml(attribs, elements, True)\n        for child in self:\n            if isinstance(child, (Word, Morpheme, Phoneme)):\n                #Include REFERENCES to word items instead of word items themselves\n                attribs['{' + NSFOLIA + '}id'] = child.id\n                if child.PRINTABLE and child.hastext(self.textclass):\n                    attribs['{' + NSFOLIA + '}t'] = child.text(self.textclass)\n                e.append( E.wref(**attribs) )\n            elif not (isinstance(child, Feature) and child.SUBSET): #Don't add pre-defined features, they are already added as attributes\n                e.append( child.xml() )\n        return e",
    "docstring": "See :meth:`AbstractElement.xml`",
    "summary": "Dieser Codeausschnitt ist eine Python-Funktion, die Teil einer Klasse namens `AbstractSpanAnnotation` ist. Die Funktion `xml` generiert eine XML-Darstellung des Objekts, das sie aufruft, und ber\u00fccksichtigt dabei bestimmte Attribute und Elemente. Hier ist eine einfache Erkl\u00e4rung in Deutsch:\n\n1. **Eingabeparameter**:\n   - `attribs`: Ein W\u00f6rterbuch mit Attributen, die in der XML-Darstellung verwendet werden sollen. Wenn kein W\u00f6rterbuch \u00fcbergeben wird, wird ein leeres erstellt.\n   - `elements`: Optionale Elemente, die in der XML-Darstellung ber\u00fccksichtigt werden sollen.\n   - `skipchildren`: Ein boolescher Wert, der angibt, ob untergeordnete Elemente \u00fcbersprungen werden sollen.\n\n2. **Namespace-Definition**:\n   - Die Funktion verwendet einen spezifischen XML-Namespace (`http://ilk.uvt.nl/folia`) und eine Namespace-Zuordnung, um sicherzustellen, dass die XML-Elemente korrekt qualifiziert sind.\n\n3. **Erstellen des XML-Elements**:\n   - Die Funktion ruft die `xml`-Methode der Elternklasse (`super`) auf, um das grundlegende XML-Element zu erstellen.\n\n4. **Verarbeitung von untergeordneten Elementen**:\n   - Die Funktion durchl\u00e4uft alle untergeordneten Elemente (`child`) des aktuellen Objekts.\n   - Wenn ein untergeordnetes Element ein `Word`, `Morpheme` oder `Phoneme` ist, wird eine Referenz (`wref`) auf dieses Element erstellt, anstatt das Element selbst einzuf\u00fcgen. Dabei werden bestimmte Attribute wie die ID und der Text des Elements hinzugef\u00fcgt.\n   - Wenn das untergeordnete Element kein `Feature` ist oder kein Teil eines vordefinierten Subsets, wird es rekursiv in die XML-Darstellung eingef\u00fcgt.\n\n5. **R\u00fcckgabewert**:\n   - Die Funktion gibt das erstellte XML-Element (`e`) zur\u00fcck, das alle verarbeiteten Attribute und untergeordneten Elemente enth\u00e4lt.\n\nZusammenfassend generiert diese Funktion eine XML-Darstellung eines `AbstractSpanAnnotation`-Objekts, wobei sie spezifische Regeln f\u00fcr die Behandlung von untergeordneten Elementen und Attributen befolgt."
  },
  {
    "code": "def append(self, child, *args, **kwargs):\n        \"\"\"See :meth:`AbstractElement.append`\"\"\"\n        #Accept Word instances instead of WordReference, references will be automagically used upon serialisation\n        if isinstance(child, (Word, Morpheme, Phoneme)) and WordReference in self.ACCEPTED_DATA:\n            #We don't really append but do an insertion so all references are in proper order\n            insertionpoint = len(self.data)\n            for i, sibling in enumerate(self.data):\n                if isinstance(sibling, (Word, Morpheme, Phoneme)):\n                    try:\n                        if not sibling.precedes(child):\n                            insertionpoint = i\n                    except: #happens if we can't determine common ancestors\n                        pass\n\n            self.data.insert(insertionpoint, child)\n            return child\n        elif isinstance(child, AbstractSpanAnnotation): #(covers span roles just as well)\n            insertionpoint = len(self.data)\n            try:\n                firstword = child.wrefs(0)\n            except IndexError:\n                #we have no basis to determine an insertionpoint for this child, just append it then\n                return super(AbstractSpanAnnotation,self).append(child, *args, **kwargs)\n\n            insertionpoint = len(self.data)\n            for i, sibling in enumerate(self.data):\n                if isinstance(sibling, (Word, Morpheme, Phoneme)):\n                    try:\n                        if not sibling.precedes(firstword):\n                            insertionpoint = i\n                    except: #happens if we can't determine common ancestors\n                        pass\n            return super(AbstractSpanAnnotation,self).insert(insertionpoint, child, *args, **kwargs)\n        else:\n            return super(AbstractSpanAnnotation,self).append(child, *args, **kwargs)",
    "docstring": "See :meth:`AbstractElement.append`",
    "summary": "Dieser Code ist eine Funktion in Python, die Teil einer Klasse namens `AbstractSpanAnnotation` ist. Die Funktion `append` f\u00fcgt ein neues Element (`child`) zu einer internen Datenstruktur (`self.data`) hinzu, aber mit einer speziellen Logik, um die Reihenfolge der Elemente zu erhalten.\n\nHier ist eine einfache Erkl\u00e4rung in Deutsch:\n\n1. **\u00dcberpr\u00fcfung des Elements**: Die Funktion pr\u00fcft, ob das hinzuzuf\u00fcgende Element (`child`) ein `Word`, `Morpheme` oder `Phoneme` ist und ob solche Elemente in der Datenstruktur akzeptiert werden.\n\n2. **Bestimmung der Einf\u00fcgeposition**: Anstatt das Element einfach ans Ende anzuh\u00e4ngen, wird eine geeignete Position innerhalb der Datenstruktur gesucht, um sicherzustellen, dass die Reihenfolge der Elemente korrekt bleibt. Dies geschieht, indem die Funktion \u00fcberpr\u00fcft, ob das neue Element vor oder nach den bereits vorhandenen Elementen eingef\u00fcgt werden sollte.\n\n3. **Einf\u00fcgen des Elements**: Das Element wird an der bestimmten Position eingef\u00fcgt, um die richtige Reihenfolge zu gew\u00e4hrleisten.\n\n4. **Behandlung von Annotationen**: Wenn das hinzuzuf\u00fcgende Element eine `AbstractSpanAnnotation` ist, wird eine \u00e4hnliche Logik angewendet, um die richtige Einf\u00fcgeposition zu finden, basierend auf den Referenzen (`wrefs`) der Annotation.\n\n5. **Standardverhalten**: Wenn das Element nicht in die speziellen Kategorien f\u00e4llt, wird das Standardverhalten der Basisklasse (`super`) verwendet, um das Element einfach anzuh\u00e4ngen.\n\nZusammenfassend sorgt diese Funktion daf\u00fcr, dass Elemente in einer bestimmten Reihenfolge in die Datenstruktur eingef\u00fcgt werden, insbesondere wenn es sich um W\u00f6rter, Morpheme oder Phoneme handelt, und behandelt Annotationen auf \u00e4hnliche Weise."
  },
  {
    "code": "def setspan(self, *args):\n        \"\"\"Sets the span of the span element anew, erases all data inside.\n\n        Arguments:\n            *args: Instances of :class:`Word`, :class:`Morpheme` or :class:`Phoneme`\n        \"\"\"\n        self.data = []\n        for child in args:\n            self.append(child)",
    "docstring": "Sets the span of the span element anew, erases all data inside.\n\n        Arguments:\n            *args: Instances of :class:`Word`, :class:`Morpheme` or :class:`Phoneme`",
    "summary": "Sicher! Diese Funktion `setspan` aktualisiert den Inhalt eines Span-Elements und l\u00f6scht dabei alle vorherigen Daten. Sie nimmt eine beliebige Anzahl von Argumenten entgegen, die Instanzen der Klassen `Word`, `Morpheme` oder `Phoneme` sein m\u00fcssen. Diese Argumente werden dann nacheinander dem Span-Element hinzugef\u00fcgt, indem sie mit der `append`-Methode an das Attribut `data` angeh\u00e4ngt werden.\n\nZusammengefasst: Die Funktion leert das Span-Element und f\u00fcllt es neu mit den \u00fcbergebenen Elementen."
  },
  {
    "code": "def hasannotation(self,Class,set=None):\n        \"\"\"Returns an integer indicating whether such as annotation exists, and if so, how many. See ``annotations()`` for a description of the parameters.\"\"\"\n        return self.count(Class,set,True,default_ignore_annotations)",
    "docstring": "Returns an integer indicating whether such as annotation exists, and if so, how many. See ``annotations()`` for a description of the parameters.",
    "summary": "Sicher! Diese Funktion `hasannotation` \u00fcberpr\u00fcft, ob eine bestimmte Anmerkung (Annotation) in einem bestimmten Kontext existiert, und gibt die Anzahl dieser Anmerkungen zur\u00fcck. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Parameter**:\n   - `self`: Bezieht sich auf die Instanz der Klasse, in der die Funktion aufgerufen wird.\n   - `Class`: Die Art der Anmerkung, nach der gesucht wird.\n   - `set`: Ein optionaler Parameter, der eine Menge von Elementen angibt, in denen nach der Anmerkung gesucht werden soll. Wenn `None`, wird in einem Standardkontext gesucht.\n\n2. **Funktionsweise**:\n   - Die Funktion verwendet die Methode `self.count`, um die Anzahl der Anmerkungen vom Typ `Class` zu z\u00e4hlen.\n   - Der Parameter `True` gibt an, dass die Suche nach Anmerkungen durchgef\u00fchrt werden soll.\n   - `default_ignore_annotations` ist eine Standardliste von Anmerkungen, die ignoriert werden sollen, falls vorhanden.\n\n3. **R\u00fcckgabewert**:\n   - Die Funktion gibt eine Ganzzahl (`integer`) zur\u00fcck, die angibt, wie viele Anmerkungen vom Typ `Class` gefunden wurden. Wenn keine Anmerkungen gefunden werden, wird 0 zur\u00fcckgegeben.\n\nZusammengefasst pr\u00fcft die Funktion, ob eine bestimmte Anmerkung existiert, und gibt die Anzahl der gefundenen Anmerkungen zur\u00fcck."
  },
  {
    "code": "def annotation(self, type, set=None):\n        \"\"\"Will return a **single** annotation (even if there are multiple). Raises a ``NoSuchAnnotation`` exception if none was found\"\"\"\n        l = list(self.select(type,set,True,default_ignore_annotations))\n        if len(l) >= 1:\n            return l[0]\n        else:\n            raise NoSuchAnnotation()",
    "docstring": "Will return a **single** annotation (even if there are multiple). Raises a ``NoSuchAnnotation`` exception if none was found",
    "summary": "Sicher! Hier ist eine einfache Erkl\u00e4rung der Funktion auf Deutsch:\n\nDiese Funktion namens `annotation` sucht nach einer bestimmten **Anmerkung** (Annotation) in einem Datensatz. Sie nimmt zwei Parameter entgegen:\n\n1. **`type`**: Der Typ oder die Kategorie der Anmerkung, nach der gesucht werden soll.\n2. **`set`**: Ein optionaler Parameter, der angibt, in welchem Satz oder Bereich nach der Anmerkung gesucht werden soll.\n\nDie Funktion funktioniert wie folgt:\n\n- Sie durchsucht den Datensatz nach Anmerkungen des angegebenen Typs.\n- Wenn sie mindestens eine Anmerkung findet, gibt sie die **erste** gefundene Anmerkung zur\u00fcck.\n- Wenn keine Anmerkung gefunden wird, l\u00f6st sie einen Fehler (`NoSuchAnnotation`) aus, um anzuzeigen, dass keine passende Anmerkung vorhanden ist.\n\nZusammengefasst: Die Funktion sucht nach einer bestimmten Anmerkung und gibt sie zur\u00fcck, falls vorhanden. Wenn nicht, wird ein Fehler gemeldet."
  },
  {
    "code": "def _helper_wrefs(self, targets, recurse=True):\n        \"\"\"Internal helper function\"\"\"\n        for c in self:\n            if isinstance(c,Word) or isinstance(c,Morpheme) or isinstance(c, Phoneme):\n                targets.append(c)\n            elif isinstance(c,WordReference):\n                try:\n                    targets.append(self.doc[c.id]) #try to resolve\n                except KeyError:\n                    targets.append(c) #add unresolved\n            elif isinstance(c, AbstractSpanAnnotation) and recurse:\n                #recursion\n                c._helper_wrefs(targets) #pylint: disable=protected-access\n            elif isinstance(c, Correction) and c.auth: #recurse into corrections\n                for e in c:\n                    if isinstance(e, AbstractCorrectionChild) and e.auth:\n                        for e2 in e:\n                            if isinstance(e2, AbstractSpanAnnotation):\n                                #recursion\n                                e2._helper_wrefs(targets)",
    "docstring": "Internal helper function",
    "summary": "Dieser Code ist eine interne Hilfsfunktion in Python, die eine Liste von Zielen (`targets`) mit bestimmten Elementen f\u00fcllt, die in einer Struktur (vermutlich einem Dokument oder einer Annotation) gefunden werden. Hier ist eine einfache Erkl\u00e4rung, was die Funktion tut:\n\n1. **Durchlaufen der Elemente**: Die Funktion durchl\u00e4uft alle Elemente (`c`) in der aktuellen Instanz (`self`).\n\n2. **\u00dcberpr\u00fcfen des Typs der Elemente**:\n   - Wenn das Element ein `Word`, `Morpheme` oder `Phoneme` ist, wird es direkt zur Liste `targets` hinzugef\u00fcgt.\n   - Wenn das Element ein `WordReference` ist, versucht die Funktion, die Referenz aufzul\u00f6sen (d.h., das entsprechende Element im Dokument zu finden). Wenn dies nicht gelingt, wird die unaufgel\u00f6ste Referenz hinzugef\u00fcgt.\n   - Wenn das Element eine `AbstractSpanAnnotation` ist und `recurse` auf `True` gesetzt ist, wird die Funktion rekursiv aufgerufen, um auch die untergeordneten Elemente zu verarbeiten.\n   - Wenn das Element eine `Correction` ist und eine Autorisierung (`auth`) hat, werden die untergeordneten Elemente (`AbstractCorrectionChild`) durchlaufen. Wenn diese ebenfalls autorisiert sind und `AbstractSpanAnnotation`-Elemente enthalten, wird die Funktion erneut rekursiv aufgerufen.\n\n3. **Zusammenfassung**: Die Funktion sammelt also alle relevanten W\u00f6rter, Morpheme, Phoneme und Referenzen in der Liste `targets`, wobei sie bei Bedarf rekursiv in tiefer liegende Strukturen vordringt, um alle relevanten Elemente zu erfassen.\n\n**Zusammengefasst**: Die Funktion durchsucht eine Struktur rekursiv nach bestimmten linguistischen Elementen (wie W\u00f6rtern, Morphemen oder Phonemen) und sammelt sie in einer Liste, wobei sie auch Referenzen aufl\u00f6st oder unver\u00e4ndert hinzuf\u00fcgt, falls n\u00f6tig."
  },
  {
    "code": "def wrefs(self, index = None, recurse=True):\n        \"\"\"Returns a list of word references, these can be Words but also Morphemes or Phonemes.\n\n        Arguments:\n            index (int or None): If set to an integer, will retrieve and return the n'th element (starting at 0) instead of returning the list of all\n        \"\"\"\n        targets =[]\n        self._helper_wrefs(targets, recurse)\n        if index is None:\n            return targets\n        else:\n            return targets[index]",
    "docstring": "Returns a list of word references, these can be Words but also Morphemes or Phonemes.\n\n        Arguments:\n            index (int or None): If set to an integer, will retrieve and return the n'th element (starting at 0) instead of returning the list of all",
    "summary": "Diese Funktion, `wrefs`, gibt eine Liste von Wortreferenzen zur\u00fcck, die W\u00f6rter, Morpheme oder Phoneme sein k\u00f6nnen. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Parameter**:\n   - `index`: Ein optionaler Parameter, der entweder eine Ganzzahl (int) oder `None` sein kann. Wenn eine Ganzzahl angegeben wird, gibt die Funktion nur das Element an dieser Position in der Liste zur\u00fcck (z. B. `index=0` gibt das erste Element zur\u00fcck).\n   - `recurse`: Ein boolescher Parameter, der standardm\u00e4\u00dfig `True` ist. Er bestimmt, ob die Funktion rekursiv arbeitet, um alle Referenzen zu sammeln.\n\n2. **Funktionsweise**:\n   - Die Funktion initialisiert eine leere Liste namens `targets`.\n   - Sie ruft dann eine Hilfsfunktion `_helper_wrefs` auf, die die eigentliche Arbeit erledigt und die Referenzen in die `targets`-Liste einf\u00fcgt.\n   - Wenn `index` nicht angegeben ist (`None`), gibt die Funktion die gesamte Liste `targets` zur\u00fcck.\n   - Wenn `index` eine Ganzzahl ist, gibt die Funktion nur das Element an der angegebenen Position in der Liste zur\u00fcck.\n\n3. **Zusammenfassung**:\n   - Ohne `index` gibt die Funktion alle Wortreferenzen zur\u00fcck.\n   - Mit `index` gibt sie nur die spezifische Referenz an der angegebenen Position zur\u00fcck.\n\nAuf Deutsch: Die Funktion sammelt Wortreferenzen und gibt entweder alle oder eine bestimmte Referenz basierend auf dem angegebenen Index zur\u00fcck."
  },
  {
    "code": "def addtoindex(self,norecurse=None):\n        \"\"\"Makes sure this element (and all subelements), are properly added to the index\"\"\"\n        if not norecurse: norecurse = (Word, Morpheme, Phoneme)\n        if self.id:\n            self.doc.index[self.id] = self\n        for e in self.data:\n            if all([not isinstance(e, C) for C in norecurse]):\n                try:\n                    e.addtoindex(norecurse)\n                except AttributeError:\n                    pass",
    "docstring": "Makes sure this element (and all subelements), are properly added to the index",
    "summary": "Sicher! Diese Funktion `addtoindex` stellt sicher, dass das aktuelle Element (und alle seine Unterelemente) korrekt in einen Index hinzugef\u00fcgt werden. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Parameter `norecurse`**: Dies ist eine Option, um bestimmte Elementtypen von der rekursiven Indizierung auszuschlie\u00dfen. Standardm\u00e4\u00dfig sind `Word`, `Morpheme` und `Phoneme` ausgeschlossen, falls nicht anders angegeben.\n\n2. **\u00dcberpr\u00fcfung der ID**: Wenn das aktuelle Element eine `id` hat, wird es in den Index des Dokuments (`self.doc.index`) unter dieser ID gespeichert.\n\n3. **Durchlaufen der Unterelemente**: Die Funktion durchl\u00e4uft alle Unterelemente (`self.data`) des aktuellen Elements.\n\n4. **\u00dcberpr\u00fcfung des Typs**: F\u00fcr jedes Unterelement wird \u00fcberpr\u00fcft, ob es **nicht** einer der in `norecurse` angegebenen Typen ist. Wenn das Unterelement keinen der ausgeschlossenen Typen hat, wird die `addtoindex`-Funktion rekursiv aufgerufen, um auch dieses Unterelement und seine Kinder in den Index aufzunehmen.\n\n5. **Fehlerbehandlung**: Falls ein Unterelement keine `addtoindex`-Methode hat (z. B. weil es ein einfaches Datenobjekt ist), wird der Fehler ignoriert.\n\nZusammengefasst sorgt diese Funktion daf\u00fcr, dass alle relevanten Elemente in einer Hierarchie korrekt in einen Index aufgenommen werden, w\u00e4hrend bestimmte Typen (wie `Word`, `Morpheme`, `Phoneme`) von der rekursiven Indizierung ausgeschlossen werden k\u00f6nnen."
  },
  {
    "code": "def copychildren(self, newdoc=None, idsuffix=\"\"):\n        \"\"\"Generator creating a deep copy of the children of this element. If idsuffix is a string, if set to True, a random idsuffix will be generated including a random 32-bit hash\"\"\"\n        if idsuffix is True: idsuffix = \".copy.\" + \"%08x\" % random.getrandbits(32) #random 32-bit hash for each copy, same one will be reused for all children\n        for c in self:\n            if isinstance(c, Word):\n                yield WordReference(newdoc, id=c.id)\n            else:\n                yield c.copy(newdoc,idsuffix)",
    "docstring": "Generator creating a deep copy of the children of this element. If idsuffix is a string, if set to True, a random idsuffix will be generated including a random 32-bit hash",
    "summary": "Sicher! Hier ist eine einfache Erkl\u00e4rung der Funktion `copychildren` auf Deutsch:\n\nDie Funktion `copychildren` erstellt eine **tiefe Kopie** (d.h. eine vollst\u00e4ndige Kopie aller untergeordneten Elemente) der Kinder eines bestimmten Elements. Sie kann optional einen neuen Dokumentkontext (`newdoc`) und einen Suffix f\u00fcr die IDs der kopierten Elemente (`idsuffix`) annehmen.\n\n**Was die Funktion genau tut:**\n\n1. **Zuf\u00e4lliges IDsuffix:** Wenn `idsuffix` auf `True` gesetzt ist, wird ein zuf\u00e4lliges Suffix generiert, das einen 32-Bit-Hash enth\u00e4lt. Dieses Suffix wird an die IDs der kopierten Elemente angeh\u00e4ngt, um sicherzustellen, dass sie eindeutig sind.\n2. **Durchlaufen der Kinder:** Die Funktion durchl\u00e4uft alle Kinder des aktuellen Elements.\n3. **Kopieren der Kinder:**\n   - Wenn ein Kind vom Typ `Word` ist, wird eine `WordReference` erstellt, die auf das urspr\u00fcngliche Wort verweist.\n   - F\u00fcr alle anderen Kinder wird die `copy`-Methode aufgerufen, um eine tiefe Kopie des Kindes zu erstellen. Dabei wird der neue Dokumentkontext (`newdoc`) und das IDsuffix (`idsuffix`) \u00fcbergeben.\n\n**Zusammenfassend:** Die Funktion `copychildren` erstellt eine tiefe Kopie der Kinder eines Elements, wobei sie optional einen neuen Dokumentkontext und ein IDsuffix f\u00fcr die kopierten Elemente verwendet. Sie ist besonders n\u00fctzlich, wenn man eine unabh\u00e4ngige Kopie eines Teils eines Dokuments erstellen m\u00f6chte, ohne die urspr\u00fcnglichen Daten zu ver\u00e4ndern."
  },
  {
    "code": "def xml(self, attribs = None,elements = None, skipchildren = False):\n        \"\"\"See :meth:`AbstractElement.xml`\"\"\"\n        if self.set is False or self.set is None:\n            if len(self.data) == 0: #just skip if there are no children\n                return None\n            else:\n                raise ValueError(\"No set specified or derivable for annotation layer \" + self.__class__.__name__)\n        return super(AbstractAnnotationLayer, self).xml(attribs, elements, skipchildren)",
    "docstring": "See :meth:`AbstractElement.xml`",
    "summary": "Dies ist eine Python-Funktion, die Teil einer Klasse namens `AbstractAnnotationLayer` ist. Sie generiert eine XML-Darstellung des aktuellen Objekts. Hier ist eine einfache Erkl\u00e4rung in Deutsch:\n\n1. **Eingabeparameter**:\n   - `attribs`: Optionale Attribute, die in der XML-Darstellung verwendet werden sollen.\n   - `elements`: Optionale Elemente, die in der XML-Darstellung enthalten sein sollen.\n   - `skipchildren`: Ein boolescher Wert, der angibt, ob untergeordnete Elemente \u00fcbersprungen werden sollen.\n\n2. **Funktionsweise**:\n   - Die Funktion \u00fcberpr\u00fcft zun\u00e4chst, ob das Attribut `set` des Objekts `False` oder `None` ist. Wenn dies der Fall ist und das Objekt keine Daten (`self.data`) enth\u00e4lt, gibt die Funktion `None` zur\u00fcck, da es nichts zu tun gibt.\n   - Wenn `set` nicht festgelegt ist, aber das Objekt Daten enth\u00e4lt, wird ein `ValueError` ausgel\u00f6st, da keine Annotationsebene festgelegt oder abgeleitet werden kann.\n   - Wenn `set` korrekt festgelegt ist, wird die Methode `xml` der Basisklasse (`super`) aufgerufen, um die tats\u00e4chliche XML-Darstellung zu erzeugen.\n\n3. **Zusammenfassung**:\n   Die Funktion generiert eine XML-Darstellung des Objekts, wobei sie \u00fcberpr\u00fcft, ob die notwendigen Voraussetzungen erf\u00fcllt sind, und im Fehlerfall eine Ausnahme ausl\u00f6st. Sie nutzt die Implementierung der Basisklasse, um die tats\u00e4chliche XML-Erstellung durchzuf\u00fchren."
  },
  {
    "code": "def append(self, child, *args, **kwargs):\n        \"\"\"See :meth:`AbstractElement.append`\"\"\"\n        #if no set is associated with the layer yet, we learn it from span annotation elements that are added\n        if self.set is False or self.set is None:\n            if inspect.isclass(child):\n                if issubclass(child,AbstractSpanAnnotation):\n                    if 'set' in kwargs:\n                        self.set = kwargs['set']\n            elif isinstance(child, AbstractSpanAnnotation):\n                if child.set:\n                    self.set = child.set\n            elif isinstance(child, Correction):\n                #descend into corrections to find the proper set for this layer (derived from span annotation elements)\n                for e in itertools.chain( child.new(), child.original(), child.suggestions() ):\n                    if isinstance(e, AbstractSpanAnnotation) and e.set:\n                        self.set = e.set\n                        break\n\n        return super(AbstractAnnotationLayer, self).append(child, *args, **kwargs)",
    "docstring": "See :meth:`AbstractElement.append`",
    "summary": "Dieser Codeausschnitt ist eine Methode namens `append`, die Teil einer Klasse namens `AbstractAnnotationLayer` ist. Lass mich dir in einfachen Worten erkl\u00e4ren, was sie macht:\n\n1. **Zweck der Methode**: Die Methode `append` f\u00fcgt ein neues Element (`child`) zu einer Annotationsebene hinzu. Diese Ebene ist Teil eines gr\u00f6\u00dferen Systems, das mit Annotationen (z. B. Markierungen in Texten) arbeitet.\n\n2. **\u00dcberpr\u00fcfung des Sets**: Bevor das Element hinzugef\u00fcgt wird, \u00fcberpr\u00fcft die Methode, ob der Ebene bereits ein `set` zugeordnet ist. Ein `set` ist hier wahrscheinlich eine Art Kategorie oder Gruppe, der die Annotation zugeordnet ist.\n\n3. **Lernen des Sets**: Wenn noch kein `set` vorhanden ist, versucht die Methode, es aus dem hinzugef\u00fcgten Element (`child`) zu \"lernen\". Das passiert in folgenden F\u00e4llen:\n   - Wenn das Element eine Klasse ist, die von `AbstractSpanAnnotation` abgeleitet ist und ein `set` in den Keyword-Argumenten (`kwargs`) angegeben ist.\n   - Wenn das Element eine Instanz von `AbstractSpanAnnotation` ist und bereits ein `set` hat.\n   - Wenn das Element eine `Correction` ist, durchsucht die Methode die darin enthaltenen Elemente (z. B. `new`, `original`, `suggestions`), um ein passendes `set` zu finden.\n\n4. **Hinzuf\u00fcgen des Elements**: Nachdem das `set` bestimmt wurde (falls n\u00f6tig), wird das Element (`child`) mit den \u00fcbergebenen Argumenten (`args` und `kwargs`) zur Ebene hinzugef\u00fcgt. Dies geschieht durch den Aufruf der `append`-Methode der Basisklasse (`super`).\n\n**Zusammenfassung**: Die Methode f\u00fcgt ein Element zu einer Annotationsebene hinzu und stellt sicher, dass die Ebene ein passendes `set` hat, falls noch keines vorhanden ist. Sie lernt das `set` aus dem hinzugef\u00fcgten Element oder dessen Inhalt."
  },
  {
    "code": "def alternatives(self, Class=None, set=None):\n        \"\"\"Generator over alternatives, either all or only of a specific annotation type, and possibly restrained also by set.\n\n        Arguments:\n            * ``Class`` - The Class you want to retrieve (e.g. PosAnnotation). Or set to None to select all alternatives regardless of what type they are.\n            * ``set``   - The set you want to retrieve (defaults to None, which selects irregardless of set)\n\n        Returns:\n            Generator over Alternative elements\n        \"\"\"\n\n        for e in self.select(AlternativeLayers,None, True, ['Original','Suggestion']): #pylint: disable=too-many-nested-blocks\n            if Class is None:\n                yield e\n            elif len(e) >= 1: #child elements?\n                for e2 in e:\n                    try:\n                        if isinstance(e2, Class):\n                            try:\n                                if set is None or e2.set == set:\n                                    yield e #not e2\n                                    break #yield an alternative only once (in case there are multiple matches)\n                            except AttributeError:\n                                continue\n                    except AttributeError:\n                        continue",
    "docstring": "Generator over alternatives, either all or only of a specific annotation type, and possibly restrained also by set.\n\n        Arguments:\n            * ``Class`` - The Class you want to retrieve (e.g. PosAnnotation). Or set to None to select all alternatives regardless of what type they are.\n            * ``set``   - The set you want to retrieve (defaults to None, which selects irregardless of set)\n\n        Returns:\n            Generator over Alternative elements",
    "summary": "Dieser Code ist eine Funktion in Python, die einen Generator \u00fcber Alternativen erstellt. Hier ist eine einfache Erkl\u00e4rung auf Deutsch:\n\nDie Funktion `alternatives` durchsucht eine Sammlung von Elementen (genannt `AlternativeLayers`) und gibt bestimmte Alternativen zur\u00fcck, basierend auf den angegebenen Kriterien.\n\n**Eingabeparameter:**\n\n* `Class`: Dies ist optional und gibt an, welche Art von Annotation (z.B. `PosAnnotation`) zur\u00fcckgegeben werden soll. Wenn `None`, werden alle Alternativen zur\u00fcckgegeben, unabh\u00e4ngig von ihrem Typ.\n* `set`: Dies ist ebenfalls optional und gibt an, aus welchem Satz (oder Gruppe) die Alternativen stammen sollen. Wenn `None`, werden Alternativen aus allen S\u00e4tzen zur\u00fcckgegeben.\n\n**Funktionsweise:**\n\n1. Die Funktion durchl\u00e4uft alle Elemente in `AlternativeLayers`.\n2. Wenn `Class` nicht angegeben ist (`None`), gibt sie jedes Element (`e`) zur\u00fcck.\n3. Wenn `Class` angegeben ist, \u00fcberpr\u00fcft sie, ob das Element Kinder (`e2`) hat, die vom Typ `Class` sind.\n4. Wenn ein passendes Kind gefunden wird, \u00fcberpr\u00fcft sie, ob es zum angegebenen `set` geh\u00f6rt (falls `set` angegeben ist).\n5. Wenn alle Bedingungen erf\u00fcllt sind, gibt sie das \u00fcbergeordnete Element (`e`) zur\u00fcck, nicht das Kind (`e2`).\n6. Sie stellt sicher, dass jede Alternative nur einmal zur\u00fcckgegeben wird, auch wenn es mehrere passende Kinder gibt.\n\n**R\u00fcckgabewert:**\nEin Generator, der die passenden Alternativen zur\u00fcckgibt.\n\nZusammenfassend durchsucht diese Funktion eine Sammlung von Elementen und gibt bestimmte Alternativen zur\u00fcck, basierend auf dem Typ der Annotation und dem Satz, zu dem sie geh\u00f6ren."
  },
  {
    "code": "def findspan(self, *words):\n        \"\"\"Returns the span element which spans over the specified words or morphemes.\n\n        See also:\n            :meth:`Word.findspans`\n        \"\"\"\n\n        for span in self.select(AbstractSpanAnnotation,None,True):\n            if tuple(span.wrefs()) == words:\n                return span\n        raise NoSuchAnnotation",
    "docstring": "Returns the span element which spans over the specified words or morphemes.\n\n        See also:\n            :meth:`Word.findspans`",
    "summary": "Diese Funktion, `findspan`, sucht in einem Text nach einem bestimmten Bereich (Span), der eine bestimmte Folge von W\u00f6rtern oder Morphemen abdeckt. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Eingabe**: Die Funktion nimmt eine beliebige Anzahl von W\u00f6rtern (`*words`) als Eingabe, die in einer bestimmten Reihenfolge stehen.\n2. **Suche**: Sie durchsucht alle vorhandenen Textbereiche (Spans), die mit `AbstractSpanAnnotation` markiert sind.\n3. **\u00dcberpr\u00fcfung**: Sie pr\u00fcft, ob die Folge der W\u00f6rter in einem dieser Bereiche genau mit der eingegebenen Folge \u00fcbereinstimmt.\n4. **Ergebnis**: Wenn sie einen passenden Bereich findet, gibt sie diesen zur\u00fcck. Wenn kein passender Bereich gefunden wird, wird eine Fehlermeldung (`NoSuchAnnotation`) ausgel\u00f6st.\n\nZusammengefasst: Die Funktion sucht nach einem Textbereich, der genau die angegebenen W\u00f6rter in der richtigen Reihenfolge enth\u00e4lt, und gibt diesen Bereich zur\u00fcck, falls er existiert."
  },
  {
    "code": "def relaxng(cls, includechildren=True,extraattribs = None, extraelements=None, origclass = None):\n        \"\"\"Returns a RelaxNG definition for this element (as an XML element (lxml.etree) rather than a string)\"\"\"\n        E = ElementMaker(namespace=\"http://relaxng.org/ns/structure/1.0\",nsmap={None:'http://relaxng.org/ns/structure/1.0' , 'folia': \"http://ilk.uvt.nl/folia\", 'xml' : \"http://www.w3.org/XML/1998/namespace\",'a':\"http://relaxng.org/ns/annotation/0.9\" })\n        if not extraattribs:\n            extraattribs = []\n        extraattribs.append(E.optional(E.attribute(E.text(), name='set')) )\n        return AbstractElement.relaxng(includechildren, extraattribs, extraelements, cls)",
    "docstring": "Returns a RelaxNG definition for this element (as an XML element (lxml.etree) rather than a string)",
    "summary": "Diese Funktion, `relaxng`, generiert eine **RelaxNG-Definition** (eine Art Schema f\u00fcr XML-Dokumente) f\u00fcr ein bestimmtes Element. Hier ist eine einfache Erkl\u00e4rung in Deutsch:\n\n1. **Zweck**: Die Funktion erstellt eine RelaxNG-Definition f\u00fcr ein bestimmtes Element, die als XML-Element (und nicht als Text) zur\u00fcckgegeben wird.\n\n2. **Parameter**:\n   - `cls`: Das Element, f\u00fcr das die RelaxNG-Definition erstellt werden soll.\n   - `includechildren`: Ein Schalter, der angibt, ob Kind-Elemente in der Definition ber\u00fccksichtigt werden sollen (Standard: `True`).\n   - `extraattribs`: Zus\u00e4tzliche Attribute, die in der Definition enthalten sein sollen.\n   - `extraelements`: Zus\u00e4tzliche Elemente, die in der Definition enthalten sein sollen.\n   - `origclass`: Das urspr\u00fcngliche Element, falls es sich um eine abgeleitete Klasse handelt.\n\n3. **Ablauf**:\n   - Es wird ein `ElementMaker` erstellt, der die Namespaces f\u00fcr RelaxNG, FOLIA, XML und Annotationen definiert.\n   - Wenn `extraattribs` nicht angegeben ist, wird es als leere Liste initialisiert.\n   - Ein optionales Attribut namens `set` wird zu `extraattribs` hinzugef\u00fcgt.\n   - Die Methode `relaxng` der Klasse `AbstractElement` wird aufgerufen, um die eigentliche RelaxNG-Definition zu generieren.\n\n4. **Ergebnis**: Die Funktion gibt ein XML-Element zur\u00fcck, das die RelaxNG-Definition f\u00fcr das angegebene Element darstellt.\n\n**Zusammenfassung**: Die Funktion erstellt ein XML-basiertes Schema (RelaxNG) f\u00fcr ein bestimmtes Element, wobei optionale Attribute und Kind-Elemente ber\u00fccksichtigt werden k\u00f6nnen."
  },
  {
    "code": "def hasnew(self,allowempty=False):\n        \"\"\"Does the correction define new corrected annotations?\"\"\"\n        for e in  self.select(New,None,False, False):\n            if not allowempty and len(e) == 0: continue\n            return True\n        return False",
    "docstring": "Does the correction define new corrected annotations?",
    "summary": "Sicher! Diese Funktion \u00fcberpr\u00fcft, ob eine Korrektur neue korrigierte Anmerkungen definiert. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Zweck der Funktion**: Die Funktion `hasnew` pr\u00fcft, ob es neue korrigierte Anmerkungen gibt.\n  \n2. **Parameter**:\n   - `self`: Bezieht sich auf die Instanz der Klasse, in der die Funktion aufgerufen wird.\n   - `allowempty=False`: Ein optionaler Parameter, der angibt, ob leere Anmerkungen ber\u00fccksichtigt werden sollen. Standardm\u00e4\u00dfig werden leere Anmerkungen ignoriert (`False`).\n\n3. **Funktionsweise**:\n   - Die Funktion durchl\u00e4uft eine Liste von Elementen (`e`), die durch `self.select(New, None, False, False)` ausgew\u00e4hlt werden. Diese Elemente stellen wahrscheinlich neue korrigierte Anmerkungen dar.\n   - Wenn `allowempty` auf `False` gesetzt ist und ein Element (`e`) leer ist (`len(e) == 0`), wird es \u00fcbersprungen.\n   - Sobald ein nicht leeres Element gefunden wird, gibt die Funktion `True` zur\u00fcck, was bedeutet, dass es neue korrigierte Anmerkungen gibt.\n   - Wenn keine neuen Anmerkungen gefunden werden, gibt die Funktion `False` zur\u00fcck.\n\n4. **Zusammenfassung**: Die Funktion pr\u00fcft, ob es neue, nicht leere korrigierte Anmerkungen gibt, und gibt entsprechend `True` oder `False` zur\u00fcck.\n\nHoffe, das hilft!"
  },
  {
    "code": "def hasoriginal(self,allowempty=False):\n        \"\"\"Does the correction record the old annotations prior to correction?\"\"\"\n        for e in self.select(Original,None,False, False):\n            if not allowempty and len(e) == 0: continue\n            return True\n        return False",
    "docstring": "Does the correction record the old annotations prior to correction?",
    "summary": "Sicher! Diese Funktion \u00fcberpr\u00fcft, ob in einem Datensatz (oder einer Aufzeichnung) die urspr\u00fcnglichen Anmerkungen vor einer Korrektur gespeichert wurden. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Zweck der Funktion**: Die Funktion `hasoriginal` pr\u00fcft, ob es in den Daten eine Aufzeichnung der urspr\u00fcnglichen Anmerkungen (vor einer Korrektur) gibt.\n\n2. **Parameter**:\n   - `self`: Bezieht sich auf die Instanz der Klasse, in der diese Funktion verwendet wird.\n   - `allowempty=False`: Ein optionaler Parameter, der angibt, ob leere Eintr\u00e4ge ber\u00fccksichtigt werden sollen. Standardm\u00e4\u00dfig wird `False` verwendet, was bedeutet, dass leere Eintr\u00e4ge ignoriert werden.\n\n3. **Funktionsweise**:\n   - Die Funktion durchl\u00e4uft alle Eintr\u00e4ge (`e`), die mit `self.select(Original, None, False, False)` ausgew\u00e4hlt werden. Hierbei wird nach Eintr\u00e4gen vom Typ `Original` gesucht.\n   - Wenn `allowempty` auf `False` gesetzt ist und der Eintrag `e` leer ist (`len(e) == 0`), wird dieser Eintrag \u00fcbersprungen (`continue`).\n   - Wenn ein nicht leerer Eintrag gefunden wird, gibt die Funktion `True` zur\u00fcck, was bedeutet, dass es mindestens einen Eintrag mit urspr\u00fcnglichen Anmerkungen gibt.\n   - Wenn keine nicht leeren Eintr\u00e4ge gefunden werden, gibt die Funktion `False` zur\u00fcck.\n\n4. **Zusammenfassung**: Die Funktion pr\u00fcft also, ob es in den Daten mindestens einen nicht leeren Eintrag mit urspr\u00fcnglichen Anmerkungen gibt, und gibt entsprechend `True` oder `False` zur\u00fcck.\n\n**Auf Deutsch**:  \nDie Funktion \u00fcberpr\u00fcft, ob in den Daten urspr\u00fcngliche Anmerkungen vor einer Korrektur gespeichert wurden. Sie durchsucht die Eintr\u00e4ge und gibt `True` zur\u00fcck, wenn mindestens ein nicht leerer Eintrag mit urspr\u00fcnglichen Anmerkungen gefunden wird. Andernfalls gibt sie `False` zur\u00fcck."
  },
  {
    "code": "def hascurrent(self, allowempty=False):\n        \"\"\"Does the correction record the current authoritative annotation (needed only in a structural context when suggestions are proposed)\"\"\"\n        for e in self.select(Current,None,False, False):\n            if not allowempty and len(e) == 0: continue\n            return True\n        return False",
    "docstring": "Does the correction record the current authoritative annotation (needed only in a structural context when suggestions are proposed)",
    "summary": "Sicher! Diese Funktion \u00fcberpr\u00fcft, ob ein bestimmtes Objekt (in diesem Fall `self`) eine aktuelle, autoritative Anmerkung enth\u00e4lt. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Zweck**: Die Funktion `hascurrent` pr\u00fcft, ob es eine aktuelle Anmerkung (oder \"Annotation\") gibt, die als autoritativ gilt. Dies ist besonders wichtig, wenn Vorschl\u00e4ge in einem strukturellen Kontext gemacht werden.\n\n2. **Parameter**:\n   - `allowempty=False`: Ein optionaler Parameter, der angibt, ob leere Anmerkungen ber\u00fccksichtigt werden sollen. Standardm\u00e4\u00dfig werden leere Anmerkungen ignoriert (`False`).\n\n3. **Funktionsweise**:\n   - Die Funktion durchl\u00e4uft alle Elemente (`e`), die durch `self.select(Current, None, False, False)` ausgew\u00e4hlt werden. Dies bedeutet, sie sucht nach aktuellen Anmerkungen.\n   - Wenn `allowempty` auf `False` gesetzt ist und das aktuelle Element (`e`) leer ist (`len(e) == 0`), wird es \u00fcbersprungen (`continue`).\n   - Wenn ein nicht leeres aktuelles Element gefunden wird, gibt die Funktion `True` zur\u00fcck, was bedeutet, dass eine aktuelle autoritative Anmerkung vorhanden ist.\n   - Wenn keine solche Anmerkung gefunden wird, gibt die Funktion `False` zur\u00fcck.\n\n4. **Zusammenfassung**: Die Funktion pr\u00fcft also, ob es eine aktuelle, nicht leere Anmerkung gibt, und gibt basierend darauf `True` oder `False` zur\u00fcck.\n\n**Auf Deutsch**:  \nDie Funktion \u00fcberpr\u00fcft, ob es eine aktuelle und g\u00fcltige Anmerkung gibt, und ber\u00fccksichtigt dabei, ob leere Anmerkungen erlaubt sind oder nicht. Sie gibt `True` zur\u00fcck, wenn eine solche Anmerkung gefunden wird, und `False`, wenn nicht."
  },
  {
    "code": "def hassuggestions(self,allowempty=False):\n        \"\"\"Does the correction propose suggestions for correction?\"\"\"\n        for e in self.select(Suggestion,None,False, False):\n            if not allowempty and len(e) == 0: continue\n            return True\n        return False",
    "docstring": "Does the correction propose suggestions for correction?",
    "summary": "Sicher! Diese Funktion \u00fcberpr\u00fcft, ob es Vorschl\u00e4ge f\u00fcr Korrekturen gibt. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Zweck der Funktion**: Die Funktion `hassuggestions` pr\u00fcft, ob es Vorschl\u00e4ge f\u00fcr Korrekturen gibt, die von einem Korrekturvorschlagssystem gemacht wurden.\n\n2. **Parameter**:\n   - `allowempty=False`: Ein optionaler Parameter, der angibt, ob leere Vorschl\u00e4ge ber\u00fccksichtigt werden sollen. Standardm\u00e4\u00dfig werden leere Vorschl\u00e4ge ignoriert (`False`).\n\n3. **Funktionsweise**:\n   - Die Funktion durchl\u00e4uft alle Vorschl\u00e4ge (`Suggestion`), die von `self.select` zur\u00fcckgegeben werden.\n   - Wenn `allowempty` auf `False` gesetzt ist (Standard), werden leere Vorschl\u00e4ge (d.h. Vorschl\u00e4ge mit einer L\u00e4nge von 0) \u00fcbersprungen.\n   - Sobald ein nicht-leerer Vorschlag gefunden wird, gibt die Funktion `True` zur\u00fcck, was bedeutet, dass es mindestens einen Vorschlag f\u00fcr eine Korrektur gibt.\n   - Wenn keine Vorschl\u00e4ge gefunden werden (oder alle Vorschl\u00e4ge leer sind und `allowempty` auf `False` gesetzt ist), gibt die Funktion `False` zur\u00fcck.\n\n4. **Zusammenfassung**: Die Funktion gibt `True` zur\u00fcck, wenn es mindestens einen nicht-leeren Korrekturvorschlag gibt, und `False`, wenn keine Vorschl\u00e4ge vorhanden sind oder alle Vorschl\u00e4ge leer sind (und `allowempty` auf `False` gesetzt ist).\n\n**Auf Deutsch**:\nDie Funktion \u00fcberpr\u00fcft, ob es Vorschl\u00e4ge f\u00fcr Korrekturen gibt. Sie ignoriert leere Vorschl\u00e4ge, es sei denn, dies wird explizit erlaubt. Wenn mindestens ein nicht-leerer Vorschlag gefunden wird, gibt sie `True` zur\u00fcck, ansonsten `False`."
  },
  {
    "code": "def textcontent(self, cls='current', correctionhandling=CorrectionHandling.CURRENT):\n        \"\"\"See :meth:`AbstractElement.textcontent`\"\"\"\n        if cls == 'original': correctionhandling = CorrectionHandling.ORIGINAL #backward compatibility\n        if correctionhandling in (CorrectionHandling.CURRENT, CorrectionHandling.EITHER):\n            for e in self:\n                if isinstance(e, New) or isinstance(e, Current):\n                    return e.textcontent(cls,correctionhandling)\n        if correctionhandling in (CorrectionHandling.ORIGINAL, CorrectionHandling.EITHER):\n            for e in self:\n                if isinstance(e, Original):\n                    return e.textcontent(cls,correctionhandling)\n        raise NoSuchText",
    "docstring": "See :meth:`AbstractElement.textcontent`",
    "summary": "Diese Funktion, `textcontent`, dient dazu, den Textinhalt eines Elements basierend auf bestimmten Kriterien zu extrahieren. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Parameter**:\n   - `cls='current'`: Legt fest, welche Version des Textinhalts zur\u00fcckgegeben werden soll (z. B. die aktuelle Version).\n   - `correctionhandling=CorrectionHandling.CURRENT`: Bestimmt, wie mit Korrekturen umgegangen wird (z. B. ob die aktuelle, urspr\u00fcngliche oder eine beliebige Version verwendet werden soll).\n\n2. **Funktionsweise**:\n   - Wenn `cls` auf `'original'` gesetzt ist, wird `correctionhandling` auf `CorrectionHandling.ORIGINAL` ge\u00e4ndert, um Abw\u00e4rtskompatibilit\u00e4t zu gew\u00e4hrleisten.\n   - Die Funktion durchl\u00e4uft die Elemente (`e`) des Objekts (`self`).\n   - Je nach `correctionhandling` wird der Textinhalt entweder von der aktuellen Version (`New` oder `Current`) oder der urspr\u00fcnglichen Version (`Original`) zur\u00fcckgegeben.\n   - Wenn keine passende Version gefunden wird, wird eine `NoSuchText`-Ausnahme ausgel\u00f6st.\n\n3. **Zusammenfassung**:\n   Die Funktion sucht den Textinhalt eines Elements, wobei sie zwischen aktuellen und urspr\u00fcnglichen Versionen unterscheidet, und gibt den entsprechenden Text zur\u00fcck. Wenn kein passender Text gefunden wird, wird ein Fehler geworfen."
  },
  {
    "code": "def phoncontent(self, cls='current', correctionhandling=CorrectionHandling.CURRENT):\n        \"\"\"See :meth:`AbstractElement.phoncontent`\"\"\"\n        if cls == 'original': correctionhandling = CorrectionHandling.ORIGINAL #backward compatibility\n        if correctionhandling in (CorrectionHandling.CURRENT, CorrectionHandling.EITHER):\n            for e in self:\n                if isinstance(e, New) or isinstance(e, Current):\n                    return e.phoncontent(cls, correctionhandling)\n        if correctionhandling in (CorrectionHandling.ORIGINAL, CorrectionHandling.EITHER):\n            for e in self:\n                if isinstance(e, Original):\n                    return e.phoncontent(cls, correctionhandling)\n        raise NoSuchPhon",
    "docstring": "See :meth:`AbstractElement.phoncontent`",
    "summary": "Diese Funktion, `phoncontent`, scheint Teil einer gr\u00f6\u00dferen Klasse zu sein und hat die Aufgabe, phonetische Inhalte basierend auf bestimmten Kriterien abzurufen. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Parameter**:\n   - `cls='current'`: Ein Standardparameter, der angibt, welche Art von Inhalt abgerufen werden soll (z.B. \"aktuell\" oder \"original\").\n   - `correctionhandling=CorrectionHandling.CURRENT`: Ein Parameter, der bestimmt, wie Korrekturen behandelt werden sollen (z.B. aktuelle Korrekturen, urspr\u00fcngliche Korrekturen oder beides).\n\n2. **Funktionsweise**:\n   - Wenn `cls` auf `'original'` gesetzt ist, wird `correctionhandling` auf `CorrectionHandling.ORIGINAL` ge\u00e4ndert, um Abw\u00e4rtskompatibilit\u00e4t zu gew\u00e4hrleisten.\n   - Die Funktion durchl\u00e4uft dann die Elemente (`e`) des Objekts (`self`).\n   - Je nach Wert von `correctionhandling` sucht sie nach bestimmten Elementtypen (`New`, `Current`, `Original`) und ruft deren `phoncontent`-Methode auf, um den phonetischen Inhalt abzurufen.\n   - Wenn kein passendes Element gefunden wird, wird eine Ausnahme (`NoSuchPhon`) ausgel\u00f6st.\n\n3. **Zusammenfassung**:\n   Die Funktion versucht, phonetische Inhalte aus einem Objekt abzurufen, wobei sie zwischen aktuellen und urspr\u00fcnglichen Inhalten unterscheidet und Korrekturen entsprechend behandelt. Wenn kein passender Inhalt gefunden wird, wird ein Fehler gemeldet."
  },
  {
    "code": "def hastext(self, cls='current',strict=True, correctionhandling=CorrectionHandling.CURRENT):\n        \"\"\"See :meth:`AbstractElement.hastext`\"\"\"\n        if cls == 'original': correctionhandling = CorrectionHandling.ORIGINAL #backward compatibility\n        if correctionhandling in (CorrectionHandling.CURRENT, CorrectionHandling.EITHER):\n            for e in self:\n                if isinstance(e, New) or isinstance(e, Current):\n                    return e.hastext(cls,strict, correctionhandling)\n        if correctionhandling in (CorrectionHandling.ORIGINAL, CorrectionHandling.EITHER):\n            for e in self:\n                if isinstance(e, Original):\n                    return e.hastext(cls,strict, correctionhandling)\n        return False",
    "docstring": "See :meth:`AbstractElement.hastext`",
    "summary": "Sicher! Diese Funktion `hastext` \u00fcberpr\u00fcft, ob ein bestimmtes Textelement in einem Objekt vorhanden ist. Hier ist eine einfache Erkl\u00e4rung in Deutsch:\n\nDie Funktion `hastext` macht Folgendes:\n\n1. **Eingabeparameter**:\n   - `cls='current'`: Bestimmt, welche Version des Textes \u00fcberpr\u00fcft werden soll (z. B. die aktuelle Version).\n   - `strict=True`: Legt fest, ob die \u00dcberpr\u00fcfung streng sein soll (d. h., ob der Text exakt \u00fcbereinstimmen muss).\n   - `correctionhandling=CorrectionHandling.CURRENT`: Bestimmt, wie mit Korrekturen umgegangen werden soll (z. B. ob die aktuelle oder urspr\u00fcngliche Version ber\u00fccksichtigt wird).\n\n2. **Logik**:\n   - Wenn `cls` auf `'original'` gesetzt ist, wird `correctionhandling` auf `CorrectionHandling.ORIGINAL` ge\u00e4ndert, um Abw\u00e4rtskompatibilit\u00e4t zu gew\u00e4hrleisten.\n   - Die Funktion \u00fcberpr\u00fcft dann, je nach `correctionhandling`, ob ein bestimmtes Textelement in der aktuellen oder urspr\u00fcnglichen Version vorhanden ist.\n   - Sie durchl\u00e4uft dazu die Elemente (`e`) des Objekts (`self`) und pr\u00fcft, ob sie vom Typ `New`, `Current` oder `Original` sind.\n   - Wenn ein passendes Element gefunden wird, wird dessen `hastext`-Methode aufgerufen, um zu \u00fcberpr\u00fcfen, ob der Text vorhanden ist.\n\n3. **R\u00fcckgabewert**:\n   - Wenn ein Textelement gefunden wird, gibt die Funktion `True` zur\u00fcck.\n   - Wenn kein Textelement gefunden wird, gibt sie `False` zur\u00fcck.\n\nZusammengefasst \u00fcberpr\u00fcft diese Funktion, ob ein bestimmter Text in einem Objekt vorhanden ist, wobei sie verschiedene Versionen (aktuell oder urspr\u00fcnglich) und Korrekturhandlungen ber\u00fccksichtigt."
  },
  {
    "code": "def text(self, cls = 'current', retaintokenisation=False, previousdelimiter=\"\",strict=False, correctionhandling=CorrectionHandling.CURRENT, normalize_spaces=False):\n        \"\"\"See :meth:`AbstractElement.text`\"\"\"\n        if cls == 'original': correctionhandling = CorrectionHandling.ORIGINAL #backward compatibility\n        if correctionhandling in (CorrectionHandling.CURRENT, CorrectionHandling.EITHER):\n            for e in self:\n                if isinstance(e, New) or isinstance(e, Current):\n                    s = previousdelimiter + e.text(cls, retaintokenisation,\"\", strict, correctionhandling)\n                    if normalize_spaces:\n                        return norm_spaces(s)\n                    else:\n                        return s\n        if correctionhandling in (CorrectionHandling.ORIGINAL, CorrectionHandling.EITHER):\n            for e in self:\n                if isinstance(e, Original):\n                    s =  previousdelimiter + e.text(cls, retaintokenisation,\"\", strict, correctionhandling)\n                    if normalize_spaces:\n                        return norm_spaces(s)\n                    else:\n                        return s\n        raise NoSuchText",
    "docstring": "See :meth:`AbstractElement.text`",
    "summary": "Diese Funktion, `text`, scheint ein Teil einer Klasse zu sein und dient dazu, Text aus bestimmten Elementen zu extrahieren und zu verarbeiten. Hier ist eine einfache Erkl\u00e4rung, was sie macht:\n\n1. **Parameter**: Die Funktion nimmt mehrere Parameter entgegen, wie z.B. `cls`, `retaintokenisation`, `previousdelimiter`, `strict`, `correctionhandling`, und `normalize_spaces`. Diese Parameter steuern, wie der Text extrahiert und verarbeitet wird.\n\n2. **R\u00fcckw\u00e4rtskompatibilit\u00e4t**: Wenn `cls` den Wert `'original'` hat, wird `correctionhandling` auf `CorrectionHandling.ORIGINAL` gesetzt. Dies dient der Kompatibilit\u00e4t mit \u00e4lteren Versionen des Codes.\n\n3. **Text-Extraktion**: Die Funktion durchl\u00e4uft die Elemente (`e`) des aktuellen Objekts (`self`). Je nach Wert von `correctionhandling` wird der Text entweder aus `New` oder `Current`-Elementen (`CorrectionHandling.CURRENT` oder `CorrectionHandling.EITHER`) oder aus `Original`-Elementen (`CorrectionHandling.ORIGINAL` oder `CorrectionHandling.EITHER`) extrahiert.\n\n4. **Verarbeitung des Textes**: Der extrahierte Text wird mit dem `previousdelimiter` kombiniert. Wenn `normalize_spaces` auf `True` gesetzt ist, wird der Text mit der Funktion `norm_spaces` bereinigt, um \u00fcberfl\u00fcssige Leerzeichen zu entfernen.\n\n5. **R\u00fcckgabe**: Die Funktion gibt den verarbeiteten Text zur\u00fcck.\n\n6. **Fehlerbehandlung**: Wenn kein passendes Element gefunden wird, wird eine `NoSuchText`-Ausnahme ausgel\u00f6st.\n\nZusammenfassend extrahiert diese Funktion Text aus bestimmten Elementen, verarbeitet ihn basierend auf den gegebenen Parametern und gibt ihn zur\u00fcck. Wenn kein Text gefunden wird, wird ein Fehler geworfen."
  },
  {
    "code": "def phon(self, cls = 'current', previousdelimiter=\"\",strict=False, correctionhandling=CorrectionHandling.CURRENT):\n        \"\"\"See :meth:`AbstractElement.phon`\"\"\"\n        if cls == 'original': correctionhandling = CorrectionHandling.ORIGINAL #backward compatibility\n        if correctionhandling in (CorrectionHandling.CURRENT, CorrectionHandling.EITHER):\n            for e in self:\n                if isinstance(e, New) or isinstance(e, Current):\n                    return previousdelimiter + e.phon(cls, \"\", strict, correctionhandling)\n        if correctionhandling in (CorrectionHandling.ORIGINAL, CorrectionHandling.EITHER):\n            for e in self:\n                if isinstance(e, Original):\n                    return previousdelimiter + e.phon(cls, \"\", correctionhandling)\n        raise NoSuchPhon",
    "docstring": "See :meth:`AbstractElement.phon`",
    "summary": "Diese Funktion, `phon`, scheint eine Methode in einer Klasse zu sein, die mit der phonetischen Darstellung von Elementen arbeitet. Hier ist eine einfache Erkl\u00e4rung auf Deutsch:\n\nDie Funktion `phon` durchl\u00e4uft eine Liste von Elementen (`self`) und versucht, eine phonetische Darstellung (also wie etwas ausgesprochen wird) basierend auf bestimmten Kriterien zu finden. Sie hat mehrere Parameter:\n\n- `cls`: Bestimmt, ob die phonetische Darstellung auf der aktuellen (`'current'`) oder urspr\u00fcnglichen (`'original'`) Form basieren soll.\n- `previousdelimiter`: Ein Trennzeichen, das vor der phonetischen Darstellung hinzugef\u00fcgt wird.\n- `strict`: Ein boolescher Wert, der bestimmt, ob die Suche streng sein soll (obwohl nicht direkt in der Funktion verwendet, k\u00f6nnte es in aufgerufenen Methoden relevant sein).\n- `correctionhandling`: Bestimmt, wie Korrekturen behandelt werden sollen (z.B. nur aktuelle, nur urspr\u00fcngliche oder beide).\n\nDie Funktion \u00fcberpr\u00fcft, ob die phonetische Darstellung basierend auf den aktuellen oder urspr\u00fcnglichen Elementen gefunden werden kann. Wenn ein passendes Element gefunden wird, gibt sie die phonetische Darstellung mit dem angegebenen Trennzeichen zur\u00fcck. Wenn kein passendes Element gefunden wird, wird eine Ausnahme (`NoSuchPhon`) ausgel\u00f6st, was bedeutet, dass keine phonetische Darstellung gefunden werden konnte.\n\nZusammenfassend: Die Funktion sucht nach einer phonetischen Darstellung von Elementen, basierend auf den angegebenen Parametern, und gibt diese zur\u00fcck, falls gefunden. Andernfalls wird eine Fehlermeldung ausgel\u00f6st."
  },
  {
    "code": "def gettextdelimiter(self, retaintokenisation=False):\n        \"\"\"See :meth:`AbstractElement.gettextdelimiter`\"\"\"\n        for e in self:\n            if isinstance(e, New) or isinstance(e, Current):\n                return e.gettextdelimiter(retaintokenisation)\n        return \"\"",
    "docstring": "See :meth:`AbstractElement.gettextdelimiter`",
    "summary": "Sicher! Diese Funktion, `gettextdelimiter`, durchsucht die Elemente eines Objekts (das durch `self` dargestellt wird) und versucht, einen Text-Delimiter (Trennzeichen) zu finden. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Zweck**: Die Funktion sucht nach einem spezifischen Trennzeichen, das in Texten verwendet wird, um verschiedene Teile zu trennen.\n\n2. **Funktionsweise**:\n   - Sie durchl\u00e4uft alle Elemente (`e`) in `self`.\n   - Sie pr\u00fcft, ob ein Element vom Typ `New` oder `Current` ist.\n   - Wenn ein solches Element gefunden wird, ruft sie die Methode `gettextdelimiter` dieses Elements auf, wobei sie den Parameter `retaintokenisation` weitergibt.\n   - Wenn kein solches Element gefunden wird, gibt sie einen leeren String (`\"\"`) zur\u00fcck.\n\n3. **Zusammenfassung**: Die Funktion versucht, ein Trennzeichen aus einem bestimmten Element zu extrahieren, und gibt es zur\u00fcck, falls gefunden. Wenn kein passendes Element vorhanden ist, gibt sie nichts zur\u00fcck (einen leeren String).\n\nKurz gesagt: Sie sucht nach einem Text-Trennzeichen in bestimmten Elementen und gibt es zur\u00fcck, falls vorhanden."
  },
  {
    "code": "def new(self,index = None):\n        \"\"\"Get the new corrected annotation.\n\n        This returns only one annotation if multiple exist, use `index` to select another in the sequence.\n\n        Returns:\n            an annotation element (:class:`AbstractElement`)\n\n        Raises:\n            :class:`NoSuchAnnotation`\n        \"\"\"\n\n        if index is None:\n            try:\n                return next(self.select(New,None,False))\n            except StopIteration:\n                raise NoSuchAnnotation\n        else:\n            for e in self.select(New,None,False):\n                return e[index]\n            raise NoSuchAnnotation",
    "docstring": "Get the new corrected annotation.\n\n        This returns only one annotation if multiple exist, use `index` to select another in the sequence.\n\n        Returns:\n            an annotation element (:class:`AbstractElement`)\n\n        Raises:\n            :class:`NoSuchAnnotation`",
    "summary": "Dies ist eine Python-Funktion, die in einer Klasse definiert ist und dazu dient, eine korrigierte Annotation (Anmerkung) aus einer Sammlung von Annotationen abzurufen. Hier ist eine einfache Erkl\u00e4rung auf Deutsch:\n\n**Funktionsname:** `new`\n\n**Zweck:** Diese Funktion gibt eine bestimmte korrigierte Annotation zur\u00fcck, insbesondere wenn es mehrere Annotationen gibt.\n\n**Parameter:**\n\n* `self`: Dies ist eine Referenz auf die Instanz der Klasse, in der die Funktion aufgerufen wird (Standard in Python-Klassenmethoden).\n* `index = None`: Ein optionaler Parameter, der es dir erm\u00f6glicht, eine bestimmte Annotation aus einer Sequenz auszuw\u00e4hlen. Wenn `index` nicht angegeben wird (oder `None` ist), wird die erste verf\u00fcgbare Annotation zur\u00fcckgegeben.\n\n**Funktionsweise:**\n\n1. **Ohne Index**: Wenn kein `index` angegeben wird, versucht die Funktion, die n\u00e4chste Annotation des Typs `New` (vermutlich eine spezielle Art von Annotation) zu finden und zur\u00fcckzugeben. Wenn keine solche Annotation gefunden wird, wird eine Ausnahme (`NoSuchAnnotation`) ausgel\u00f6st.\n2. **Mit Index**: Wenn ein `index` angegeben wird, durchl\u00e4uft die Funktion alle Annotationen des Typs `New` und gibt die Annotation an der angegebenen Position (`index`) zur\u00fcck. Wenn der `index` ung\u00fcltig ist (z.B. au\u00dferhalb des Bereichs), wird ebenfalls eine `NoSuchAnnotation`-Ausnahme ausgel\u00f6st.\n\n**R\u00fcckgabewert:** Die Funktion gibt ein Annotationselement zur\u00fcck, das von der Klasse `AbstractElement` abgeleitet ist.\n\n**Ausnahmen:** Wenn keine passende Annotation gefunden wird, wird eine `NoSuchAnnotation`-Ausnahme ausgel\u00f6st.\n\nZusammenfassend: Die Funktion `new` hilft dir, eine bestimmte korrigierte Annotation aus einer Sammlung auszuw\u00e4hlen, entweder die erste verf\u00fcgbare oder eine spezifische anhand eines Index."
  },
  {
    "code": "def original(self,index=None):\n        \"\"\"Get the old annotation prior to correction.\n\n        This returns only one annotation if multiple exist, use `index` to select another in the sequence.\n\n        Returns:\n            an annotation element (:class:`AbstractElement`)\n\n        Raises:\n            :class:`NoSuchAnnotation`\n        \"\"\"\n        if index is None:\n            try:\n                return next(self.select(Original,None,False, False))\n            except StopIteration:\n                raise NoSuchAnnotation\n        else:\n            for e in self.select(Original,None,False, False):\n                return e[index]\n            raise NoSuchAnnotation",
    "docstring": "Get the old annotation prior to correction.\n\n        This returns only one annotation if multiple exist, use `index` to select another in the sequence.\n\n        Returns:\n            an annotation element (:class:`AbstractElement`)\n\n        Raises:\n            :class:`NoSuchAnnotation`",
    "summary": "Dies ist eine Python-Funktion, die in einer Klasse definiert ist und dazu dient, eine \u00e4ltere Annotation (Anmerkung) abzurufen, bevor sie korrigiert wurde. Hier ist eine einfache Erkl\u00e4rung auf Deutsch:\n\n**Funktionsname:** `original`\n\n**Zweck:** Diese Funktion gibt eine fr\u00fchere Annotation zur\u00fcck, die vor einer Korrektur vorhanden war.\n\n**Parameter:**\n\n* `self`: Dies ist eine Referenz auf die aktuelle Instanz der Klasse, in der die Funktion definiert ist.\n* `index=None`: Ein optionaler Parameter, der es erm\u00f6glicht, eine bestimmte Annotation aus einer Sequenz von Annotationen auszuw\u00e4hlen. Wenn kein Index angegeben wird (`None`), wird die erste Annotation zur\u00fcckgegeben.\n\n**Funktionsweise:**\n\n1. **\u00dcberpr\u00fcfung des Index:** Wenn kein Index angegeben wird, versucht die Funktion, die n\u00e4chste Annotation des Typs `Original` zu finden und zur\u00fcckzugeben.\n2. **Fehlerbehandlung:** Wenn keine Annotation gefunden wird, wird eine Ausnahme (`NoSuchAnnotation`) ausgel\u00f6st.\n3. **Auswahl einer bestimmten Annotation:** Wenn ein Index angegeben wird, durchl\u00e4uft die Funktion alle Annotationen des Typs `Original` und gibt die Annotation an der angegebenen Position (`index`) zur\u00fcck.\n4. **Fehlerbehandlung bei ung\u00fcltigem Index:** Wenn der angegebene Index ung\u00fcltig ist (z.B. weil es keine Annotation an dieser Position gibt), wird ebenfalls eine Ausnahme (`NoSuchAnnotation`) ausgel\u00f6st.\n\n**R\u00fcckgabewert:** Die Funktion gibt ein Annotationselement vom Typ `AbstractElement` zur\u00fcck.\n\n**Zusammenfassung:** Diese Funktion erm\u00f6glicht es, auf fr\u00fchere Annotationen zuzugreifen, die vor einer Korrektur vorhanden waren. Man kann entweder die erste Annotation abrufen oder eine bestimmte Annotation aus einer Sequenz ausw\u00e4hlen, indem man einen Index angibt."
  },
  {
    "code": "def current(self,index=None):\n        \"\"\"Get the current authoritative annotation (used with suggestions in a structural context)\n\n        This returns only one annotation if multiple exist, use `index` to select another in the sequence.\n\n        Returns:\n            an annotation element (:class:`AbstractElement`)\n\n        Raises:\n            :class:`NoSuchAnnotation`\n        \"\"\"\n        if index is None:\n            try:\n                return next(self.select(Current,None,False))\n            except StopIteration:\n                raise NoSuchAnnotation\n        else:\n            for e in self.select(Current,None,False):\n                return e[index]\n            raise NoSuchAnnotation",
    "docstring": "Get the current authoritative annotation (used with suggestions in a structural context)\n\n        This returns only one annotation if multiple exist, use `index` to select another in the sequence.\n\n        Returns:\n            an annotation element (:class:`AbstractElement`)\n\n        Raises:\n            :class:`NoSuchAnnotation`",
    "summary": "Sicher! Hier ist eine einfache Erkl\u00e4rung der Funktion `current` auf Deutsch:\n\nDie Funktion `current` wird verwendet, um die aktuelle, autoritative Anmerkung (Annotation) in einem strukturellen Kontext abzurufen, insbesondere wenn es Vorschl\u00e4ge (Suggestions) gibt. \n\n- **Was sie macht**: Sie gibt eine einzelne Anmerkung zur\u00fcck, auch wenn mehrere vorhanden sind. Du kannst den Parameter `index` verwenden, um eine bestimmte Anmerkung aus einer Sequenz auszuw\u00e4hlen.\n- **R\u00fcckgabewert**: Sie gibt ein Anmerkungselement vom Typ `AbstractElement` zur\u00fcck.\n- **Fehler**: Wenn keine Anmerkung gefunden wird, wird ein Fehler vom Typ `NoSuchAnnotation` ausgel\u00f6st.\n\n**Zusammenfassung**: Die Funktion hilft dir, eine bestimmte Anmerkung aus einer Liste von Anmerkungen auszuw\u00e4hlen, entweder die erste (standardm\u00e4\u00dfig) oder eine bestimmte, die du \u00fcber den Index angibst. Wenn keine Anmerkung vorhanden ist, wird ein Fehler gemeldet."
  },
  {
    "code": "def suggestions(self,index=None):\n        \"\"\"Get suggestions for correction.\n\n        Yields:\n            :class:`Suggestion` element that encapsulate the suggested annotations (if index is ``None``, default)\n\n        Returns:\n            a :class:`Suggestion` element that encapsulate the suggested annotations (if index is set)\n\n        Raises:\n            :class:`IndexError`\n        \"\"\"\n        if index is None:\n            return self.select(Suggestion,None,False, False)\n        else:\n            for i, e in enumerate(self.select(Suggestion,None,False, False)):\n                if index == i:\n                    return e\n            raise IndexError",
    "docstring": "Get suggestions for correction.\n\n        Yields:\n            :class:`Suggestion` element that encapsulate the suggested annotations (if index is ``None``, default)\n\n        Returns:\n            a :class:`Suggestion` element that encapsulate the suggested annotations (if index is set)\n\n        Raises:\n            :class:`IndexError`",
    "summary": "Sicher! Hier ist eine einfache Erkl\u00e4rung der Funktion `suggestions` auf Deutsch:\n\nDie Funktion `suggestions` gibt Vorschl\u00e4ge f\u00fcr Korrekturen zur\u00fcck. Sie kann auf zwei Arten verwendet werden:\n\n1. **Ohne einen bestimmten Index (`index=None`)**: In diesem Fall gibt die Funktion alle verf\u00fcgbaren Vorschl\u00e4ge (`Suggestion`-Elemente) zur\u00fcck. Diese Vorschl\u00e4ge enthalten m\u00f6gliche Korrekturen oder Annotationen.\n\n2. **Mit einem bestimmten Index (`index` ist gesetzt)**: Hier gibt die Funktion nur den Vorschlag zur\u00fcck, der dem angegebenen Index entspricht. Wenn der Index nicht existiert, wird ein `IndexError` ausgel\u00f6st, was bedeutet, dass der angeforderte Index nicht gefunden wurde.\n\nZusammengefasst: Die Funktion liefert entweder alle Korrekturvorschl\u00e4ge oder einen spezifischen Vorschlag basierend auf einem Index. Wenn der Index ung\u00fcltig ist, wird ein Fehler gemeldet."
  },
  {
    "code": "def select(self, Class, set=None, recursive=True,  ignore=True, node=None):\n        \"\"\"See :meth:`AbstractElement.select`\"\"\"\n        if self.include:\n            return self.subdoc.data[0].select(Class,set,recursive, ignore, node) #pass it on to the text node of the subdoc\n        else:\n            return iter([])",
    "docstring": "See :meth:`AbstractElement.select`",
    "summary": "Dies ist eine Python-Funktion namens `select`, die Teil einer Klasse zu sein scheint (da sie `self` als erstes Argument hat). Hier ist eine einfache Erkl\u00e4rung, was die Funktion tut:\n\n1. **Zweck**: Die Funktion `select` wird verwendet, um Elemente aus einem Dokument (wahrscheinlich einem XML- oder HTML-Dokument) auszuw\u00e4hlen, basierend auf bestimmten Kriterien.\n\n2. **Parameter**:\n   - `Class`: Vermutlich ein Kriterium, um Elemente einer bestimmten Klasse auszuw\u00e4hlen.\n   - `set`: Ein optionales Set von Elementen, das die Auswahl einschr\u00e4nkt.\n   - `recursive`: Ein boolescher Wert, der angibt, ob die Auswahl rekursiv (also auch in untergeordneten Elementen) erfolgen soll.\n   - `ignore`: Ein boolescher Wert, der angibt, ob bestimmte Elemente ignoriert werden sollen.\n   - `node`: Ein optionales Knotenelement, von dem aus die Auswahl beginnen soll.\n\n3. **Funktionsweise**:\n   - Wenn `self.include` wahr ist (also `True`), wird die Auswahl an die `select`-Methode eines untergeordneten Dokuments (`self.subdoc.data[0]`) weitergeleitet. Dies bedeutet, dass die Auswahl im Kontext eines untergeordneten Textknotens erfolgt.\n   - Wenn `self.include` falsch ist (also `False`), gibt die Funktion einen leeren Iterator (`iter([])`) zur\u00fcck, was bedeutet, dass keine Elemente ausgew\u00e4hlt werden.\n\n4. **Zusammenfassung**: Die Funktion `select` delegiert die Auswahl von Elementen entweder an ein untergeordnetes Dokument oder gibt eine leere Auswahl zur\u00fcck, je nachdem, ob `self.include` wahr oder falsch ist.\n\n**Auf Deutsch**:  \nDie Funktion `select` w\u00e4hlt Elemente aus einem Dokument basierend auf bestimmten Kriterien aus. Wenn eine Bedingung (`self.include`) erf\u00fcllt ist, wird die Auswahl an ein untergeordnetes Dokument weitergegeben. Andernfalls wird eine leere Auswahl zur\u00fcckgegeben."
  },
  {
    "code": "def xml(self, attribs = None,elements = None, skipchildren = False):\n        \"\"\"Serialises the FoLiA element to XML, by returning an XML Element (in lxml.etree) for this element and all its children. For string output, consider the xmlstring() method instead.\"\"\"\n        E = ElementMaker(namespace=NSFOLIA,nsmap={None: NSFOLIA, 'xml' : \"http://www.w3.org/XML/1998/namespace\"})\n\n        if not attribs: attribs = {}\n        if not elements: elements = []\n\n        if self.id:\n            attribs['id'] = self.id\n            try:\n                w = self.doc[self.id]\n                attribs['t'] = w.text()\n            except KeyError:\n                pass\n\n        e  = makeelement(E, '{' + NSFOLIA + '}' + self.XMLTAG, **attribs)\n        return e",
    "docstring": "Serialises the FoLiA element to XML, by returning an XML Element (in lxml.etree) for this element and all its children. For string output, consider the xmlstring() method instead.",
    "summary": "Sicher! Diese Funktion `xml` serialisiert ein FoLiA-Element (ein Element in einem FoLiA-Dokument, das ein XML-basiertes Format f\u00fcr linguistische Annotationen ist) in ein XML-Element. Hier ist eine einfache Erkl\u00e4rung, was die Funktion tut:\n\n1. **Eingabeparameter**:\n   - `attribs`: Ein optionales W\u00f6rterbuch mit Attributen, die dem XML-Element hinzugef\u00fcgt werden sollen.\n   - `elements`: Eine optionale Liste von untergeordneten Elementen, die dem XML-Element hinzugef\u00fcgt werden sollen.\n   - `skipchildren`: Ein optionaler boolescher Wert, der angibt, ob die untergeordneten Elemente \u00fcbersprungen werden sollen (Standard ist `False`).\n\n2. **Funktionsweise**:\n   - Die Funktion erstellt einen `ElementMaker` (ein Werkzeug aus der `lxml.etree`-Bibliothek), der verwendet wird, um XML-Elemente zu erstellen.\n   - Sie \u00fcberpr\u00fcft, ob `attribs` und `elements` angegeben wurden, und initialisiert sie mit leeren Werten, falls nicht.\n   - Wenn das FoLiA-Element eine `id` hat, f\u00fcgt sie diese als Attribut `id` zum XML-Element hinzu.\n   - Sie versucht auch, den Text des Elements aus dem Dokument abzurufen und f\u00fcgt ihn als Attribut `t` hinzu, falls m\u00f6glich.\n   - Schlie\u00dflich erstellt sie das XML-Element mit dem Tag `self.XMLTAG` und den angegebenen Attributen und gibt es zur\u00fcck.\n\n3. **R\u00fcckgabewert**:\n   - Die Funktion gibt ein XML-Element (in `lxml.etree`) zur\u00fcck, das das FoLiA-Element und seine untergeordneten Elemente (falls nicht \u00fcbersprungen) darstellt.\n\nZusammenfassend konvertiert diese Funktion ein FoLiA-Element in ein XML-Element, das in einem XML-Dokument verwendet werden kann. Sie ber\u00fccksichtigt dabei Attribute, untergeordnete Elemente und die ID des Elements."
  },
  {
    "code": "def annotation(self, type, set=None):\n        \"\"\"Will return a **single** annotation (even if there are multiple). Raises a ``NoSuchAnnotation`` exception if none was found\"\"\"\n        l = self.count(type,set,True,default_ignore_annotations)\n        if len(l) >= 1:\n            return l[0]\n        else:\n            raise NoSuchAnnotation()",
    "docstring": "Will return a **single** annotation (even if there are multiple). Raises a ``NoSuchAnnotation`` exception if none was found",
    "summary": "Sicher! Hier ist eine einfache Erkl\u00e4rung der Funktion auf Deutsch:\n\nDiese Funktion, namens `annotation`, sucht nach einer bestimmten **Annotation** (einem bestimmten Typ von Markierung oder Metadaten) in einem Objekt. Sie nimmt zwei Parameter entgegen:\n\n1. **`type`**: Der Typ der Annotation, nach der gesucht werden soll.\n2. **`set`**: Ein optionaler Parameter, der angibt, wo die Suche stattfinden soll (z. B. in einer bestimmten Menge von Daten).\n\nDie Funktion funktioniert wie folgt:\n\n1. Sie z\u00e4hlt, wie viele Annotationen des angegebenen Typs (`type`) vorhanden sind, indem sie die Methode `self.count` aufruft.\n2. Wenn mindestens eine Annotation gefunden wird (`len(l) >= 1`), gibt die Funktion die **erste** gefundene Annotation zur\u00fcck (`return l[0]`).\n3. Wenn keine Annotation gefunden wird, wirft die Funktion eine Ausnahme (`NoSuchAnnotation`), um anzuzeigen, dass die gesuchte Annotation nicht existiert.\n\nZusammengefasst: Die Funktion sucht nach einer bestimmten Annotation und gibt sie zur\u00fcck, falls sie gefunden wird. Wenn nicht, wird eine Fehlermeldung ausgel\u00f6st."
  },
  {
    "code": "def findspans(self, type,set=None):\n        \"\"\"Find span annotation of the specified type that include this word\"\"\"\n        if issubclass(type, AbstractAnnotationLayer):\n            layerclass = type\n        else:\n            layerclass = ANNOTATIONTYPE2LAYERCLASS[type.ANNOTATIONTYPE]\n        e = self\n        while True:\n            if not e.parent: break\n            e = e.parent\n            for layer in e.select(layerclass,set,False):\n                for e2 in layer:\n                    if isinstance(e2, AbstractSpanAnnotation):\n                        if self in e2.wrefs():\n                            yield e2",
    "docstring": "Find span annotation of the specified type that include this word",
    "summary": "Dieser Codeausschnitt ist eine Funktion namens `findspans`, die in einer Klasse definiert ist und in Python geschrieben wurde. Hier ist eine einfache Erkl\u00e4rung auf Deutsch:\n\nDie Funktion `findspans` sucht nach bestimmten Annotationen (Markierungen oder Beschriftungen) in einem Text, die ein bestimmtes Wort (das durch `self` dargestellt wird) enthalten. \n\n**So funktioniert sie:**\n\n1. **Eingabeparameter:**\n   - `type`: Der Typ der Annotation, nach der gesucht werden soll.\n   - `set` (optional): Eine spezifische Menge von Annotationen, in der gesucht werden soll.\n\n2. **\u00dcberpr\u00fcfung des Annotationstyps:**\n   - Die Funktion pr\u00fcft, ob `type` eine bestimmte Art von Annotation (abgeleitet von `AbstractAnnotationLayer`) ist.\n\n3. **Suche nach Annotationen:**\n   - Die Funktion durchl\u00e4uft die Hierarchie der Textelemente (beginnend mit dem aktuellen Element `self` und dann zu seinen \u00fcbergeordneten Elementen).\n   - Sie sucht nach Annotationen des angegebenen Typs (`layerclass`) in jedem \u00fcbergeordneten Element.\n\n4. **\u00dcberpr\u00fcfung der Annotationen:**\n   - F\u00fcr jede gefundene Annotation wird \u00fcberpr\u00fcft, ob sie ein `AbstractSpanAnnotation` ist (also eine Annotation, die einen Textabschnitt markiert).\n   - Es wird gepr\u00fcft, ob das aktuelle Wort (`self`) in den referenzierten W\u00f6rtern (`wrefs`) dieser Annotation enthalten ist.\n\n5. **Ergebnis:**\n   - Wenn eine passende Annotation gefunden wird, gibt die Funktion sie zur\u00fcck (mittels `yield`, was bedeutet, dass sie eine Folge von Annotationen erzeugt, die die Bedingung erf\u00fcllen).\n\n**Zusammenfassend:** Die Funktion `findspans` hilft dabei, alle Annotationen eines bestimmten Typs zu finden, die ein bestimmtes Wort in einem Text enthalten."
  },
  {
    "code": "def correctwords(self, originalwords, newwords, **kwargs):\n        \"\"\"Generic correction method for words. You most likely want to use the helper functions\n           :meth:`Sentence.splitword` , :meth:`Sentence.mergewords`, :meth:`deleteword`, :meth:`insertword` instead\"\"\"\n        for w in originalwords:\n            if not isinstance(w, Word):\n                raise Exception(\"Original word is not a Word instance: \" + str(type(w)))\n            elif w.sentence() != self:\n                raise Exception(\"Original not found as member of sentence!\")\n        for w in newwords:\n            if not isinstance(w, Word):\n                raise Exception(\"New word is not a Word instance: \" + str(type(w)))\n        if 'suggest' in kwargs and kwargs['suggest']:\n            del kwargs['suggest']\n            return self.correct(suggestion=newwords,current=originalwords, **kwargs)\n        else:\n            return self.correct(original=originalwords, new=newwords, **kwargs)",
    "docstring": "Generic correction method for words. You most likely want to use the helper functions\n           :meth:`Sentence.splitword` , :meth:`Sentence.mergewords`, :meth:`deleteword`, :meth:`insertword` instead",
    "summary": "Diese Funktion, `correctwords`, dient dazu, W\u00f6rter in einem Satz zu korrigieren oder zu ersetzen. Hier ist eine einfache Erkl\u00e4rung, was sie macht:\n\n1. **Eingabeparameter**:\n   - `originalwords`: Die W\u00f6rter, die ersetzt oder korrigiert werden sollen.\n   - `newwords`: Die neuen W\u00f6rter, die anstelle der urspr\u00fcnglichen W\u00f6rter eingesetzt werden sollen.\n   - `**kwargs`: Zus\u00e4tzliche Optionen, die an die Funktion \u00fcbergeben werden k\u00f6nnen.\n\n2. **\u00dcberpr\u00fcfungen**:\n   - Die Funktion pr\u00fcft, ob die `originalwords` und `newwords` tats\u00e4chlich Instanzen der Klasse `Word` sind. Wenn nicht, wird ein Fehler ausgel\u00f6st.\n   - Es wird auch \u00fcberpr\u00fcft, ob die `originalwords` tats\u00e4chlich zum aktuellen Satz geh\u00f6ren. Wenn nicht, wird ebenfalls ein Fehler ausgel\u00f6st.\n\n3. **Korrekturmodus**:\n   - Wenn das Argument `suggest` in `kwargs` vorhanden ist und `True` ist, wird die Korrektur als Vorschlag behandelt. In diesem Fall werden die `newwords` als Vorschlag und die `originalwords` als aktuelle W\u00f6rter an die `correct`-Methode \u00fcbergeben.\n   - Wenn `suggest` nicht vorhanden ist oder `False` ist, werden die `originalwords` durch die `newwords` direkt ersetzt, indem sie an die `correct`-Methode \u00fcbergeben werden.\n\n4. **R\u00fcckgabe**:\n   - Die Funktion gibt das Ergebnis der `correct`-Methode zur\u00fcck, das den korrigierten Satz oder die korrigierten W\u00f6rter enth\u00e4lt.\n\nZusammengefasst: Die Funktion erm\u00f6glicht es, bestimmte W\u00f6rter in einem Satz durch neue W\u00f6rter zu ersetzen, entweder direkt oder als Vorschlag, und stellt sicher, dass die Eingaben korrekt formatiert sind. Es wird empfohlen, stattdessen Hilfsfunktionen wie `splitword`, `mergewords`, `deleteword` oder `insertword` zu verwenden, die auf dieser generischen Methode aufbauen."
  },
  {
    "code": "def splitword(self, originalword, *newwords, **kwargs):\n        \"\"\"TODO: Write documentation\"\"\"\n        if isstring(originalword):\n            originalword = self.doc[u(originalword)]\n        return self.correctwords([originalword], newwords, **kwargs)",
    "docstring": "TODO: Write documentation",
    "summary": "Sicher! Diese Funktion, `splitword`, scheint ein Teil einer gr\u00f6\u00dferen Klasse zu sein (da sie `self` als erstes Argument hat). Hier ist eine einfache Erkl\u00e4rung, was sie tut:\n\n1. **Eingaben**: Die Funktion nimmt ein `originalword` (das urspr\u00fcngliche Wort) und eine beliebige Anzahl von `newwords` (neue W\u00f6rter) als Argumente entgegen. Zus\u00e4tzlich kann sie optionale Keyword-Argumente (`**kwargs`) akzeptieren.\n\n2. **\u00dcberpr\u00fcfung des urspr\u00fcnglichen Wortes**: Die Funktion pr\u00fcft, ob `originalword` ein String ist. Wenn ja, wird es in ein anderes Format umgewandelt, indem es mit `self.doc[u(originalword)]` ersetzt wird. Hierbei wird wahrscheinlich ein W\u00f6rterbuch (`self.doc`) verwendet, um das Wort in eine andere Form zu bringen.\n\n3. **Korrektur der W\u00f6rter**: Die Funktion ruft dann eine andere Methode namens `correctwords` auf, die das urspr\u00fcngliche Wort (`originalword`) und die neuen W\u00f6rter (`newwords`) als Eingabe erh\u00e4lt. Diese Methode scheint die W\u00f6rter zu korrigieren oder zu bearbeiten, basierend auf den \u00fcbergebenen Argumenten und den optionalen Keyword-Argumenten (`**kwargs`).\n\n4. **R\u00fcckgabe**: Das Ergebnis der `correctwords`-Methode wird zur\u00fcckgegeben.\n\nZusammengefasst: Die Funktion `splitword` nimmt ein urspr\u00fcngliches Wort und neue W\u00f6rter entgegen, wandelt das urspr\u00fcngliche Wort gegebenenfalls um und gibt dann das Ergebnis einer Korrektur- oder Bearbeitungsoperation auf diesen W\u00f6rtern zur\u00fcck. Die genaue Art der Korrektur oder Bearbeitung h\u00e4ngt von der Implementierung der `correctwords`-Methode ab."
  },
  {
    "code": "def mergewords(self, newword, *originalwords, **kwargs):\n        \"\"\"TODO: Write documentation\"\"\"\n        return self.correctwords(originalwords, [newword], **kwargs)",
    "docstring": "TODO: Write documentation",
    "summary": "Sicher! Diese Funktion, `mergewords`, scheint Teil einer gr\u00f6\u00dferen Klasse zu sein (da sie `self` als erstes Argument hat). Hier ist eine einfache Erkl\u00e4rung, was sie tut:\n\n1. **Eingaben**:  \n   - `newword`: Ein neues Wort, das hinzugef\u00fcgt werden soll.  \n   - `*originalwords`: Eine beliebige Anzahl von urspr\u00fcnglichen W\u00f6rtern (als Tupel).  \n   - `**kwargs`: Optionale zus\u00e4tzliche Parameter (als Dictionary).  \n\n2. **Funktion**:  \n   Die Funktion ruft eine andere Methode der Klasse namens `correctwords` auf und \u00fcbergibt ihr:  \n   - Die urspr\u00fcnglichen W\u00f6rter (`originalwords`).  \n   - Eine Liste, die nur das neue Wort (`newword`) enth\u00e4lt.  \n   - Die optionalen Parameter (`**kwargs`).  \n\n3. **Ausgabe**:  \n   Die Funktion gibt das Ergebnis von `self.correctwords` zur\u00fcck, das wahrscheinlich eine korrigierte oder bearbeitete Version der W\u00f6rter ist.  \n\nZusammengefasst: Die Funktion kombiniert ein neues Wort mit den urspr\u00fcnglichen W\u00f6rtern und l\u00e4sst sie dann von einer anderen Methode (`correctwords`) bearbeiten."
  },
  {
    "code": "def deleteword(self, word, **kwargs):\n        \"\"\"TODO: Write documentation\"\"\"\n        if isstring(word):\n            word = self.doc[u(word)]\n        return self.correctwords([word], [], **kwargs)",
    "docstring": "TODO: Write documentation",
    "summary": "Diese Funktion, `deleteword`, scheint ein Wort aus einer Art Dokument oder Liste zu entfernen. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **Eingabepr\u00fcfung**: Die Funktion \u00fcberpr\u00fcft zun\u00e4chst, ob das \u00fcbergebene `word` ein String ist. Wenn ja, wird es in ein spezifisches Format umgewandelt (vermutlich f\u00fcr die interne Verarbeitung).\n\n2. **Wort entfernen**: Das Wort wird dann aus einer Liste oder einem Dokument (`self.doc`) entfernt.\n\n3. **Korrektur**: Nach dem Entfernen des Wortes wird eine weitere Funktion (`self.correctwords`) aufgerufen, die wahrscheinlich sicherstellt, dass die verbleibenden W\u00f6rter korrekt sind oder bestimmte Regeln befolgen.\n\n4. **R\u00fcckgabe**: Die Funktion gibt das Ergebnis der Korrektur zur\u00fcck.\n\nZusammengefasst: Die Funktion entfernt ein bestimmtes Wort und stellt sicher, dass die verbleibenden W\u00f6rter in einem korrekten Zustand sind."
  },
  {
    "code": "def insertwordleft(self, newword, nextword, **kwargs):\n        \"\"\"Inserts a word **as a correction** before an existing word.\n\n        Reverse of :meth:`Sentence.insertword`.\n        \"\"\"\n        if nextword:\n            if isstring(nextword):\n                nextword = self.doc[u(nextword)]\n            if not nextword in self or not isinstance(nextword, Word):\n                raise Exception(\"Next word not found or not instance of Word!\")\n            if isinstance(newword, list) or isinstance(newword, tuple):\n                if not all([ isinstance(x, Word) for x in newword ]):\n                    raise Exception(\"New word (iterable) constains non-Word instances!\")\n            elif not isinstance(newword, Word):\n                raise Exception(\"New word no instance of Word!\")\n\n            kwargs['insertindex'] = self.getindex(nextword)\n        else:\n            kwargs['insertindex'] = 0\n        kwargs['nooriginal'] = True\n        if isinstance(newword, list) or isinstance(newword, tuple):\n            return self.correctwords([], newword, **kwargs)\n        else:\n            return self.correctwords([], [newword], **kwargs)",
    "docstring": "Inserts a word **as a correction** before an existing word.\n\n        Reverse of :meth:`Sentence.insertword`.",
    "summary": "Diese Funktion, `insertwordleft`, f\u00fcgt ein neues Wort **als Korrektur** vor einem bereits vorhandenen Wort in einem Satz ein. \n Hier ist eine detailliertere Erkl\u00e4rung:\n\n1. **Eingabeparameter:**\n   - `newword`: Das neue Wort, das eingef\u00fcgt werden soll. Es kann entweder ein einzelnes `Word`-Objekt oder eine Liste/Tupel von `Word`-Objekten sein.\n   - `nextword`: Das Wort, vor dem das neue Wort eingef\u00fcgt werden soll. Es kann entweder ein String (der Name des Wortes) oder ein `Word`-Objekt sein.\n   - `**kwargs`: Zus\u00e4tzliche Optionen, die an die Funktion \u00fcbergeben werden k\u00f6nnen.\n\n2. **Funktionsweise:**\n   - **\u00dcberpr\u00fcfung von `nextword`:** Die Funktion pr\u00fcft, ob `nextword` ein g\u00fcltiges Wort im Satz ist. Wenn es ein String ist, wird es in das entsprechende `Word`-Objekt umgewandelt.\n   - **Fehlerbehandlung:** Wenn `nextword` nicht gefunden wird oder kein `Word`-Objekt ist, wird eine Ausnahme ausgel\u00f6st.\n   - **\u00dcberpr\u00fcfung von `newword`:** Die Funktion pr\u00fcft, ob `newword` ein g\u00fcltiges `Word`-Objekt (oder eine Liste/Tupel davon) ist. Wenn nicht, wird eine Ausnahme ausgel\u00f6st.\n   - **Bestimmung der Einf\u00fcgeposition:** Die Position, an der das neue Wort eingef\u00fcgt werden soll, wird basierend auf der Position von `nextword` bestimmt.\n   - **Einf\u00fcgen des neuen Wortes:** Das neue Wort wird als Korrektur vor `nextword` eingef\u00fcgt. Die Funktion `correctwords` wird verwendet, um die Einf\u00fcgung durchzuf\u00fchren.\n\n3. **R\u00fcckgabewert:**\n   - Die Funktion gibt das Ergebnis der `correctwords`-Funktion zur\u00fcck, das wahrscheinlich den modifizierten Satz oder eine Best\u00e4tigung der erfolgreichen Einf\u00fcgung enth\u00e4lt.\n\nZusammenfassend f\u00fcgt diese Funktion ein oder mehrere neue W\u00f6rter als Korrektur vor einem angegebenen Wort in einem Satz ein, wobei sichergestellt wird, dass die Eingaben g\u00fcltig sind und die Einf\u00fcgung an der richtigen Position erfolgt."
  },
  {
    "code": "def resolve(self,size, distribution):\n        \"\"\"Resolve a variable sized pattern to all patterns of a certain fixed size\"\"\"\n        if not self.variablesize():\n            raise Exception(\"Can only resize patterns with * wildcards\")\n\n        nrofwildcards = 0\n        for x in self.sequence:\n            if x == '*':\n                nrofwildcards += 1\n\n        assert (len(distribution) == nrofwildcards)\n\n        wildcardnr = 0\n        newsequence = []\n        for x in self.sequence:\n            if x == '*':\n                newsequence += [True] * distribution[wildcardnr]\n                wildcardnr += 1\n            else:\n                newsequence.append(x)\n        d = { 'matchannotation':self.matchannotation, 'matchannotationset':self.matchannotationset, 'casesensitive':self.casesensitive }\n        yield Pattern(*newsequence, **d )",
    "docstring": "Resolve a variable sized pattern to all patterns of a certain fixed size",
    "summary": "Dieser Code ist eine Funktion in Python, die ein Muster (Pattern) mit variabler L\u00e4nge in alle m\u00f6glichen Muster einer bestimmten festen L\u00e4nge umwandelt. Hier ist eine einfache Erkl\u00e4rung in Deutsch:\n\n1. **\u00dcberpr\u00fcfung der Variablengr\u00f6\u00dfe**: Die Funktion pr\u00fcft zun\u00e4chst, ob das Muster tats\u00e4chlich eine variable Gr\u00f6\u00dfe hat (d.h., es enth\u00e4lt Platzhalter wie `*`). Wenn nicht, wird ein Fehler ausgel\u00f6st.\n\n2. **Z\u00e4hlen der Platzhalter**: Die Funktion z\u00e4hlt, wie viele Platzhalter (`*`) im Muster vorhanden sind.\n\n3. **Verteilung der Platzhalter**: Es wird \u00fcberpr\u00fcft, ob die angegebene Verteilung (`distribution`) genau so viele Eintr\u00e4ge hat wie es Platzhalter gibt. Diese Verteilung gibt an, wie viele Zeichen an der Stelle jedes Platzhalters eingef\u00fcgt werden sollen.\n\n4. **Erstellen des neuen Musters**: Die Funktion durchl\u00e4uft das urspr\u00fcngliche Muster und ersetzt jeden Platzhalter durch die entsprechende Anzahl von `True`-Werten (basierend auf der Verteilung). Andere Zeichen bleiben unver\u00e4ndert.\n\n5. **Erstellen und R\u00fcckgabe des neuen Musters**: Das neue Muster wird als ein `Pattern`-Objekt erstellt und zur\u00fcckgegeben. Dabei werden auch zus\u00e4tzliche Eigenschaften wie `matchannotation`, `matchannotationset` und `casesensitive` beibehalten.\n\n**Zusammenfassung**: Die Funktion nimmt ein Muster mit Platzhaltern und eine Verteilung, die angibt, wie viele Zeichen an die Stelle der Platzhalter eingef\u00fcgt werden sollen, und erzeugt daraus ein neues Muster mit fester L\u00e4nge."
  },
  {
    "code": "def load(self, filename):\n        \"\"\"Load a FoLiA XML file.\n\n        Argument:\n            filename (str): The file to load\n        \"\"\"\n        #if LXE and self.mode != Mode.XPATH:\n        #    #workaround for xml:id problem (disabled)\n        #    #f = open(filename)\n        #    #s = f.read().replace(' xml:id=', ' id=')\n        #    #f.close()\n        #    self.tree = ElementTree.parse(filename)\n        #else:\n        self.tree = xmltreefromfile(filename)\n        self.parsexml(self.tree.getroot())\n        if self.mode != Mode.XPATH:\n            #XML Tree is now obsolete (only needed when partially loaded for xpath queries)\n            self.tree = None",
    "docstring": "Load a FoLiA XML file.\n\n        Argument:\n            filename (str): The file to load",
    "summary": "Dieser Codeausschnitt ist eine Funktion in Python, die Teil einer Klasse ist (erkennbar am `self`-Parameter). Die Funktion `load` dient dazu, eine XML-Datei im FoLiA-Format zu laden und zu verarbeiten. Hier ist eine einfache Erkl\u00e4rung, was die Funktion tut:\n\n1. **Datei laden**: Die Funktion nimmt den Dateinamen (`filename`) als Eingabe und l\u00e4dt die entsprechende XML-Datei.  \n2. **XML-Baum erstellen**: Sie erstellt einen XML-Baum (eine strukturierte Darstellung der XML-Datei) mithilfe der Funktion `xmltreefromfile`.  \n3. **XML parsen**: Die Methode `parsexml` wird aufgerufen, um den XML-Baum zu analysieren und die Daten zu verarbeiten.  \n4. **Speicher freigeben**: Wenn der Modus nicht `XPATH` ist, wird der XML-Baum (`self.tree`) auf `None` gesetzt, um Speicher freizugeben, da er nicht mehr ben\u00f6tigt wird.  \n\nZusammengefasst: Die Funktion l\u00e4dt eine FoLiA-XML-Datei, verarbeitet ihren Inhalt und bereinigt danach den Speicher, falls n\u00f6tig."
  },
  {
    "code": "def items(self):\n        \"\"\"Returns a depth-first flat list of all items in the document\"\"\"\n        l = []\n        for e in self.data:\n            l += e.items()\n        return l",
    "docstring": "Returns a depth-first flat list of all items in the document",
    "summary": "Sicher! Diese Funktion, `items(self)`, gibt eine flache Liste aller Elemente in einem Dokument zur\u00fcck, und zwar in der Reihenfolge, in der sie beim Durchlaufen des Dokuments von oben nach unten (Depth-First) gefunden werden.\n\nHier ist eine einfache Erkl\u00e4rung:\n\n1. **Initialisierung**: Es wird eine leere Liste `l` erstellt, in der sp\u00e4ter alle Elemente gespeichert werden.\n2. **Durchlauf der Daten**: Die Funktion durchl\u00e4uft jedes Element `e` in `self.data`, das wahrscheinlich eine Sammlung von Elementen oder Unterelementen des Dokuments ist.\n3. **Rekursive Sammlung**: F\u00fcr jedes Element `e` wird die Methode `e.items()` aufgerufen, die alle Elemente des aktuellen Elements (einschlie\u00dflich seiner Unterelemente) zur\u00fcckgibt. Diese Elemente werden dann zur Liste `l` hinzugef\u00fcgt.\n4. **R\u00fcckgabe der Liste**: Nachdem alle Elemente durchlaufen wurden, gibt die Funktion die Liste `l` zur\u00fcck, die nun alle Elemente des Dokuments in einer flachen Liste enth\u00e4lt.\n\nZusammengefasst: Die Funktion sammelt alle Elemente eines Dokuments (einschlie\u00dflich der in verschachtelten Strukturen) und gibt sie in einer einfachen, flachen Liste zur\u00fcck."
  },
  {
    "code": "def xpath(self, query):\n        \"\"\"Run Xpath expression and parse the resulting elements. Don't forget to use the FoLiA namesapace in your expressions, using folia: or the short form f: \"\"\"\n        for result in self.tree.xpath(query,namespaces={'f': 'http://ilk.uvt.nl/folia','folia': 'http://ilk.uvt.nl/folia' }):\n            yield self.parsexml(result)",
    "docstring": "Run Xpath expression and parse the resulting elements. Don't forget to use the FoLiA namesapace in your expressions, using folia: or the short form f:",
    "summary": "Diese Funktion f\u00fchrt eine **XPath-Abfrage** auf einem XML-Dokument aus und verarbeitet die gefundenen Elemente. Hier ist eine einfache Erkl\u00e4rung:\n\n1. **XPath-Abfrage ausf\u00fchren**: Die Funktion nimmt eine XPath-Abfrage (`query`) entgegen und sucht im XML-Dokument (das in `self.tree` gespeichert ist) nach den Elementen, die dieser Abfrage entsprechen.  \n\n2. **Namespace ber\u00fccksichtigen**: Die Funktion verwendet automatisch den **FoLiA-Namespace** (ein spezifisches XML-Schema), damit die Abfrage korrekt funktioniert. Du kannst in deiner Abfrage entweder `folia:` oder das K\u00fcrzel `f:` verwenden, um auf Elemente dieses Namespace zuzugreifen.  \n\n3. **Ergebnisse verarbeiten**: F\u00fcr jedes gefundene Element wird die Methode `self.parsexml` aufgerufen, um das Element weiter zu verarbeiten. Die Ergebnisse werden nacheinander zur\u00fcckgegeben (\u00fcber `yield`), sodass du sie Schritt f\u00fcr Schritt verwenden kannst.  \n\n**Zusammengefasst**: Die Funktion hilft dir, bestimmte Teile eines FoLiA-XML-Dokuments mit XPath zu finden und zu verarbeiten, ohne dass du dich um den Namespace k\u00fcmmern musst."
  }
]